---
title: 07 多态与虚函数
tags:
categories:
- language
- cpp
---

## **多态**
C++ 虚函数对于多态具有决定性的作用，有虚函数才能构成多态.  
 * 1. 只需要在虚函数的声明处加上 virtual 关键字，函数定义处可以加也可以不加.
 * 2. 可以只将基类中的函数声明为虚函数，这样所有派生类中具有遮蔽关系的同名函数都将自动成为虚函数, 派生类可以不添加virtual关键字.
 * 3. 当在基类中定义了虚函数时，如果派生类没有定义新的函数来遮蔽此函数，那么将使用基类的虚函数.
 * 4. 只有派生类的虚函数覆盖基类的虚函数（函数原型相同）才能构成多态.
      如基类虚函数的原型为virtual void func();，派生类虚函数的原型为virtual void func(int);，那么当基类指针 p 指向派生类对象时，语句p -> func(100);将会出错，而语句p -> func();将调用基类的函数.  
 * 5. 构造函数不能是虚函数。对于基类的构造函数，它仅仅是在派生类构造函数中被调用，这种机制不同于继承。也就是说，派生类不继承基类的构造函数，将构造函数声明为虚函数没有什么意义.
 * 6. 析构函数可以声明为虚函数，而且有时候必须要声明为虚函数, 将基类的析构函数声明为虚函数后，派生类的析构函数也会自动成为虚函数.
 * 7. 存在基类的指针，通过该指针调用虚函数.

如果不使用多态，那么就需要定义多个指针变量，很容易造成混乱；而有了多态，只需要一个指针变量 p 就可以调用所有派生类的虚函数。

从这个例子中也可以发现，对于具有复杂继承关系的大中型程序，多态可以增加其灵活性，让代码更具有表现力。

### **什么时候声明虚函数**
首先看成员函数所在的类是否会作为基类。然后看成员函数在类的继承后有无可能被更改功能，如果希望更改其功能的，一般应该将它声明为虚函数。如果成员函数在类被继承后功能不需修改，或派生类用不到该函数，则不要把它声明为虚函数。  

### **指针实现多态**
有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为多态（Polymorphism）.  

C++提供多态的目的是：可以通过基类指针对所有派生类（包括直接派生和间接派生）的成员变量和成员函数进行“全方位”的访问，尤其是成员函数。如果没有多态，我们只能访问成员变量.  

	#include <iostream>
	using namespace std;
	
	//基类People
	class People
	{
	public:
	    People(char *name, int age);
	    virtual void display(); //声明为虚函数
	protected:
	    char *m_name;
	    int m_age;
	};
	People::People(char *name, int age) : m_name(name), m_age(age) {}
	void People::display()
	{
	    cout << m_name << "今年" << m_age << "岁了，是个无业游民。" << endl;
	}
	
	//派生类Teacher
	class Teacher : public People
	{
	public:
	    Teacher(char *name, int age, int salary);
	    virtual void display(); //声明为虚函数
	private:
	    int m_salary;
	};
	Teacher::Teacher(char *name, int age, int salary) : People(name, age), m_salary(salary) {}
	void Teacher::display()
	{
	    cout << m_name << "今年" << m_age << "岁了，是一名教师，每月有" << m_salary << "元的收入。" << endl;
	}
	
	int main()
	{
	    People *p = new People("王志刚", 23);
	    p->display();
	
	    p = new Teacher("赵宏佳", 45, 8200);
	    p->display();
	
	    return 0;
	}
运行结果：

	王志刚今年23岁了，是个无业游民。
	赵宏佳今年45岁了，是一名教师，每月有8200元的收入。



### 引用实现多态

引用在本质上是通过指针的方式实现的, 借助引用也可以实现多态.  

不过引用不像指针灵活，指针可以随时改变指向，而引用只能指代固定的对象，在多态性方面缺乏表现力，所以以后我们再谈及多态时一般是说指针.  

	int main(){
	    People p("王志刚", 23);
	    Teacher t("赵宏佳", 45, 8200);
	   
	    People &rp = p;
	    People &rt = t;
	   
	    rp.display();
	    rt.display();
	    return 0;
	}
运行结果：

	王志刚今年23岁了，是个无业游民。
	赵宏佳今年45岁了，是一名教师，每月有8200元的收入。

## **虚析构函数**
如果基类析构函数不定义为virtual, 如:

	Base *pb = new Derived();
	delete pb;
只调用了基类的析构函数，没有调用派生类的析构函数.  
不调用派生类的析构函数会导致 name 指向的 100 个 char 类型的内存空间得不到释放；除非程序运行结束由操作系统回收，否则就再也没有机会释放这些内存。这是典型的内存泄露.  
 * 析构函数是非虚函数，通过指针访问非虚函数时，编译器会根据指针的类型来确定要调用的函数；也就是说，指针指向哪个类就调用哪个类的函数.  
 * 将基类的析构函数声明为虚函数后，派生类的析构函数也会自动成为虚函数。这个时候编译器会忽略指针的类型，而根据指针的指向来选择函数；也就是说，指针指向哪个类的对象就调用哪个类的函数.  
 **`在执行派生类的析构函数的过程中，又会调用基类的析构函数。派生类析构函数始终会调用基类的析构函数，并且这个过程是隐式完成的.`**
 
在实际开发中，一旦我们自己定义了析构函数，就是希望在对象销毁时用它来进行清理工作，比如释放内存、关闭文件等，如果这个类又是一个基类，那么我们就必须将该析构函数声明为虚函数，否则就有内存泄露的风险。也就是说，大部分情况下都应该将基类的析构函数声明为虚函数.  

	#include <iostream>
	using namespace std;
	
	//基类
	class Base
	{
	public:
	    Base();
	    virtual ~Base();
	
	protected:
	    char *str;
	};
	Base::Base()
	{
	    str = new char[100];
	    cout << "Base constructor" << endl;
	}
	Base::~Base()
	{
	    delete[] str;
	    cout << "Base destructor" << endl;
	}
	
	//派生类
	class Derived : public Base
	{
	public:
	    Derived();
	    ~Derived();
	
	private:
	    char *name;
	};
	Derived::Derived()
	{
	    name = new char[100];
	    cout << "Derived constructor" << endl;
	}
	Derived::~Derived()
	{
	    delete[] name;
	    cout << "Derived destructor" << endl;
	}
	
	int main()
	{
	    Base *pb = new Derived();
	    delete pb;
	
	    cout << "-------------------" << endl;
	
	    Derived *pd = new Derived();
	    delete pd;
	
	    return 0;
	}
运行结果：

	Base constructor
	Derived constructor
	Derived destructor
	Base destructor
	-------------------
	Base constructor
	Derived constructor
	Derived destructor
	Base destructor

## **纯虚函数 & 抽象类**
可以将虚函数声明为纯虚函数，语法格式为：

	virtual 返回值类型 函数名 (函数参数) = 0;
纯虚函数没有函数体，只有函数声明，在虚函数声明的结尾加上=0，表明此函数为纯虚函数。
> 最后的=0并不表示函数返回值为0，它只起形式上的作用，告诉编译系统“这是纯虚函数”。
**`包含纯虚函数的类称为抽象类（Abstract Class）`**。之所以说它抽象，是因为它无法实例化，也就是无法创建对象。原因很明显，纯虚函数没有函数体，不是完整的函数，无法调用，也无法为其分配内存空间。  

抽象类通常是作为基类，让派生类去实现纯虚函数。派生类必须实现纯虚函数才能被实例化.

1. 一个纯虚函数就可以使类成为抽象基类，但是抽象基类中除了包含纯虚函数外，还可以包含其它的成员函数（虚函数或普通函数）和成员变量。

2. 只有类中的虚函数才能被声明为纯虚函数，普通成员函数和顶层函数均不能声明为纯虚函数。如下例所示：


	//顶层函数不能被声明为纯虚函数
	void fun() = 0;   //compile error
	class base{
	public :
	    //普通成员函数不能被声明为纯虚函数
	    void display() = 0;  //compile error
	};


	#include <iostream>
	using namespace std;
	
	//线
	class Line    // 最顶层的基类，在 Line 类中定义了两个纯虚函数 area() 和 volume()
	{
	public:
	    Line(float len);
	    virtual float area() = 0;
	    virtual float volume() = 0;
	
	protected:
	    float m_len;
	};
	Line::Line(float len) : m_len(len) {}
	
	//矩形
	class Rec : public Line    // Rec 也仍然是抽象类, 没有实现继承来的 volume() 函数，volume() 仍然是纯虚函数
	{
	public:
	    Rec(float len, float width);
	    float area();
	
	protected:
	    float m_width;
	};
	Rec::Rec(float len, float width) : Line(len), m_width(width) {}
	float Rec::area() { return m_len * m_width; }
	
	//长方体
	class Cuboid : public Rec
	{
	public:
	    Cuboid(float len, float width, float height);
	    float area();
	    float volume();
	
	protected:
	    float m_height;
	};
	Cuboid::Cuboid(float len, float width, float height) : Rec(len, width), m_height(height) {}
	float Cuboid::area() { return 2 * (m_len * m_width + m_len * m_height + m_width * m_height); }
	float Cuboid::volume() { return m_len * m_width * m_height; }
	
	//正方体
	class Cube : public Cuboid
	{
	public:
	    Cube(float len);
	    float area();
	    float volume();
	};
	Cube::Cube(float len) : Cuboid(len, len, len) {}
	float Cube::area() { return 6 * m_len * m_len; }
	float Cube::volume() { return m_len * m_len * m_len; }
	
	int main()
	{
	    Line *p = new Cuboid(10, 20, 30);
	    cout << "The area of Cuboid is " << p->area() << endl;
	    cout << "The volume of Cuboid is " << p->volume() << endl;
	
	    p = new Cube(15);
	    cout << "The area of Cube is " << p->area() << endl;
	    cout << "The volume of Cube is " << p->volume() << endl;
	
	    return 0;
	}
运行结果：

	The area of Cuboid is 2200
	The volume of Cuboid is 6000
	The area of Cube is 1350
	The volume of Cube is 3375
本例中定义了四个类，它们的继承关系为：Line --> Rec --> Cuboid --> Cube。

在 Rec 类中，实现了 area() 函数；所谓实现，就是定义了纯虚函数的函数体。但这时 Rec 仍不能被实例化，因为它没有实现继承来的 volume() 函数，volume() 仍然是纯虚函数，所以 Rec 也仍然是抽象类.  

抽象基类除了约束派生类的功能，还可以实现多态。请注意第 51 行代码，指针 p 的类型是 Line，但是它却可以访问派生类中的 area() 和 volume() 函数，正是由于在 Line 类中将这两个函数定义为纯虚函数；如果不这样做，51 行后面的代码都是错误的.  









