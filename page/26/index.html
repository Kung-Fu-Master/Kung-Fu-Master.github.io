<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.1" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://kung-fu-master.github.io/page/26/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Kung-Fu-Master">
<meta name="twitter:card" content="summary"><title>Hexo</title><link ref="canonical" href="https://kung-fu-master.github.io/page/26/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: true,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return false;"><span class="header-nav-menu-item__icon"><i class="fas fa-feather-alt"></i></span><span class="header-nav-menu-item__text">文章</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/categories/"><span class="header-nav-submenu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-submenu-item__text">分类</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/archives/"><span class="header-nav-submenu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-submenu-item__text">归档</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/tags/"><span class="header-nav-submenu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-submenu-item__text">标签</span></a></div></div></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-fingerprint"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Hexo</div><div class="header-banner-info__subtitle"></div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/03/13/reference/k8s/05.%E7%99%BD%E8%AF%9D%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80(%E4%B8%80)%E4%BB%8E%E8%BF%9B%E7%A8%8B%E8%AF%B4%E5%BC%80%E5%8E%BB/">05 | 白话容器基础（一）：从进程说开去</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">3k</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="2.jpg"  alt="">
      </p>
<p>在前面的 4 篇预习文章中，我梳理了“容器”这项技术的来龙去脉，通过这些内容，我希望你能理解如下几个事实：</p>
<ul>
<li>容器技术的兴起源于 PaaS 技术的普及；</li>
<li>Docker 公司发布的 Docker 项目具有里程碑式的意义；</li>
<li>Docker 项目通过“容器镜像”，解决了应用打包这个根本性难题。<br>紧接着，我详细介绍了容器技术圈在过去五年里的“风云变幻”，而通过这部分内容，我希望你能理解这样一个道理：</li>
</ul>
<blockquote>
<p>容器本身没有价值，有价值的是“容器编排”。</p>
</blockquote>
<p>也正因为如此，容器技术生态才爆发了一场关于“容器编排”的“战争”。<strong><code>而这次战争，最终以 Kubernetes 项目和 CNCF 社区的胜利而告终。</code></strong>所以，这个专栏后面的内容，我会以 Docker 和 Kubernetes 项目为核心，为你详细介绍容器技术的各项实践与其中的原理。</p>
<p>不过在此之前，你还需要搞清楚一个更为基础的问题：</p>
<blockquote>
<p>容器，到底是怎么一回事儿？</p>
</blockquote>
<p>在第一篇预习文章《小鲸鱼大事记（一）：初出茅庐》中，我已经提到过，容器其实是一种沙盒技术。顾名思义，沙盒就是能够像一个集装箱一样，把你的应用“装”起来的技术。这样，应用与应用之间，就因为有了边界而不至于相互干扰；而被装进集装箱的应用，也可以被方便地搬来搬去，这不就是 PaaS 最理想的状态嘛。</p>
<p>不过，这两个能力说起来简单，但要用技术手段去实现它们，可能大多数人就无从下手了。</p>
<p>所以，我就先来跟你说说这个“边界”的实现手段。</p>
<p>假如，现在你要写一个计算加法的小程序，这个程序需要的输入来自于一个文件，计算完成后的结果则输出到另一个文件中。</p>
<p>由于计算机只认识 0 和 1，所以无论用哪种语言编写这段代码，最后都需要通过某种方式翻译成二进制文件，才能在计算机操作系统中运行起来。</p>
<p>而为了能够让这些代码正常运行，我们往往还要给它提供数据，比如我们这个加法程序所需要的输入文件。这些数据加上代码本身的二进制文件，放在磁盘上，就是我们平常所说的一个“程序”，也叫代码的可执行镜像（executable image）。</p>
<p>然后，我们就可以在计算机上运行这个“程序”了。</p>
<p>首先，操作系统从“程序”中发现输入数据保存在一个文件中，所以这些数据就被会加载到内存中待命。同时，操作系统又读取到了计算加法的指令，这时，它就需要指示 CPU 完成加法操作。而 CPU 与内存协作进行加法计算，又会使用寄存器存放数值、内存堆栈保存执行的命令和变量。同时，计算机里还有被打开的文件，以及各种各样的 I/O 设备在不断地调用中修改自己的状态。</p>
<p>就这样，一旦“程序”被执行起来，它就从磁盘上的二进制文件，变成了计算机内存中的数据、寄存器里的值、堆栈中的指令、被打开的文件，以及各种设备的状态信息的一个集合。<code>像这样一个程序运起来后的计算机执行环境的总和，就是我们今天的主角：进程。</code></p>
<p>所以，对于进程来说，它的静态表现就是程序，平常都安安静静地待在磁盘上；而一旦运行起来，它就变成了计算机里的数据和状态的总和，这就是它的动态表现。</p>
<p>而<code>容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”。</code></p>
<p>对于 Docker 等大多数 Linux 容器来说，<code>Cgroups</code> 技术是用来制造约束的主要手段，而 <code>Namespace</code> 技术则是用来修改进程视图的主要方法。</p>
<p>你可能会觉得 Cgroups 和 Namespace 这两个概念很抽象，别担心，接下来我们一起动手实践一下，你就很容易理解这两项技术了。</p>
<p>假设你已经有了一个 Linux 操作系统上的 Docker 项目在运行，比如我的环境是 Ubuntu 16.04 和 Docker CE 18.05。</p>
<p>接下来，让我们首先创建一个容器来试试。</p>
<pre><code>$ docker run -it busybox /bin/sh
/ #</code></pre><p>这个命令是 Docker 项目最重要的一个操作，即大名鼎鼎的 docker run。</p>
<p>而 -it 参数告诉了 Docker 项目在启动容器后，需要给我们分配一个文本输入 / 输出环境，也就是 TTY，跟容器的标准输入相关联，这样我们就可以和这个 Docker 容器进行交互了。而 /bin/sh 就是我们要在 Docker 容器里运行的程序。</p>
<p>所以，上面这条指令翻译成人类的语言就是：请帮我启动一个容器，在容器里执行 /bin/sh，并且给我分配一个命令行终端跟这个容器交互。</p>
<p>这样，我的 Ubuntu 16.04 机器就变成了一个宿主机，而一个运行着 /bin/sh 的容器，就跑在了这个宿主机里面。</p>
<p>上面的例子和原理，如果你已经玩过 Docker，一定不会感到陌生。此时，如果我们在容器里执行一下 ps 指令，就会发现一些更有趣的事情：</p>
<pre><code>/ # ps
PID  USER   TIME COMMAND
  1  root   0:00 /bin/sh
  10 root   0:00 ps</code></pre><p>可以看到，我们在 Docker 里最开始执行的 /bin/sh，就是这个容器内部的第 1 号进程（PID=1），而这个容器里一共只有两个进程在运行。这就意味着，前面执行的 /bin/sh，以及我们刚刚执行的 ps，已经被 Docker 隔离在了一个跟宿主机完全不同的世界当中。</p>
<p>这究竟是怎么做到呢？</p>
<p>本来，每当我们在宿主机上运行了一个 /bin/sh 程序，操作系统都会给它分配一个进程编号，比如 PID=100。这个编号是进程的唯一标识，就像员工的工牌一样。所以 PID=100，可以粗略地理解为这个 /bin/sh 是我们公司里的第 100 号员工，而第 1 号员工就自然是比尔 · 盖茨这样统领全局的人物。</p>
<p>而现在，我们要通过 Docker 把这个 /bin/sh 程序运行在一个容器当中。这时候，Docker 就会在这个第 100 号员工入职时给他施一个“障眼法”，让他永远看不到前面的其他 99 个员工，更看不到比尔 · 盖茨。这样，他就会错误地以为自己就是公司里的第 1 号员工。</p>
<p><code>这种机制，其实就是对被隔离应用的进程空间做了手脚，使得这些进程只能看到重新计算过的进程编号，比如 PID=1。可实际上，他们在宿主机的操作系统里，还是原来的第 100 号进程。</code></p>
<p><code>这种技术，就是 Linux 里面的 Namespace 机制。</code>而 Namespace 的使用方式也非常有意思：它其实只是 Linux 创建新进程的一个可选参数。我们知道，在 Linux 系统中创建线程的系统调用是 clone()，比如：</p>
<pre><code>int pid = clone(main_function, stack_size, SIGCHLD, NULL); </code></pre><p>这个系统调用就会为我们创建一个新的进程，并且返回它的进程号 pid。</p>
<p>而当我们用 clone() 系统调用创建一个新进程时，就可以在参数中指定 CLONE_NEWPID 参数，比如：</p>
<pre><code>int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL); </code></pre><p>这时，新创建的这个进程将会“看到”一个全新的进程空间，在这个进程空间里，它的 PID 是 1。之所以说“看到”，是因为这只是一个“障眼法”，在宿主机真实的进程空间里，这个进程的 PID 还是真实的数值，比如 100。</p>
<p>当然，我们还可以多次执行上面的 clone() 调用，这样就会创建多个 PID Namespace，而每个 Namespace 里的应用进程，都会认为自己是当前容器里的第 1 号进程，它们既看不到宿主机里真正的进程空间，也看不到其他 PID Namespace 里的具体情况。</p>
<p>而<code>除了我们刚刚用到的 PID Namespace，Linux 操作系统还提供了 Mount、UTS、IPC、Network 和 User 这些 Namespace，用来对各种不同的进程上下文进行“障眼法”操作。</code></p>
<p>比如，Mount Namespace，用于让被隔离进程只看到当前 Namespace 里的挂载点信息；Network Namespace，用于让被隔离进程看到当前 Namespace 里的网络设备和配置。</p>
<p>这，<code>就是 Linux 容器最基本的实现原理了。</code></p>
<p>所以，<code>Docker 容器这个听起来玄而又玄的概念，实际上是在创建容器进程时，指定了这个进程所需要启用的一组 Namespace 参数。</code>这样，容器就只能“看”到当前 Namespace 所限定的资源、文件、设备、状态，或者配置。而对于宿主机以及其他不相关的程序，它就完全看不到了。</p>
<p>所以说，<code>容器，其实是一种特殊的进程而已。</code></p>
<p><strong>总结</strong><br>谈到为“进程划分一个独立空间”的思想，相信你一定会联想到虚拟机。而且，你应该还看过一张虚拟机和容器的对比图。<br>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="1.jpg"  alt="">
      </p>
<p>这幅图的左边，画出了虚拟机的工作原理。其中，名为 Hypervisor 的软件是虚拟机最主要的部分。它通过硬件虚拟化功能，模拟出了运行一个操作系统需要的各种硬件，比如 CPU、内存、I/O 设备等等。然后，它在这些虚拟的硬件上安装了一个新的操作系统，即 Guest OS。</p>
<p>这样，用户的应用进程就可以运行在这个虚拟的机器中，它能看到的自然也只有 Guest OS 的文件和目录，以及这个机器里的虚拟设备。这就是为什么虚拟机也能起到将不同的应用进程相互隔离的作用。</p>
<p>而这幅图的右边，则用一个名为 Docker Engine 的软件替换了 Hypervisor。这也是为什么，很多人会把 Docker 项目称为“轻量级”虚拟化技术的原因，实际上就是把虚拟机的概念套在了容器上。</p>
<p>可是这样的说法，却并不严谨。</p>
<p>在理解了 Namespace 的工作方式之后，你就会明白，跟真实存在的虚拟机不同，在使用 Docker 的时候，并没有一个真正的“Docker 容器”运行在宿主机里面。Docker 项目帮助用户启动的，还是原来的应用进程，只不过在创建这些进程时，Docker 为它们加上了各种各样的 Namespace 参数。</p>
<p>这时，这些进程就会觉得自己是各自 PID Namespace 里的第 1 号进程，只能看到各自 Mount Namespace 里挂载的目录和文件，只能访问到各自 Network Namespace 里的网络设备，就仿佛运行在一个个“容器”里面，与世隔绝。</p>
<p>不过，相信你此刻已经会心一笑：这些不过都是“障眼法”罢了。</p>
<p><strong>思考题</strong><br>鉴于我对容器本质的讲解，你觉得上面这张容器和虚拟机对比图右侧关于容器的部分，怎么画才更精确？</p>
<p>你是否知道最新的 Docker 项目默认会为容器启用哪些 Namespace 吗？</p>
<p>感谢你的收听，欢迎你给我留言，也欢迎分享给更多的朋友一起阅读。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/03/13/micro_service/kubernetes/02_kubernetes_roles_introduction/">02 kubernetes introduction</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1k</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="kubernetes组件官网介绍"   >
          <a href="#kubernetes组件官网介绍" class="heading-link"><i class="fas fa-link"></i></a>kubernetes组件官网介绍</h2>
      <p><span class="exturl"><a class="exturl__link"   href="https://kubernetes.io/docs/reference/"  target="_blank" rel="noopener">https://kubernetes.io/docs/reference/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="REST"   >
          <a href="#REST" class="heading-link"><i class="fas fa-link"></i></a>REST</h3>
      <blockquote>
<p>REST（representational state transfer）是由roy博士在他的论文中提出的一个术语，rest本身只是为分布式超媒体系统设计的一种架构风格，而不是标准</p>
<ul>
<li>无状态性：<br>  这是在客户-服务器的基础上添加的又一层规范，它要求通信必须在本质上是无状态的，即从客户端到服务器的每个request都必须包含理解该request所必须的所有信息。这个规范改善了系统的可见性（无状态性使得客户端和服务端不必保存对方的详细信息，服务器只需要处理当前的request，而不必了解所有request的历史）、可靠性（无状态性减少了服务器从局部错误中恢复的任务量）、可伸缩性（无状态使得服务器端可以很容易地释放资源，因为服务端不必在多个request中保存状态）。同时，这种规范的缺点也是显而易见的，由于不能将状态数据保存在服务器上，因此增加了在一系列request中发生重复数据的开销，严重降低了效率。</li>
<li>缓存：<br>  为了改善无状态性带来的网络低效性，我们添加了缓存约束，缓存约束允许隐式或显式标记一个response中的数据，赋予了客户端缓存response数据的功能，这样就可以为以后的request公用缓存的数据，部分或全部地消除一部分交互，提高了网络效率。但是由于客户端缓存了信息，所以增加了客户端与服务器数据不一致的可能性，从而降低了可靠性。<br>REST中的资源所指的不是数据，而是数据和表现形式的组合，比如“最新访问的10位会员”和“最活跃的10位会员”在数据上可能有重叠或者完全相同，而由于它们的表现形式不同，所以被归于不同的资源，这也就是为什么REST的全名是representational state transfer，资源标识符就是URI（uniform resource identifier），不管是图片，word还是视频文件，也不管是什么格式，全部通过URI对资源进行唯一标识.<br>kubernetes API是集群系统中的重要组成部分，kubernetes中各种资源的数据通过该API接口被提交到后端的持久性存储etcd中，kubernetes集群中的各部分之间通过该API接口实现解耦合，同时kubernetes集群中一个重要且便捷的管理工具kubectl也是通过访问该API接口实现其强大的管理功能的。kubernetes API中的资源对象都拥有通用的元数据，资源对象也可能存在嵌套现象，比如在一个pod里面嵌套多个container。创建一个API对象是指通过API调用一条有意义的记录，该记录一旦被创建，kubernetes将确保对应的资源对象会被自动创建并托管维护</li>
</ul>
</blockquote>

        <h3 id="标签"   >
          <a href="#标签" class="heading-link"><i class="fas fa-link"></i></a>标签</h3>
      <blockquote>
<p>我们不会特别说明pod应该调度到哪个节点上， 因为这将会使应用程序与基础架构强耦合， 从而违背了Kubemetes对运行在其上的应用程序隐藏实际 的基础架构的整个构想。<br>但如果你想对一个 pod应该调度到哪里拥有发言权， 那就不应该直接指定一个确切的节点， 而应该用某种方式描述对节点的需求， 使Kubemetes选择一个符合这些需求的节点。这恰恰可以通过节点标签和节点标签选择器完成<br>pod并不是唯一可以附加标签的Kubemetes资源。 标签可以附加到任何Kubemetes对象上， 包括节点。 通常来说， 当运维团队向集群添加新节点时，他们将通过附加标签来对节点进行分类， 这些 标签指定节点提供 的硬件类型 ， 或者任何在调度pod 时能提供便利的其他信息</p>
</blockquote>

        <h2 id="roles"   >
          <a href="#roles" class="heading-link"><i class="fas fa-link"></i></a>roles</h2>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/03/13/micro_service/istio/istio_K8s_SpringCloud/">Istio_K8s_SpringCloud</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">123</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>SpringCloud、Istio比较</p>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   href="https://blog.csdn.net/qq_33873431/article/details/89524554"  target="_blank" rel="noopener">https://blog.csdn.net/qq_33873431/article/details/89524554</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>Spring Cloud Netflix vs. Kubernetes＆Istio</p>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   href="https://my.oschina.net/xiaominmin/blog/1859677"  target="_blank" rel="noopener">https://my.oschina.net/xiaominmin/blog/1859677</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br><span class="exturl"><a class="exturl__link"   href="https://my.oschina.net/xiaominmin?tab=newest&amp;catalogId=5894416"  target="_blank" rel="noopener">https://my.oschina.net/xiaominmin?tab=newest&amp;catalogId=5894416</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>史上最简单的spark系列教程</p>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   href="https://blog.csdn.net/youbitch1/article/details/89925790"  target="_blank" rel="noopener">https://blog.csdn.net/youbitch1/article/details/89925790</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>Spark教程视频:<br><span class="exturl"><a class="exturl__link"   href="https://www.bilibili.com/video/BV1JE411R7Xp?p=55"  target="_blank" rel="noopener">https://www.bilibili.com/video/BV1JE411R7Xp?p=55</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br><span class="exturl"><a class="exturl__link"   href="https://www.bilibili.com/video/BV11J41147iP?p=1"  target="_blank" rel="noopener">https://www.bilibili.com/video/BV11J41147iP?p=1</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br><span class="exturl"><a class="exturl__link"   href="https://www.bilibili.com/video/BV11J41147iP?p=1"  target="_blank" rel="noopener">https://www.bilibili.com/video/BV11J41147iP?p=1</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>Istio B站学习视频和对应的Gihub文档</p>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   href="https://www.bilibili.com/video/BV1vt411H755/?spm_id_from=333.788.videocard.0"  target="_blank" rel="noopener">https://www.bilibili.com/video/BV1vt411H755/?spm_id_from=333.788.videocard.0</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br><span class="exturl"><a class="exturl__link"   href="https://github.com/Kung-Fu-Master/Document"  target="_blank" rel="noopener">https://github.com/Kung-Fu-Master/Document</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>Istio中文社区:</p>
<blockquote>
<ul>
<li><span class="exturl"><a class="exturl__link"   href="https://istio.cn/"  target="_blank" rel="noopener">中文社区</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link"   href="https://istio.cn/t/topic/270"  target="_blank" rel="noopener">Istio 1.5发布</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ul>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/03/13/micro_service/istio/istio_cert_manager/">istio cert-manager</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">43</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="cert-manager"   >
          <a href="#cert-manager" class="heading-link"><i class="fas fa-link"></i></a>cert-manager</h2>
      <p>Official website:<br><span class="exturl"><a class="exturl__link"   href="https://istio.io/latest/zh/docs/ops/integrations/certmanager/"  target="_blank" rel="noopener">https://istio.io/latest/zh/docs/ops/integrations/certmanager/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   href="https://cert-manager.io/"  target="_blank" rel="noopener">cert-manager</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 是一种自动执行证书管理的工具，它可以与 Istio Gateway 集成以管理 TLS 证书。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/03/13/micro_service/istio/istio_problems/">Istio problems</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">111</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="istio-bookinfo部署不成功"   >
          <a href="#istio-bookinfo部署不成功" class="heading-link"><i class="fas fa-link"></i></a>istio bookinfo部署不成功</h2>
      <p>部署istio官网bookinfo出现以下错误</p>
<pre><code>$ kubectl describe replicaset.apps/details-v1-769468b8c -n book-info
  Warning  FailedCreate  3s (x13 over 24s)  replicaset-controller  Error creating: Internal error occurred: failed calling webhook &quot;sidecar-injector.istio.io&quot;: Post &quot;https://istiod.istio-system.svc:443/inject?timeout=30s&quot;: x509: certificate signed by unknown authority</code></pre><p>官网推荐解决方法: <span class="exturl"><a class="exturl__link"   href="https://istio.io/latest/docs/ops/common-problems/injection/#automatic-sidecar-injection-fails-if-the-kubernetes-api-server-has-proxy-settings"  target="_blank" rel="noopener">https://istio.io/latest/docs/ops/common-problems/injection/#automatic-sidecar-injection-fails-if-the-kubernetes-api-server-has-proxy-settings</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>注释掉  /etc/kubernetes/manifests/kube-apiserver.yaml 文件里的proxy</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/03/13/micro_service/istio/istio_%E6%9F%A5%E7%9C%8B%E5%92%8C%E5%BB%B6%E9%95%BF%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6/">istio 查看和延长自签名证书</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">13</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>Official website:<br><span class="exturl"><a class="exturl__link"   href="https://istio.io/latest/zh/docs/ops/configuration/security/root-transition/"  target="_blank" rel="noopener">https://istio.io/latest/zh/docs/ops/configuration/security/root-transition/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/03/13/micro_service/istio/istio_%E9%99%90%E5%88%B6%E8%AE%BF%E9%97%AE%E7%AD%96%E7%95%A5/">istio 限制访问策略</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">26</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>Official website:<br><span class="exturl"><a class="exturl__link"   href="https://istio.io/latest/docs/concepts/security/#authorization-policies"  target="_blank" rel="noopener">https://istio.io/latest/docs/concepts/security/#authorization-policies</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>(已经弃用)<span class="exturl"><a class="exturl__link"   href="https://istio.io/latest/docs/tasks/policy-enforcement/denial-and-list/"  target="_blank" rel="noopener">https://istio.io/latest/docs/tasks/policy-enforcement/denial-and-list/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/03/13/linux/%E6%9F%A5%E7%9C%8BSSD/">查看SSD</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">348</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>[root@wlp10 ~]# lsscsi -ls<br>[6:0:0:0]    disk    ATA      INTEL SSDSC2BB48 0370  /dev/sda    480GB<br>  state=running queue_depth=32 scsi_level=6 type=0 device_blocked=0 timeout=30<br>[7:0:0:0]    disk    ATA      INTEL SSDSC2BB48 0101  /dev/sdb    480GB<br>  state=running queue_depth=32 scsi_level=6 type=0 device_blocked=0 timeout=30<br>[8:0:0:0]    disk    ATA      INTEL SSDSC2BB48 0370  /dev/sdc    480GB<br>  state=running queue_depth=32 scsi_level=6 type=0 device_blocked=0 timeout=30<br>[9:0:0:0]    disk    ATA      INTEL SSDSC2BG01 0015  /dev/sdd   1.20TB<br>  state=running queue_depth=32 scsi_level=6 type=0 device_blocked=0 timeout=30<br>[root@wlp10 ~]#<br>看第四列就知道是否是SSD硬盘了</p>
<p>[root@wlp10 ~]# lsscsi -h<br>Usage: lsscsi   [–classic] [–device] [–generic] [–help] [–hosts]<br>                [–kname] [–list] [–lunhex] [–long] [–protection]<br>                [–scsi_id] [–size] [–sysfsroot=PATH] [–transport]<br>                [–verbose] [–version] [–wwn] [&lt;h:c:t:l&gt;]<br>  where:<br>    –classic|-c      alternate output similar to ‘cat /proc/scsi/scsi’<br>    –device|-d       show device node’s major + minor numbers<br>    –generic|-g      show scsi generic device name<br>    –help|-h         this usage information<br>    –hosts|-H        lists scsi hosts rather than scsi devices<br>    –kname|-k        show kernel name instead of device node name<br>    –list|-L         additional information output one<br>                      attribute=value per line<br>    –long|-l         additional information output<br>    –lunhex|-x       show LUN part of tuple as hex number in T10 format;<br>                      use twice to get full 16 digit hexadecimal LUN<br>    –protection|-p   show target and initiator protection information<br>    –protmode|-P     show negotiated protection information mode<br>    –scsi_id|-i      show udev derived /dev/disk/by-id/scsi* entry<br>    –size|-s         show disk size<br>    –sysfsroot=PATH|-y PATH    set sysfs mount point to PATH (def: /sys)<br>    –transport|-t    transport information for target or, if ‘–hosts’<br>                      given, for initiator<br>    –verbose|-v      output path names where data is found<br>    –version|-V      output version string and exit<br>    –wwn|-w          output WWN for disks (from /dev/disk/by-id/wwn<em>)<br>    &lt;h:c:t:l&gt;         filter output list (def: ‘</em>:<em>:</em>:*’ (all))</p>
<p>List SCSI devices or hosts, optionally with additional information<br>[root@wlp10 ~]#</p>
<p>From <span class="exturl"><a class="exturl__link"   href="https://www.cnblogs.com/laozhuang/p/7110438.html"  target="_blank" rel="noopener">https://www.cnblogs.com/laozhuang/p/7110438.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/03/13/linux/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98-%E4%BD%BF%E7%94%A8dev_mem&amp;mmap/">用户态和内核共享内存----使用 /dev/mem &amp; mmap</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">938</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>想法的来源是看到chinaunix上有人转载了wheelz的博客，但是wheelz的代码在我的实验平台上是不能正常工作的，可能是wheelz的代码太过久远，我试验的内核版本是：3.4.13。wheelz的源代码如下：<br>// 内核模块<br>#include &lt;linux/config.h&gt;<br>#include &lt;linux/module.h&gt;<br>#include &lt;linux/kernel.h&gt;<br>#include &lt;linux/mm.h&gt;<br>MODULE_LICENSE(“GPL”);<br>MODULE_AUTHOR(“Wheelz”);<br>MODULE_DESCRIPTION(“mmap demo”);<br>static unsigned long p = 0;<br>static int __init init(void)<br>{<br>        //分配共享内存（一个页面）<br>        p = __get_free_pages(GFP_KERNEL, 0);<br>        SetPageReserved(virt_to_page(p));<br>        printk(“&lt;1&gt; p = 0x%08x\n”, p);<br>    //p是内核中的虚拟地址<br>        //在共享内存中写上一个字符串<br>        strcpy(p, “Hello world!\n”);<br>        return 0;<br>}<br>static void __exit fini(void)<br>{<br>        ClearPageReserved(virt_to_page(p));<br>        free_pages(p, 0);<br>}<br>module_init(init);<br>module_exit(fini);</p>
<hr>
<p>// 用户态程序<br>#include &lt;sys/mman.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;stdio.h&gt;<br>#define PAGE_SIZE (4*1024)<br>#define PAGE_OFFSET                0xc0000000<br>#define KERNEL_VIRT_ADDR        0xc5e3c000<br>int main()<br>{<br>        char *buf;<br>        int fd;<br>        unsigned long phy_addr;<br>fd=open(“/dev/mem”,O_RDWR);<br>if(fd == -1)<br>                perror(“open”);<br>        phy_addr=KERNEL_VIRT_ADDR - PAGE_OFFSET;<br>        //此处不太懂，不能理解物理地址phy_addr的计算方法<br>        buf=mmap(0, PAGE_SIZE,<br>                PROT_READ|PROT_WRITE, MAP_SHARED,<br>                fd, phy_addr);<br>        if(buf == MAP_FAILED)<br>                perror(“mmap”);<br>puts(buf);//打印共享内存的内容<br>        munmap(buf,PAGE_SIZE);<br>        close(fd);<br>        return 0;<br>}<br>在网上找了一些资料，导致这段代码不工作的原因可能有一下几个：<br>（1）在编译内核时设置了CONFIG_STRICT_DEVMEM（某些版本中是CONFIG_NONPROMISC_DEVMEM），应该将此设置删除。<br>（2）请求的地址没有通过内核中devmem_is_allowed函数对/dev/mem的保护。<br>（3）物理地址phy_addr计算错误。（PS：wheelz的计算方法是怎么得到的？）</p>
<p>我对上面的几个问题一一做了修改：<br>（1）修改了.config文件</p>

        <h1 id="CONFIG-STRICT-DEVMEM-is-not-set"   >
          <a href="#CONFIG-STRICT-DEVMEM-is-not-set" class="heading-link"><i class="fas fa-link"></i></a>CONFIG_STRICT_DEVMEM is not set</h1>
      <p>（２）重写arch/x86/mm/init.c下的devmem_is_allowed函数，这里我没有做太细致的修改，只是让函数一直返回1。当然这可能会存在一些问题。</p>
<p>/*</p>
<ul>
<li>devmem_is_allowed() checks to see if /dev/mem access to a certain address</li>
<li>is valid. The argument is a physical page number.</li>
<li></li>
<li></li>
<li>On x86, access has to be given to the first megabyte of ram because that area</li>
<li>contains bios code and data regions used by X and dosemu and similar apps.</li>
<li>Access has to be given to non-kernel-ram areas as well, these contain the PCI</li>
<li>mmio resources as well as potential bios/acpi data regions.</li>
<li>/<br>int devmem_is_allowed(unsigned long pagenr)<br>{<br>return 1;<pre><code>if (pagenr &lt;= 256)
        return 1;
if (iomem_is_exclusive(pagenr &lt;&lt; PAGE_SHIFT))
        return 0;
if (!page_is_ram(pagenr))
        return 1;
return 0;</code></pre>}<br>（3）修改物理地址的计算，这里我们直接使用内核中提供的转换函数virt_to_phy()或者__pa()。</li>
</ul>
<p>// 内核模块<br>#include &lt;linux/module.h&gt;<br>#include &lt;linux/kernel.h&gt;<br>#include &lt;linux/mm.h&gt;<br>MODULE_LICENSE(“GPL”);<br>MODULE_AUTHOR(“godjesse”);<br>MODULE_DESCRIPTION(“mmap demo”);<br>static unsigned long p = 0;<br>static unsigned long pp = 0;<br>static int __init init(void)<br>{<br>        p = __get_free_pages(GFP_KERNEL, 0);<br>if(!p)<br>        {<br>                printk(“Allocate memory failure!/n”);<br>        }<br>        else<br>        {<br>                SetPageReserved(virt_to_page(p));<br>// 使用virt_to_phys计算物理地址，供用户态程序使用<br>                pp = (unsigned long)virt_to_phys((void *)p);<br>                printk(“&lt;1&gt; page : pp = 0x%lx\n”,pp);<br>        }<br>        strcpy((char *)p, “Hello world !\n”);<br>        return 0;<br>}<br>static void __exit fini(void)<br>{<br>printk(“The content written by user is: %s/n”, (unsigned char *)p);<br>        ClearPageReserved(virt_to_page(p));<br>        free_pages(p, 0);<br>        printk(“ exit \n”);<br>}<br>module_init(init);<br>module_exit(fini);</p>
<hr>
<p>// 用户态程序<br>#include &lt;sys/mman.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br>//hard coding read after the module installed<br>#define KERNEL_PHY_ADDR  0x3737c000<br>int main()<br>{<br>char *buf;<br>        int fd;<br>        unsigned long phy_addr;<br>        int  pagesize = getpagesize();<br>phy_addr=KERNEL_PHY_ADDR;<br>fd=open(“/dev/mem”,O_RDWR);<br>if(fd == -1)<br>                perror(“open”);<br>buf=mmap(0, pagesize, PROT_READ|PROT_WRITE, MAP_SHARED, fd, phy_addr);<br>if(buf == MAP_FAILED)<br>        {<br>                perror(“mmap”);<br>        }<br>printf(“buf : %s\n”,buf);<br>// test the write<br>        buf[0] = ‘X’;<br>munmap(buf,pagesize);<br>        close(fd);<br>        return 0;<br>}</p>
<p> 经过这些修改后，demo可以正常工作。<br>上文中提到修改devmem_is_allowed实际上是存在问题的，存在其他一些较为优雅的方法，如某牛人写的博客：bypassing devmem_is_allowed with kernel probes，博客链接：<br><span class="exturl"><a class="exturl__link"   href="http://www.libcrack.so/2012/09/02/bypassing-devmem_is_allowed-with-kprobes/"  target="_blank" rel="noopener">http://www.libcrack.so/2012/09/02/bypassing-devmem_is_allowed-with-kprobes/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>相关资料：<br><span class="exturl"><a class="exturl__link"   href="http://stackoverflow.com/questions/11891979/accessing-mmaped-dev-mem"  target="_blank" rel="noopener">http://stackoverflow.com/questions/11891979/accessing-mmaped-dev-mem</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>
<p>From <span class="exturl"><a class="exturl__link"   href="https://www.cnblogs.com/godjesse/archive/2012/11/23/2784093.html"  target="_blank" rel="noopener">https://www.cnblogs.com/godjesse/archive/2012/11/23/2784093.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/03/13/linux/%E7%A1%AC%E7%9B%98%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E5%8D%95%E4%BD%8DGB/">硬盘存储空间单位GB</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">101</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>信息技术的存储设备常用B、KB、MB、GB等作为存储设备的单位,例如,我们常说的某计算机的硬盘容量是320GB,某移动硬盘的容量是80GB,某个文件夹的大小是156KB等,其中1GB=210MB,1MB=210KB,1KB=210B(字节),对于一个容量为8GB的内存盘,其容量为____B(字节).<br>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="unit_GB.gif"  alt="">
      </p>
<p>From <span class="exturl"><a class="exturl__link"   href="http://www.manfen5.com/stinfo/CZ_SX/SYS201808030701323019115696/"  target="_blank" rel="noopener">http://www.manfen5.com/stinfo/CZ_SX/SYS201808030701323019115696/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/25/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><span class="page-number current">26</span><a class="page-number" href="/page/27/">27</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="extend next" rel="next" href="/page/27/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/stun-logo.svg" alt="avatar"></div><p class="sidebar-ov-author__text">Kung-Fu-Master</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://plus.google.com/" target="_blank" rel="noopener" data-popover="Google" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-google"></i></span></a><a class="sidebar-ov-social-item" href="https://twitter.com/" target="_blank" rel="noopener" data-popover="Twitter" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-twitter"></i></span></a><a class="sidebar-ov-social-item" href="https://youtube.com/" target="_blank" rel="noopener" data-popover="Youtube" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-youtube"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">291</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">40</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">12</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Kung-Fu-Master</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v4.2.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.1</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="/js/utils.js?v=2.6.1"></script><script src="/js/stun-boot.js?v=2.6.1"></script><script src="/js/scroll.js?v=2.6.1"></script><script src="/js/header.js?v=2.6.1"></script><script src="/js/sidebar.js?v=2.6.1"></script><script type="application/json" src="/search.json"></script></body></html>