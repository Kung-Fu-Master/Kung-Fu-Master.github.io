---
title: 08 模板
tags:
categories:
- language
- cpp
---

## 函数模板

在C++中，数据的类型也可以通过参数来传递，在函数定义时可以不指明具体的数据类型，当发生函数调用时，编译器可以根据传入的实参自动推断数据类型。这就是类型的参数化.  

值（Value）和类型（Type）是数据的两个主要特征，它们在C++中都可以被参数化.  

所谓函数模板，实际上是建立一个通用函数，它所用到的数据的类型（包括返回值类型、形参类型、局部变量类型）可以不具体指定，而是用一个虚拟的类型来代替（实际上是用一个标识符来占位），等发生函数调用时再根据传入的实参来逆推出真正的类型。这个通用函数就称为**`函数模板（Function Template）.`**

`一但定义了函数模板，就可以将类型参数用于函数定义和函数声明了。说得直白一点，原来使用 int、float、char 等内置类型的地方，都可以用类型参数来代替.`

**typename关键字也可以使用class关键字替代，它们没有任何区别**。C++ 早期对模板的支持并不严谨，没有引入新的关键字，而是用 class 来指明类型参数.  

	#include <iostream>
	using namespace std;
	
	template <typename T>
	void Swap(T *a, T *b)
	{
	    T temp = *a;
	    *a = *b;
	    *b = temp;
	}
	
	template <typename T>
	void Swap1(T &a, T &b)
	{
	    T temp = a;
	    a = b;
	    b = temp;
	}
	
	template <typename T> //模板头，这里不能有分号
	T max(T a, T b, T c)
	{ //函数头
	    T max_num = a;
	    if (b > max_num)
	        max_num = b;
	    if (c > max_num)
	        max_num = c;
	    return max_num;
	}
	
	int main()
	{
	    //交换 int 变量的值
	    int n1 = 100, n2 = 200;
	    Swap(&n1, &n2);
	    cout << n1 << ", " << n2 << endl;
	
	    //交换 float 变量的值
	    float f1 = 12.5, f2 = 56.93;
	    Swap(&f1, &f2);
	    cout << f1 << ", " << f2 << endl;
	
	    //交换 char 变量的值
	    char c1 = 'A', c2 = 'B';
	    Swap1(c1, c2);
	    cout << c1 << ", " << c2 << endl;
	
	    //交换 bool 变量的值
	    bool b1 = true, b2 = false;
	    Swap1(b1, b2);
	    cout << b1 << ", " << b2 << endl;
	
	    //求三个浮点数的最大值
	    double d1 = 1.0, d2 = 2.0, d3 = 3.0;
	    double d_max = max(d1, d2, d3);
	    cout << "d_max=" << d_max << endl;
	
	    return 0;
	}
运行结果：

	200, 100
	56.93, 12.5
	B, A
	0, 1
	d_max=3

## 类模板

C++ 除了支持函数模板，还支持类模板（Class Template）。函数模板中定义的类型参数可以用在函数声明和函数定义中，类模板中定义的类型参数可以用在类声明和类实现中。类模板的目的同样是将数据的类型参数化。  

声明类模板的语法为：

	template<typename 类型参数1 , typename 类型参数2 , …> class 类名{
	    //TODO:
	};
一但声明了类模板，就可以将类型参数用于类的成员函数和成员变量了。换句话说，原来使用 int、float、char 等内置类型的地方，都可以用类型参数来代替。  

	#include <iostream>
	using namespace std;
	
	template <class T1, class T2> //这里不能有分号
	class Point
	{
	public:
	    Point(T1 x, T2 y) : m_x(x), m_y(y) {}
	
	public:
	    T1 getX() const; //获取x坐标
	    void setX(T1 x); //设置x坐标
	    T2 getY() const; //获取y坐标
	    void setY(T2 y); //设置y坐标
	private:
	    T1 m_x; //x坐标
	    T2 m_y; //y坐标
	};
	
	template <class T1, class T2>  //模板头
	T1 Point<T1, T2>::getX() const /*函数头*/
	{
	    return m_x;
	}
	
	template <class T1, class T2>
	void Point<T1, T2>::setX(T1 x)
	{
	    m_x = x;
	}
	
	template <class T1, class T2>
	T2 Point<T1, T2>::getY() const
	{
	    return m_y;
	}
	
	template <class T1, class T2>
	void Point<T1, T2>::setY(T2 y)
	{
	    m_y = y;
	}
	
	int main()
	{
	    Point<int, int> p1(10, 20);
	    cout << "x=" << p1.getX() << ", y=" << p1.getY() << endl;
	
	    Point<int, char *> p2(10, "东经180度");
	    cout << "x=" << p2.getX() << ", y=" << p2.getY() << endl;
	
	    Point<char *, char *> *p3 = new Point<char *, char *>("东经180度", "北纬210度");
	    cout << "x=" << p3->getX() << ", y=" << p3->getY() << endl;
	
	    return 0;
	}
运行结果:

	x=10, y=20
	x=10, y=东经180度
	x=东经180度, y=北纬210度













