<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.1" type="image/png" sizes="32x32"><meta name="description" content="Kubernetes Service        Kubemetes 服务是一种为一组功能相同的 pod 提供单一不变的接入点的资源.当服务存在时，它的 IP 地址和端口不会改变。 客户端通过 IP 地址和端口号建立连接，这些连接会被路由到提供该服务的任意一个 pod上.通过这种方式， 客户端不需要知道每个单独的提供服务的 pod 的地址， 这样这些 po">
<meta property="og:type" content="article">
<meta property="og:title" content="04 Kubernetes service">
<meta property="og:url" content="https://kung-fu-master.github.io/2021/03/13/micro_service/kubernetes/04_kubernetes_service/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Kubernetes Service        Kubemetes 服务是一种为一组功能相同的 pod 提供单一不变的接入点的资源.当服务存在时，它的 IP 地址和端口不会改变。 客户端通过 IP 地址和端口号建立连接，这些连接会被路由到提供该服务的任意一个 pod上.通过这种方式， 客户端不需要知道每个单独的提供服务的 pod 的地址， 这样这些 po">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-13T05:00:42.872Z">
<meta property="article:modified_time" content="2021-03-13T05:00:42.872Z">
<meta property="article:author" content="Kung-Fu-Master">
<meta property="article:tag" content="kubernetes">
<meta name="twitter:card" content="summary"><title>04 Kubernetes service | Hexo</title><link ref="canonical" href="https://kung-fu-master.github.io/2021/03/13/micro_service/kubernetes/04_kubernetes_service/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: true,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return false;"><span class="header-nav-menu-item__icon"><i class="fas fa-feather-alt"></i></span><span class="header-nav-menu-item__text">文章</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/categories/"><span class="header-nav-submenu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-submenu-item__text">分类</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/archives/"><span class="header-nav-submenu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-submenu-item__text">归档</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/tags/"><span class="header-nav-submenu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-submenu-item__text">标签</span></a></div></div></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-fingerprint"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">04 Kubernetes service</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">6k</span></span></div></header><div class="post-body">
        <h2 id="Kubernetes-Service"   >
          <a href="#Kubernetes-Service" class="heading-link"><i class="fas fa-link"></i></a>Kubernetes Service</h2>
      <blockquote>
<p>Kubemetes 服务是一种为一组功能相同的 pod 提供单一不变的接入点的资源.<br>当服务存在时，它的 IP 地址和端口不会改变。 客户端通过 IP 地址和端口号建立连接，这些连接会被路由到提供该服务的任意一个 pod上.<br>通过这种方式， 客户端不需要知道每个单独的提供服务的 pod 的地址， 这样这些 pod 就可以在集群中随时被创建或移除.</p>
</blockquote>
<p>通过为前端 pod 创建服务， 并且将其配置成可以在集群外部访问，可以暴露一个单一不变的 IP 地址让外部的客户端连接 pod。<br>同理，可以为后台数据库 pod 创建服务，并为其分配一个固定的 IP 地址。尽管 pod 的 IP 地址会改变，但是服务的 IP 地址固定不变。<br>另外，通过创建服务，能够让前端的 pod 通过环境变量或 DNS 以及服务名来访问后端服务<br>Pod 控制器中使用标签选择器来指定哪些 pod 属于同一 Service。</p>

        <h2 id="service"   >
          <a href="#service" class="heading-link"><i class="fas fa-link"></i></a>service</h2>
      <blockquote>
<p>如果 pod 的标签与服务的 pod 选择器相匹配，那么 pod 就将作为服务的后端.只要创建了具有适当标签的新 pod ，它就成为服务的一部分，并且请求开始被重定向到 pod.<br>如下所示Service和POD都采用命名端口的方式, 最大的好处就是即使更换spec pod中的端口号也无须更改服务 spec.</p>
</blockquote>
<ul>
<li>第一步，创建service<br>创建service yaml文件 kubia-svc.yaml</li>
</ul>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia</span><br><span class="line">sepc:</span><br><span class="line">// sessionAffinity: ClientIP	// 默认此值是None, 若改为ClientIP，则SVC接受到的请求连接只会固定转发给同一个pod</span><br><span class="line">  ports:</span><br><span class="line">  - name: http			// 端口别名，可以当作端口号用</span><br><span class="line">    port: 80			// 该服务可用的端口</span><br><span class="line">    targetPort: http	// 服务将连接转发到的POD端口, pod需要将http映射pod本身的8080或其它端口，否则这里只能填写端口号</span><br><span class="line">  - name: https</span><br><span class="line">    port: 443</span><br><span class="line">    targetPort: https	// 含有label:app=kubia的pod需要将https映射pod本身8443或其它端口，否则这里只能填写端口号</span><br><span class="line">  selector:</span><br><span class="line">    app: kubia			// 具有app=kubia标签的pod都属于该服务</span><br></pre></td></tr></table></div></figure>

<p>创建了 一个名叫kubia的服务，它将在端口80接收请求并将连接路由到具有标签选择器是app=kubia的pod的8080端口上.<br>在发布完YAML文件后， 可以在命名空间下列出来所有的服务资源, 新的服务已经被分配了一个内部集群IP, 只能在集群内部可以被访问.</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get svc</span></span><br><span class="line">NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP   23h</span><br><span class="line">kubia        ClusterIP   10.98.229.76   &lt;none&gt;        80/TCP    20s</span><br></pre></td></tr></table></div></figure>

<ul>
<li>第二步，创建两个pod，一个添加标签app=kubia，另一个用来执行测试通过kubectl exec来访问第一个pod<br>kubia.yaml</li>
</ul>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia	// name: kubia1; name: kubia2</span><br><span class="line">spec:</span><br><span class="line">  nodeSelector:		// pod被分配到含有标签gpu=true的node上，当然也可以注释掉这两行</span><br><span class="line">    gpu: "true"</span><br><span class="line">  containers:</span><br><span class="line">  - image: luksa/kubia</span><br><span class="line">    name: kubia</span><br></pre></td></tr></table></div></figure>

<p>kubia-label.yaml</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1					// api服务版本</span><br><span class="line">kind : Pod						// 资源类型</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia-label			// pod 名字</span><br><span class="line">  labels:</span><br><span class="line">    app: kubia					// pod添加label</span><br><span class="line">spec :</span><br><span class="line">  nodeSelector:</span><br><span class="line">    gpu: "true"				// node 选择器</span><br><span class="line">  containers:</span><br><span class="line">  - image: luksa/kubia			// image 名字</span><br><span class="line">    name: kubia				// container 名字</span><br><span class="line">    ports:</span><br><span class="line">    - name: http				// pod端口映射，用http名字代替8080，名字随便取, 可以跟上面的service的targetPort对应起来</span><br><span class="line">      containerPort: 8080		// 用上面的名字定义这个端口号的别名</span><br><span class="line">    - name: https</span><br><span class="line">      containerPort: 8443</span><br></pre></td></tr></table></div></figure>

<p>查看POD并执行一个POD去通过上面创建的service(通过label)包含的pod提供的服务.<br>其中pod kubia-label中container运行的服务进程监听了8080端口, POD对外也暴露了8080端口</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pod --show-labels</span></span><br><span class="line">NAME           READY   STATUS    RESTARTS   AGE    LABELS</span><br><span class="line">kubia          1/1     Running   0          101m   &lt;none&gt;</span><br><span class="line">kubia-label    1/1     Running   0          98m    app=kubia</span><br><span class="line">kubia-label1   1/1     Running   0          99s    app=kubia</span><br><span class="line">kubia-label2   1/1     Running   0          79s    app=kubia</span><br></pre></td></tr></table></div></figure>

<ul>
<li>第三步: 执行一个pod用curl命令访问另一个pod提供的服务<br>双横杠(–)代表着kubectl命令项的结束.在两个横杠之后的内容是指在pod内部需要执行的命令.<br>k8s 服务代理接续curl请求连接，三个包含label为app=kubia的pod任意选择一个pod<br>访问服务三种方式,加不加端口都可以</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;$ kubectl exec kubia -- curl -s http://10.98.229.76:http&lt;/p&gt;</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kubia -- curl -s http://10.98.229.76:80</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kubia -- curl -s http://10.98.229.76</span></span><br><span class="line">You've hit kubia-label</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kubia -- curl -s http://10.98.229.76</span></span><br><span class="line">You've hit kubia-label2</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kubia -- curl -s http://10.98.229.76</span></span><br><span class="line">You've hit kubia-label1</span><br></pre></td></tr></table></div></figure>


        <h3 id="Affinity-亲和性"   >
          <a href="#Affinity-亲和性" class="heading-link"><i class="fas fa-link"></i></a>Affinity 亲和性</h3>
      <p>Kubernetes 仅仅支持两种形式的会话亲和性服务： None 和 ClientIP<br>这种方式将会使服务代理将来自同 一个 client IP 的所有请求转发至同 一个 pod上.<br>Kubernetes 服务不是在 HTTP 层面上工作。服务处理 TCP 和 UDP 包，并不关心其中的载荷内容。<br>因为 cookie 是 HTTP 协议中的一部分，服务并不知道它们，这就解释了为什么会话亲和性不能基千 cookie。<br>如果希望特定客户端产生的所有请求每次都指向同 一个 pod, 可以设置服务的 sessionAffinity 属性为 ClientIP (而不是 None,None 是默认值）</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: vl</span><br><span class="line">kind: Service</span><br><span class="line">spec:</span><br><span class="line">  sessionAffinity: ClientIP</span><br><span class="line">......</span><br></pre></td></tr></table></div></figure>


        <h2 id="环境变量发现service"   >
          <a href="#环境变量发现service" class="heading-link"><i class="fas fa-link"></i></a>环境变量发现service</h2>
      
        <h3 id="创建replicaSet-管理-3-个-POD"   >
          <a href="#创建replicaSet-管理-3-个-POD" class="heading-link"><i class="fas fa-link"></i></a>创建replicaSet 管理 3 个 POD</h3>
      <figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: ReplicaSet</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: kubia</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: kubia</span><br><span class="line">    spec:</span><br><span class="line">      nodeSelector:</span><br><span class="line">        gpu: "true"</span><br><span class="line">      containers:</span><br><span class="line">      - name: kubia</span><br><span class="line">        image: luksa/kubia</span><br><span class="line">        ports:</span><br><span class="line">        - name: http</span><br><span class="line">          containerPort: 8080</span><br><span class="line">        - name: https</span><br><span class="line">          containerPort: 8443</span><br></pre></td></tr></table></div></figure>

<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get svc </span></span><br><span class="line">NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP          29h</span><br><span class="line">kubia        ClusterIP   10.111.88.195   &lt;none&gt;        80/TCP,443/TCP   3h46m</span><br></pre></td></tr></table></div></figure>

<p>查看pod所在的service对应的IP和端口</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kubia-5rvfq env</span></span><br><span class="line">......</span><br><span class="line">KUBERNETES_SERVICE_PORT=443</span><br><span class="line">KUBIA_SERVICE_PORT=80				// 服务的集群IP</span><br><span class="line">......</span><br><span class="line">KUBERNETES_SERVICE_HOST=10.96.0.1</span><br><span class="line">KUBIA_SERVICE_HOST=10.111.88.195	// 服务所在的端口</span><br><span class="line">......</span><br></pre></td></tr></table></div></figure>
<p>pod 是否使用 内 部的 DNS 服务器是根据 pod 中 spec 的 dnsPolicy 属性来决定的</p>
<p>进入容器后执行如下命令</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kubia-5rvfq -it -- bash		// -- 表示kubectl 命令执行完了，开始执行pod容器里要运行的命令</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl http://kubia.default.svc.cluster.local</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl http://kubia.default</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl http://kubia</span></span><br><span class="line">You've hit kubia-5rvfq</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/resolv.conf</span></span><br><span class="line">nameserver 10.96.0.10		// 对应kube-system 里的服务kube-dns服务IP</span><br><span class="line">search default.svc.cluster.local svc.cluster.local cluster.local sh.intel.com</span><br><span class="line">options ndots:5</span><br><span class="line">root@kubia-5rvfq:/# curl http://svc.cluster.local</span><br><span class="line">curl: (6) Could not resolve host: svc.cluster.local</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ping kubia</span></span><br><span class="line">PING kubia.default.svc.cluster.local (10.111.88.195): 56 data bytes</span><br><span class="line">^C--- kubia.default.svc.cluster.local ping statistics ---</span><br><span class="line">4 packets transmitted, 0 packets received, 100% packet loss</span><br></pre></td></tr></table></div></figure>

<p>上面的 curl 这个服务是工作的，但是却 ping 不通。这是 因为服务的集群 IP 是一个虚拟 IP，并且只有在与服务端口结合时才有意义。 </p>
<p>查看kube-system下面kube-dns信息</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get svc -n kube-system</span></span><br><span class="line">NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)                  AGE</span><br><span class="line">kube-dns   ClusterIP   10.96.0.10   &lt;none&gt;        53/UDP,53/TCP,9153/TCP   2d3h</span><br></pre></td></tr></table></div></figure>


        <h3 id="删除service"   >
          <a href="#删除service" class="heading-link"><i class="fas fa-link"></i></a>删除service</h3>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl delete svc kubia</span></span><br></pre></td></tr></table></div></figure>


        <h2 id="Service-samples"   >
          <a href="#Service-samples" class="heading-link"><i class="fas fa-link"></i></a>Service samples</h2>
      
        <h3 id="查看service"   >
          <a href="#查看service" class="heading-link"><i class="fas fa-link"></i></a>查看service</h3>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get svc -n kube-system</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get svc -n istio-system</span></span><br><span class="line">NAME                        TYPE           CLUSTER-IP       EXTERNAL-IP   PORT(S)                                                                                                                                      AGE</span><br><span class="line">grafana                     ClusterIP      10.104.1.236     &lt;none&gt;        3000/TCP                                                                                                                                     3d5h</span><br><span class="line">istio-egressgateway         ClusterIP      10.107.177.52    &lt;none&gt;        80/TCP,443/TCP,15443/TCP                                                                                                                     3d5h</span><br><span class="line">istio-ingressgateway        LoadBalancer   10.97.82.221     &lt;pending&gt;     15020:31237/TCP,80:31556/TCP,443:30614/TCP,15029:32511/TCP,15030:32423/TCP,15031:30670/TCP,15032:30961/TCP,31400:30196/TCP,15443:31028/TCP   3d5h</span><br><span class="line">istio-pilot                 ClusterIP      10.97.192.70     &lt;none&gt;        15010/TCP,15011/TCP,15012/TCP,8080/TCP,15014/TCP,443/TCP                                                                                     3d5h</span><br><span class="line">istiod                      ClusterIP      10.107.202.199   &lt;none&gt;        15012/TCP,443/TCP</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get services</span></span><br><span class="line">NAME                        TYPE           CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">kubernetes                  ClusterIP      10.3.240.l       &lt;none&gt;        443/TCP          34m</span><br><span class="line">kubia-http                  LoadBalancer   10.3.246.185     &lt;pending&gt;     8080:31348/TCP   4s</span><br><span class="line">暂时忽略 kubernetes 服务，仔细查看创建的kubian-http 服务 。 它还没有外部 IP 地址 ，因为 Kubernetes 运行的云基础设施创建负载均衡需要一段时间</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get services</span></span><br><span class="line">NAME                        TYPE           CLUSTER-IP       EXTERNAL-IP       PORT(S)          AGE</span><br><span class="line">kubernetes                  ClusterIP      10.3.240.l       &lt;none&gt;            443/TCP          34m</span><br><span class="line">kubia-http                  LoadBalancer   103.246.185      104 155.74.57     8080:31348/TCP   4s</span><br><span class="line">现在有外部 IP 了，应用就可以从任何地方通过 http://104.155.74.57:8080 访问</span><br><span class="line"><span class="meta">$</span><span class="bash"> curl 104.155.74.57:8080</span></span><br><span class="line">You’ve hit kubia-4jfyf</span><br></pre></td></tr></table></div></figure>


        <h3 id="查看service的CRD信息"   >
          <a href="#查看service的CRD信息" class="heading-link"><i class="fas fa-link"></i></a>查看service的CRD信息</h3>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get svc istio-ingressgateway -n istio-system -oyaml</span></span><br></pre></td></tr></table></div></figure>


        <h2 id="endpoint-服务"   >
          <a href="#endpoint-服务" class="heading-link"><i class="fas fa-link"></i></a>endpoint 服务</h2>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe svc kubia</span></span><br><span class="line">Name:              kubia</span><br><span class="line">Namespace:         default</span><br><span class="line">Labels:            &lt;none&gt;</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          app=kubia		// 用于创建endpoint列表的服务pod选择器</span><br><span class="line">Type:              ClusterIP</span><br><span class="line">IP:                10.111.88.195</span><br><span class="line">Port:              http  80/TCP</span><br><span class="line">TargetPort:        8080/TCP</span><br><span class="line">Endpoints:         10.44.0.1:8080,10.44.0.2:8080,10.44.0.3:8080		// 服务endpoint的pod的IP和端口列表</span><br><span class="line">Port:              https  443/TCP</span><br><span class="line">TargetPort:        8443/TCP</span><br><span class="line">Endpoints:         10.44.0.1:8443,10.44.0.2:8443,10.44.0.3:8443</span><br><span class="line">Session Affinity:  ClientIP</span><br><span class="line">Events:            &lt;none&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get po -o wide</span></span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE   IP          NODE       NOMINATED NODE   READINESS GATES</span><br><span class="line">kubia         1/1     Running   0          15h   10.44.0.4   server02   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kubia-5rvfq   1/1     Running   0          15h   10.44.0.2   server02   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kubia-8cgnm   1/1     Running   0          15h   10.44.0.1   server02   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kubia-8kv8d   1/1     Running   0          15h   10.44.0.3   server02   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></div></figure>
<p>Endpoint 资源和其他Kubernetes 资源一样，所以可以使用 kubectl info 来获取它的基本信息</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get endpoints kubia</span></span><br><span class="line">NAME    ENDPOINTS                                                  AGE</span><br><span class="line">kubia   10.44.0.1:8443,10.44.0.2:8443,10.44.0.3:8443 + 3 more...   16h</span><br></pre></td></tr></table></div></figure>

<p>Endpoint是一个单独的资源并不 是服务的一个属性, 必须手动创建<br>external-service.yaml</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: external-service</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br></pre></td></tr></table></div></figure>

<p>external-service-endpoints.yaml</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Endpoints</span><br><span class="line">metadata:</span><br><span class="line">  name: external-service</span><br><span class="line">subsets:</span><br><span class="line">  - addresses:</span><br><span class="line">    - ip: 11.11.11.11</span><br><span class="line">    - ip: 22.22.22.22</span><br><span class="line">    ports:</span><br><span class="line">    - port: 80</span><br></pre></td></tr></table></div></figure>
<p>部署service和endpoint</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create -f external-service.yaml</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl create -f external-service-endpoints.yaml</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe svc/external-service</span></span><br><span class="line">Name:              external-service</span><br><span class="line">Namespace:         default</span><br><span class="line">Labels:            &lt;none&gt;</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          &lt;none&gt;</span><br><span class="line">Type:              ClusterIP</span><br><span class="line">IP:                10.97.153.150</span><br><span class="line">Port:              &lt;unset&gt;  80/TCP</span><br><span class="line">TargetPort:        80/TCP</span><br><span class="line">Endpoints:         11.11.11.11:80,22.22.22.22:80</span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br></pre></td></tr></table></div></figure>


        <h2 id="暴露service"   >
          <a href="#暴露service" class="heading-link"><i class="fas fa-link"></i></a>暴露service</h2>
      <p> • 将服务的类型设置成NodePort – 每个集群节点都会在节点上打开一个端口， 对于NodePort服务， 每个集群节点在节点本身（因此得名叫NodePort)上打开一个端口，并将在该端口上接收到的流量重定向到基础服务。<br>   该服务仅在内部集群 IP 和端口上才可访间， 但也可通过所有节点上的专用端口访问.<br> • 将服务的类型设置成LoadBalance, NodePort类型的一种扩展 – 这使得服务可以通过一个专用的负载均衡器来访问， 这是由Kubernetes中正在运行的云基础设施提供的。 负载均衡器将流量重定向到跨所有节点的节点端口。<br>   客户端通过负载均衡器的 IP 连接到服务<br> • 创建一 个Ingress资源， 这是一 个完全不同的机制， 通过一 个IP地址公开多个服务——它运行在 HTTP 层（网络协议第 7 层）上， 因此可以提供比工作在第4层的服务更多的功能</p>

        <h3 id="NodePort-类型-service"   >
          <a href="#NodePort-类型-service" class="heading-link"><i class="fas fa-link"></i></a>NodePort 类型 service</h3>
      <p>指定端口不是强制性的。 如果忽略它，Kubemetes将选择一个随机端口.<br>客户端发送请求的节点并不重要, 整个互联网可以通过任何节点上的30123(用户自己定义的)端口访问到pod,如下所示<br>如在个人机器上生成如下service和pod，可以在以前做的项目的任何机器上通过如下访问</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -s http://10.239.140.186:30123 (master节点的NodeIP:port)访问服务</span><br><span class="line">curl -s http://10.239.140.200:30123 (worker02节点的NodeIP:port)访问服务</span><br></pre></td></tr></table></div></figure>

<p>kubia-svc-nodeport.yaml</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia-nodeport</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort			// 设置服务类型</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80				// 服务集群IP端口号</span><br><span class="line">    targetPort: 8080</span><br><span class="line">    nodePort: 30123			// 通过集群节点(master或worker)的NodeIP，加上30123端口可以访问服务</span><br><span class="line">  selector:</span><br><span class="line">    app: kubia</span><br></pre></td></tr></table></div></figure>

<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create -f kubia-svc-nodeport.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get svc</span></span><br><span class="line">NAME                 TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">kubernetes           ClusterIP      10.96.0.1       &lt;none&gt;        443/TCP          43h</span><br><span class="line">kubia-nodeport       NodePort       10.103.7.50     &lt;none&gt;        80:30123/TCP     99m</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe svc kubia-nodeport</span></span><br><span class="line">Name:                     kubia-nodeport</span><br><span class="line">Namespace:                default</span><br><span class="line">Labels:                   &lt;none&gt;</span><br><span class="line">Annotations:              &lt;none&gt;</span><br><span class="line">Selector:                 app=kubia</span><br><span class="line">Type:                     NodePort</span><br><span class="line">IP:                       10.103.7.50</span><br><span class="line">Port:                     &lt;unset&gt;  80/TCP</span><br><span class="line">TargetPort:               8080/TCP</span><br><span class="line">NodePort:                 &lt;unset&gt;  30123/TCP</span><br><span class="line">Endpoints:                10.44.0.1:8080,10.44.0.2:8080,10.44.0.3:8080</span><br><span class="line">Session Affinity:         None</span><br><span class="line">External Traffic Policy:  Cluster</span><br><span class="line">Events:                   &lt;none&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get po -o wide</span></span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE   IP          NODE       NOMINATED NODE   READINESS GATES</span><br><span class="line">kubia         1/1     Running   0          17h   10.44.0.4   server02   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kubia-5rvfq   1/1     Running   0          17h   10.44.0.2   server02   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kubia-8cgnm   1/1     Running   0          17h   10.44.0.1   server02   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kubia-8kv8d   1/1     Running   0          17h   10.44.0.3   server02   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></div></figure>
<p>查看server02机器IP</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">kubectl get node -o wide</span></span><br><span class="line">NAME       STATUS   ROLES    AGE     VERSION   INTERNAL-IP      EXTERNAL-IP   OS-IMAGE             KERNEL-VERSION      CONTAINER-RUNTIME</span><br><span class="line">alpha      Ready    master   2d18h   v1.18.2   10.239.140.186   &lt;none&gt;        Ubuntu 18.04.4 LTS   5.3.0-28-generic    docker://19.3.6</span><br><span class="line">server02   Ready    &lt;none&gt;   2d17h   v1.18.2   10.239.140.200   &lt;none&gt;        Ubuntu 18.04.4 LTS   4.15.0-76-generic   docker://19.3.6</span><br></pre></td></tr></table></div></figure>
<p>两种访问方式</p>
<ul>
<li>第一种: 通过NodeIP:Port 访问:</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -s http://10.239.140.200:30123</span></span><br><span class="line">You've hit kubia-8kv8d</span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -s http://10.239.140.186:30123</span></span><br><span class="line">You've hit kubia-5rvfq</span><br></pre></td></tr></table></div></figure>
<ul>
<li>第二种: 通过 service的CLUSTER-IP：port 进入port进行访问</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kubia -- curl -s http://10.103.7.50:80</span></span><br><span class="line">You've hit kubia-8kv8d</span><br></pre></td></tr></table></div></figure>


        <h3 id="LoadBalancer-方式访问"   >
          <a href="#LoadBalancer-方式访问" class="heading-link"><i class="fas fa-link"></i></a>LoadBalancer 方式访问</h3>
      <blockquote>
<p>如果Kubemetes在不支持Load Badancer服务的环境中运行， 则不会调配负载平衡器， 但该服务仍将表现得像 一 个NodePort服 务。 这是因为LoadBadancer服务是NodePo江服务的扩展<br>如果没有指定特定的节点端口， Kubernetes将会选择一个端口<br>创建服务后， 云基础架构需要一段时间才能创建负载均衡器并将其 IP 地址写入服务对象。 一旦这样做了， IP 地址将被列为服务的外部 IP 地址</p>
</blockquote>
<p>kubia-svc-loadbalancer.yaml</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia-loadbalancer</span><br><span class="line">spec:</span><br><span class="line">  type: LoadBalancer</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    targetPort: 8080</span><br><span class="line">  selector:</span><br><span class="line">    app: kubia</span><br></pre></td></tr></table></div></figure>

<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create -f kubia-svc-loadbalancer.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe svc/kubia-loadbalancer</span></span><br><span class="line">Name:                     kubia-loadbalancer</span><br><span class="line">Namespace:                default</span><br><span class="line">Labels:                   &lt;none&gt;</span><br><span class="line">Annotations:              &lt;none&gt;</span><br><span class="line">Selector:                 app=kubia</span><br><span class="line">Type:                     LoadBalancer</span><br><span class="line">IP:                       10.99.184.62</span><br><span class="line">Port:                     &lt;unset&gt;  80/TCP</span><br><span class="line">TargetPort:               8080/TCP</span><br><span class="line">NodePort:                 &lt;unset&gt;  30994/TCP		// yaml资源文件里没有指定, Kubemetes将会选择一个端口</span><br><span class="line">Endpoints:                10.44.0.1:8080,10.44.0.2:8080,10.44.0.3:8080</span><br><span class="line">Session Affinity:         None</span><br><span class="line">External Traffic Policy:  Cluster</span><br><span class="line">Events:                   &lt;none&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get svc</span></span><br><span class="line">NAME                 TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">kubernetes           ClusterIP      10.96.0.1       &lt;none&gt;        443/TCP          43h</span><br><span class="line">kubia-loadbalancer   LoadBalancer   10.99.184.62    &lt;pending&gt;     80:30994/TCP     4m11s</span><br></pre></td></tr></table></div></figure>

<p>可以看到Kubemetes在不支持Load Badancer服务的环境中运行 EXTERNAL-IP显示为 <pending>状态，但仍然可以像NodePort方式一样访问服务</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kubia -- curl -s http://10.99.184.62:80</span></span><br><span class="line">You've hit kubia-8cgnm</span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -s 10.239.140.186:30994		// masterIP：svcPort</span></span><br><span class="line">You've hit kubia-5rvfq</span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -s 10.239.140.200:30994		// worker01：svcPort</span></span><br><span class="line">You've hit kubia-8kv8d</span><br></pre></td></tr></table></div></figure>
<p>如果支持LoadBalancer且获得EXTERNAL-IP为 130.211.53.173<br>可以通过 $ curl <span class="exturl"><a class="exturl__link"   href="http://130.211.53.173"  target="_blank" rel="noopener">http://130.211.53.173</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 进行访问</p>

        <h3 id="Ingress-暴露服务"   >
          <a href="#Ingress-暴露服务" class="heading-link"><i class="fas fa-link"></i></a>Ingress 暴露服务</h3>
      <blockquote>
<p>需要 Ingress一个重要的原因是每个 LoadBalancer 服务都需要自己的负载均衡器， 以及独有的公有 IP 地址， 而 Ingress 只需要一个公网 IP 就能为许多服务提供访问<br>Ingress 在网络栈 (HTTP) 的应用层操作， 并且可以提供一 些服务不能实现的功能， 诸如基于 cookie 的会话亲和性 (session affinity) 等功能<br>Ingress 对象提供的功能之前，必须强调只有 Ingress控制器在集群中运行，Ingress 资源才能正常工作。 不同的 Kubernetes 环境使用不同的控制器实现， 但有些并不提供默认控制器<br>Ingress通常向外暴露 Service.Type=NodePort 或者 Service.Type=LoadBalancer 类型的服务，因此先创建一个NodePort类型svc.</p>
</blockquote>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get svc</span></span><br><span class="line">NAME                  TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">kubia-nodeport        NodePort       10.103.7.50     &lt;none&gt;        80:30123/TCP     144m</span><br></pre></td></tr></table></div></figure>
<p>创建kubia-ingress.yaml资源文件</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: kubia.example.com				// Ingress 将域名kubia.example.com映射到您的服务</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /</span><br><span class="line">        backend:</span><br><span class="line">          serviceName: kubia-nodeport	// 将所有请求发送到kubia-nodeport服务的80端口</span><br><span class="line">          servicePort: 80</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>kubectl创建ingress.yaml资源文件遇到webhook …错误时修改master节点上/etc/kubernetes/manifests/kube-apiserver.yaml，将K8s默认用系统配置的proxy注释掉，稍后再运行kubectl create …就可以了</p>
</blockquote>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create -f kubia-ingress.yaml</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get ingress		// 自己机器上没有获得ADDRESS这列IP</span></span><br><span class="line">NAME    CLASS    HOSTS               ADDRESS            PORTS   AGE</span><br><span class="line">kubia   &lt;none&gt;   kubia.example.com   192.168.99.100     80      92s</span><br></pre></td></tr></table></div></figure>
<blockquote>
<p>一旦知道 IP 地址，通过配置 DNS 服务器将 kubia.example.com 解析为此 IP地址，或者在/ect/hosts(Windows系统为C:\windows\system32\drivers\etc\hosts ）文件中添加下面一行内容：</p>
</blockquote>
<figure class="highlight basic"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">192 </span><span class="number">168.99.100</span> kubia.example.<span class="keyword">com</span></span><br></pre></td></tr></table></div></figure>
<p>通过Ingress访问pod, 环境都己经建立完毕，可以通过 http ：此ubia.example.com 地址访 问服务 （使用浏览器或者 curl 命令）</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl http://kubia.example.com</span></span><br></pre></td></tr></table></div></figure>
<blockquote>
<p>客户端如何通过 Ingress 控制器连接到 其 中 一个 pod。客户端首先对 kubia.example.com 执行 DNS 查 找， DNS 服务器（或本地操作系统）返回了In gress 控制器的 IP。<br>客户端然后 向 Ingress 控制器发送 HTTP 请求，并在 Host 头中指定 kubia . example.com。<br>控制器从该头部确定客户端尝试访 问哪个服务，通过与该服务关联 的 Endpo int 对象查看 pod IP ， 并将客户端的请求转发给其中一个pod。<br>Ingress 控制器不会将请求转发给该服务，只用它来选择一个pod。大多数（即使不是全部）控制器都是这样工作的.</p>
</blockquote>
<p>Ingress规范的 rules 和 paths 都是数组，因此它们可以包含多个条目<br>一个 Ingress 可以将 多个主机和路径映射到多个服务</p>
<ul>
<li>客户端可以通过一个 IP 地址（ Ingress 控制器的 IP 地址 〉访问两种不同的服务</li>
<li>同样，可以使用 Ingress 根据 HTTP 请求中的主机而不是（仅）路径映射到不同的服务<br>kubia-ingress.yaml</li>
</ul>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: kubia.example.com				// 对 kubia.example.com 的请求将会转发至kubia服务</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /</span><br><span class="line">        backend:</span><br><span class="line">          serviceName: kubia-nodeport</span><br><span class="line">          servicePort: 80</span><br><span class="line">      - path: /kubia					// 对 kubia.example.com/kubia 的请求将会转发至kubia服务</span><br><span class="line">        backend:</span><br><span class="line">          serviceName: kubia</span><br><span class="line">          servicePort: 80</span><br><span class="line">      - path: /foo						// 对 kubia.example.com/foo 的请求将会转发至bar服务</span><br><span class="line">        backend:</span><br><span class="line">          serviceName: bar</span><br><span class="line">          servicePort: 80</span><br><span class="line">  - host: bar.example.com				// 对 bar.example.com 的请求将会转发至bar服务</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /</span><br><span class="line">        backend:</span><br><span class="line">          serviceName: bar</span><br><span class="line">          servicePort: 80</span><br></pre></td></tr></table></div></figure>

<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get ingress</span></span><br><span class="line">NAME    CLASS    HOSTS                               ADDRESS   PORTS   AGE</span><br><span class="line">kubia   &lt;none&gt;   kubia.example.com,bar.example.com             80      3s</span><br></pre></td></tr></table></div></figure>
<p>DNS 需要将 foo .example.com 和 bar.example.com 域名都指向 Ingress 控制器的 IP 地址.<br>然后像上面一样配置/ect/hosts文件内容,就可以通过域名访问了</p>

        <h3 id="Ingress处理TLS传输"   >
          <a href="#Ingress处理TLS传输" class="heading-link"><i class="fas fa-link"></i></a>Ingress处理TLS传输</h3>
      <p>配置 Ingress 以支持 TLS, Ingress 转发 HTTP 流量.</p>

        <h2 id="readiness-Probe-就绪探针"   >
          <a href="#readiness-Probe-就绪探针" class="heading-link"><i class="fas fa-link"></i></a>readiness Probe 就绪探针</h2>
      <blockquote>
<p>了解了存活探针，以及它们如何通过确保异常容器自动重启来保持应用程序的正常运行 。 与存活探针类似， Kubernetes 还允许为容器定义准备就绪探针<br>就绪探测器会定期调用，并确定特定的 pod 是否接收客户端请求 。 当容器的准备就绪探测返回成功时，表示容器己准备好接收请求<br>就绪探针有三种类型:</p>
</blockquote>
<ul>
<li>Exec 探针，执行进程的地方。容器的状态由进程的退出状态代码确定 。</li>
<li>HTTP GET 探针，向容器发送 HTTP GET 请求，通过响应的 HTTP 状态代码判断容器是否准备好 。</li>
<li>TCP socket 探针，它打开一个 TCP 连接到容器的指定端口。如果连接己建立，则认为容器己准备就绪 </li>
</ul>
<p>启动容器时，可以为 Kubernetes 配置一个等待时间，经过等待时间后才可以执行第一次准备就绪检查。<br>之后，它会周期性地调用探针，并根据就绪探针的结果采取行动。<br>如果某个 pod 报告它尚未准备就绪，则会从该服务中删除该 pod。如果 pod再次准备就绪，则重新添加 pod.<br>存活探针通过杀死异常的容器并用新的正常容器替代它们来保持 pod 正常工作，<br>就绪探针确保只有准备好处理请求的 pod 才可以接收它们（请求）</p>
<blockquote>
<p>设想一组pod (例如， 运行应用程序服务器的pod)取决于另 一 个pod (例如，后端数据库）提供的服务。 如果任何一个前端连接点出现连接间题并且无法再访问数据库， 那么就绪探针可能会告知Kubemet es该pod没有准备好处理任何请求。 如果其他pod实例没有遇到类似的连接问题， 则它们可以正常处理请求。 就绪探针确保客户端只与正常的pod交互， 并且永远不会知道系统存在问题.<br>通过kubectl ed江命令来向已存在的ReplicationController中的pod模板添加探针<br>kubia-replicaset-renameport.yaml</p>
</blockquote>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: ReplicaSet</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: kubia</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: kubia</span><br><span class="line">    spec:</span><br><span class="line">      nodeSelector:</span><br><span class="line">        gpu: "true"</span><br><span class="line">      containers:</span><br><span class="line">      - name: kubia</span><br><span class="line">        image: luksa/kubia</span><br><span class="line">        readinessProbe:			// pod中的每个容器都会有一个就绪探针</span><br><span class="line">          exec:</span><br><span class="line">            command:</span><br><span class="line">            - ls</span><br><span class="line">            - /var/ready</span><br><span class="line">        ports:</span><br><span class="line">        - name: http</span><br><span class="line">          containerPort: 8080</span><br><span class="line">        - name: https</span><br><span class="line">          containerPort: 8443</span><br></pre></td></tr></table></div></figure>

<p>创建RS资源并查看READY状态</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create -f kubia-replicaset-renameport.yaml</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get po</span></span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE</span><br><span class="line">kubia-2xk54   0/1     Running   0          6m20s</span><br><span class="line">kubia-bj4tz   0/1     Running   0          6m20s</span><br><span class="line">kubia-hr9bx   0/1     Running   0          6m21s</span><br></pre></td></tr></table></div></figure>

<p>通过创建/var/ready文件使其中一个文件的就绪探针返回成功，该文件的存在可以模拟就绪探针成功<br>准备就绪探针会定期检查 默认情况下每 10 秒检查一次, 最晚 10 秒钟内， 该 pod 应该已经准备就绪.</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> po/kubia-2xk54 -- touch /var/ready</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get po</span></span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE</span><br><span class="line">kubia-2xk54   1/1     Running   0          6m26s</span><br><span class="line">kubia-bj4tz   0/1     Running   0          6m26s</span><br><span class="line">kubia-hr9bx   0/1     Running   0          6m27s</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe po/kubia-2xk54</span></span><br><span class="line">......</span><br><span class="line">Readiness:      exec [ls /var/ready] delay=0s timeout=1s period=10s #success=1 #failure=3</span><br><span class="line">......</span><br></pre></td></tr></table></div></figure>

<p>修改创建过的RS的资源文件里的readiness命令是不生效的, 除非删了重建, 查看readiness Probe如下</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl edit rc kubia</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="再次测试-readiness"   >
          <a href="#再次测试-readiness" class="heading-link"><i class="fas fa-link"></i></a>再次测试 readiness</h3>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get po</span></span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE</span><br><span class="line">kubia-2xk54   1/1     Running   0          6m20s</span><br><span class="line">kubia-bj4tz   0/1     Running   0          6m20s</span><br><span class="line">kubia-hr9bx   0/1     Running   0          6m21s</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">exec</span> kubia-2xk54 -- rm -rf /var/ready		// 过大概10s后</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get po</span></span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE</span><br><span class="line">kubia-2xk54   0/1     Running   0          6m30s</span><br><span class="line">kubia-bj4tz   0/1     Running   0          6m30s</span><br><span class="line">kubia-hr9bx   0/1     Running   0          6m31s</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kubia-bj4tz -- touch /var/ready	// 过大概10s后</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get svc</span></span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE   IP          NODE       NOMINATED NODE   READINESS GATES</span><br><span class="line">kubia-2xk54   0/1     Running   0          6m40s   10.44.0.2   server02   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kubia-bj4tz   1/1     Running   0          6m40s   10.44.0.3   server02   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kubia-hr9bx   0/1     Running   0          6m40s   10.44.0.1   server02   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></div></figure>
<p>查看SVC</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get svc	// 也可以通过kubectl <span class="built_in">exec</span> kubia-bj4tz env 来查看POD所支持的所有SVC的IP等信息</span></span><br><span class="line">NAME                  TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">kubia                 ClusterIP      10.111.88.195   &lt;none&gt;        80/TCP,443/TCP   22h</span><br><span class="line">kubia-loadbalancer    LoadBalancer   10.102.224.77   &lt;pending&gt;     80:32671/TCP     3h8m</span><br></pre></td></tr></table></div></figure>

<p>两种访问方式，POD和Node<br>第一种POD访问SvcIP:SvcPort方式</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">kubectl <span class="built_in">exec</span> kubia -- curl -s  http://10.111.88.195:80		// SvcIP:SvcPort, SvcPort映射到PodIP, 可以通过describe svc查看</span></span><br><span class="line">You've hit kubia-bj4tz</span><br></pre></td></tr></table></div></figure>
<p>第二种NodeIP:NodePOrt方式</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -s 10.239.140.186:32671		// NodeIP:NodePort</span></span><br><span class="line">You've hit kubia-bj4tz</span><br></pre></td></tr></table></div></figure>

<p>应该通过删除 pod 或更改 pod 标签而不是手动更改探针来从服务中手动移除pod.<br>如果想要从某个服务中手动添加或删除 pod, 请将 enabled=true 作为标签添加到 pod, 以及服务的标签选择器中。 当想要从服务中移除 pod 时，删除标签<br>应该始终定义一 个就绪探针， 即使它只是向基准 URL 发送 HTTP 请求一样简单。</p>

        <h2 id="headless-服务"   >
          <a href="#headless-服务" class="heading-link"><i class="fas fa-link"></i></a>headless 服务</h2>
      <p>让客户端连接到所有 pod, 需要找出每个 pod 的 IP.Kubemetes 允许客户通过 DNS 查找发现 pod IP.<br>但是对千 headless 服务， 由于 DNS 返回了 pod 的 IP,客户端直接连接到该 pod, 而不是通过服务代理.<br>headless 服务仍然提供跨 pod 的负载平衡， 但是通过 DNS 轮询机制不是通过服务代理.</p>
<blockquote>
<p>如果告诉Kubemetes, 不需要为服务提供集群 IP (通过在服务 spec 中将 clusterIP 字段设置为 None 来完成此操作）， 则 DNS 服务器将返回 pod IP 而不是单个服务 IP<br>将服务 spec中的clusterIP字段设置为None 会使服务成 为headless 服务，因为Kubemetes 不会 为其分配集群IP, 客户端可通过该IP将其连接到支持它的pod<br>kubia-svc-headless.yaml</p>
</blockquote>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiersion: v1</span><br><span class="line">kin: Service</span><br><span class="line">metdata:</span><br><span class="line">  nme: kubia-headless</span><br><span class="line">spe:</span><br><span class="line">  custerIP: None		// clusterIP字段设置为None 会使服务成 为headless服务</span><br><span class="line">  prts:</span><br><span class="line">  -port: 80</span><br><span class="line">   targetPort: 8080</span><br><span class="line">  slector:</span><br><span class="line">    app: kubia</span><br><span class="line"></span><br><span class="line">$ kubectl create -f kubia-svc-headless.yaml</span><br><span class="line">$ kubectl get svc</span><br><span class="line">NAME                  TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">kubia-headless        ClusterIP      None            <span class="tag">&lt;<span class="name">none</span>&gt;</span>        80/TCP           103s</span><br></pre></td></tr></table></div></figure>




</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://kung-fu-master.github.io">Kung-Fu-Master</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://kung-fu-master.github.io/2021/03/13/micro_service/kubernetes/04_kubernetes_service/">https://kung-fu-master.github.io/2021/03/13/micro_service/kubernetes/04_kubernetes_service/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://kung-fu-master.github.io/tags/kubernetes/">kubernetes</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2021/03/13/micro_service/kubernetes/05_kubernetes_volume/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">05 Kubernetes volumes</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2021/03/13/micro_service/kubernetes/06_kubernetes_deployment/"><span class="paginator-prev__text">06 Kubernetes deployment</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Kubernetes-Service"><span class="toc-number">1.</span> <span class="toc-text">
          Kubernetes Service</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#service"><span class="toc-number">2.</span> <span class="toc-text">
          service</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Affinity-亲和性"><span class="toc-number">2.1.</span> <span class="toc-text">
          Affinity 亲和性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#环境变量发现service"><span class="toc-number">3.</span> <span class="toc-text">
          环境变量发现service</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建replicaSet-管理-3-个-POD"><span class="toc-number">3.1.</span> <span class="toc-text">
          创建replicaSet 管理 3 个 POD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除service"><span class="toc-number">3.2.</span> <span class="toc-text">
          删除service</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Service-samples"><span class="toc-number">4.</span> <span class="toc-text">
          Service samples</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#查看service"><span class="toc-number">4.1.</span> <span class="toc-text">
          查看service</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看service的CRD信息"><span class="toc-number">4.2.</span> <span class="toc-text">
          查看service的CRD信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#endpoint-服务"><span class="toc-number">5.</span> <span class="toc-text">
          endpoint 服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#暴露service"><span class="toc-number">6.</span> <span class="toc-text">
          暴露service</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NodePort-类型-service"><span class="toc-number">6.1.</span> <span class="toc-text">
          NodePort 类型 service</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LoadBalancer-方式访问"><span class="toc-number">6.2.</span> <span class="toc-text">
          LoadBalancer 方式访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ingress-暴露服务"><span class="toc-number">6.3.</span> <span class="toc-text">
          Ingress 暴露服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ingress处理TLS传输"><span class="toc-number">6.4.</span> <span class="toc-text">
          Ingress处理TLS传输</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#readiness-Probe-就绪探针"><span class="toc-number">7.</span> <span class="toc-text">
          readiness Probe 就绪探针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#再次测试-readiness"><span class="toc-number">7.1.</span> <span class="toc-text">
          再次测试 readiness</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#headless-服务"><span class="toc-number">8.</span> <span class="toc-text">
          headless 服务</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/stun-logo.svg" alt="avatar"></div><p class="sidebar-ov-author__text">Kung-Fu-Master</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://plus.google.com/" target="_blank" rel="noopener" data-popover="Google" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-google"></i></span></a><a class="sidebar-ov-social-item" href="https://twitter.com/" target="_blank" rel="noopener" data-popover="Twitter" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-twitter"></i></span></a><a class="sidebar-ov-social-item" href="https://youtube.com/" target="_blank" rel="noopener" data-popover="Youtube" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-youtube"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">292</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">40</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">12</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Kung-Fu-Master</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v4.2.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.1</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="/js/utils.js?v=2.6.1"></script><script src="/js/stun-boot.js?v=2.6.1"></script><script src="/js/scroll.js?v=2.6.1"></script><script src="/js/header.js?v=2.6.1"></script><script src="/js/sidebar.js?v=2.6.1"></script><script type="application/json" src="/search.json"></script></body></html>