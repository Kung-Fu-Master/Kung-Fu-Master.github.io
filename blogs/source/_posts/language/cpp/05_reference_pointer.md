---
title: 05 Reference & pointer
tags:
categories:
- language
- cpp
---

## Reference
对于像 char、bool、int、float 等基本类型的数据，它们占用的内存往往只有几个字节，对它们进行内存拷贝非常快速.  
而数组、结构体、对象是一系列数据的集合，数据的数量没有限制，可能很少，也可能成千上万，对它们进行频繁的内存拷贝可能会消耗很多时间，拖慢程序的执行效率.  
C/C++ 禁止在函数调用时直接传递数组的内容，而是强制传递数组指针.  
而对于结构体和对象没有这种限制，调用函数时既可以传递指针，也可以直接传递内容；为了提高效率，建议传递指针.  
但是在 C++ 中，我们有了一种比指针更加便捷的传递聚合类型数据的方式，那就是引用（Reference）.  
引用类似于 Windows 中的快捷方式，一个可执行程序可以有多个快捷方式，通过这些快捷方式和可执行程序本身都能够运行程序；引用还类似于人的绰号（笔名），使用绰号（笔名）和本名都能表示一个人。.  
引用的定义方式类似于指针，只是用&取代了*，语法格式为：
``` cpp
	type &name = data;
```
引用必须在定义的同时初始化，并且以后也要从一而终，不能再引用其它数据，这有点类似于常量（const 变量）.`  
``` cpp
	int main()
	{
	    int a = 99;
	    int &b = a;  // 变量赋值给引用变量
	    int &c = b;  // 引用便量赋值给引用变量, a, b, c 指向同一块内存地址.
	    b = 66;      // 引用也可以修改原始变量中所存储的数据
	    cout << a << ", " << b << ", " << c << endl;
	    cout << &a << ", " << &b << ", " << &c << endl; 
	    return 0;
	}
```
输出:  
```
	66, 66, 66
	0x7ffe710a246c, 0x7ffe710a246c, 0x7ffe710a246c
```
从输出结果可以看出，a 和 r 的地址一样，都是0x7ffe7cc6fe64；或者说地址为0x7ffe7cc6fe64的内存有两个名字，a 和 r，想要访问该内存上的数据时，使用哪个名字都行。  

如果读者不希望通过引用来修改原始的数据，那么可以在定义时添加 const 限制，形式为：  
``` cpp
	const type &name = value;
```
也可以是：  
``` cpp
	type const &name = value;
```
这种引用方式为常引用

### C++引用作为函数参数
在定义或声明函数时，我们可以将函数的形参指定为引用的形式，这样在调用函数时就会将实参和形参绑定在一起，让它们都指代同一份数据。如此一来，如果在函数体中修改了形参的数据，那么实参的数据也会被修改，从而拥有“在函数内部影响函数外部数据”的效果。  

按引用传参在使用形式上比指针更加直观。在以后的 C++ 编程中，鼓励读者大量使用引用，它一般可以代替指针（当然指针在C++中也不可或缺）.  

**指针传递与引用传递区别如下：**
``` cpp
	void swap1(int *m, int *n)
	{
	    int temp = *m;
	    *m = *n;
	    *n = temp;
	}
	
	void swap2(int &m, int &n)
	{
	    int temp = m;
	    m = n;
	    n = temp;
	    cout << "Reference address: " << &m << " , " << &n << endl;
	}

	int num1 = 1, num2 = 2;
	swap1(&num1, &num2);
	cout << "num1: " << num1 << ", num2: " << num2 << endl;
	num1 = 1;
	num2 = 2;
	cout << "Address: " << &num1 << " , " << &num2 << endl;
	swap2(num1, num2);
	cout << "num1: " << num1 << ", num2: " << num2 << endl;
```
输出:  
```
	num1: 2, num2: 1
	Address: 0x7fff31e04090 , 0x7fff31e0408c
	Reference address: 0x7fff31e04090 , 0x7fff31e0408c
	num1: 2, num2: 1
```
可以看到引用参数在内存中地址和实参变量地址相同.  


### C++引用作为函数返回值
``` cpp
	int &plus10(int &num)
	{
	    num += 10;
	    return num;
	}

	int num = 10;
	plus10(num);
	cout << "num: " << num << endl;
```
输出:
```
	num: 20
```
在将引用作为函数返回值时应该注意一个小问题，就是不能返回局部数据（例如局部变量、局部对象、局部数组等）的引用，因为当函数调用完成后局部数据就会被销毁，有可能在下次使用时数据就不存在了，C++ 编译器检测到该行为时也会给出警告.  
但可以返回用非局部变量赋值的引用变量如下面的&n.  

``` cpp
	int &plus10(int &num)
	{
	    int &n = num;
	    n += 10;
	    return n;
	    // int m = r + 10;  
	    // return m;        //错误用法, 禁止返回局部数据的引用
	}
```
### 引用实质
其实引用只是对指针进行了简单的封装，它的底层依然是通过指针实现的，引用占用的内存和指针占用的内存长度一样，在 32 位环境下是 4 个字节，在 64 位环境下是 8 个字节，之所以不能获取引用的地址，是因为编译器进行了内部转换.  

``` cpp
	int a = 99;
	int &r = a;
	r = 18;
	cout<<&r<<endl;
```
编译时会被转换成如下的形式：

``` cpp
	int a = 99;
	int *r = &a;
	*r = 18;
	cout<<r<<endl;
```

## "引用" 与 "指针" 区别
1. 引用必须在定义时初始化，并且以后也要从一而终，不能再指向其他数据；而指针没有这个限制，指针在定义时不必赋值，以后也能指向任意数据。

2. 可以有 const 指针，但是没有 const 引用。也就是说，引用变量不能定义为下面的形式：


``` cpp
	int a = 20;
	int & const r = a;
```
因为 r 本来就不能改变指向，加上 const 是多此一举。

3. 指针可以有多级，但是引用只能有一级，例如，int **p是合法的，而int &&r是不合法的。如果希望定义一个引用变量来指代另外一个引用变量，那么也只需要加一个&，如下所示：


``` cpp
	int a = 10;
	int &r = a;
	int &rr = r;
```
4. 指针和引用的自增（++）自减（--）运算意义不一样。对指针使用 ++ 表示指向下一份数据，对引用使用 ++ 表示它所指代的数据本身加 1；自减（--）也是类似的道理.  


``` cpp
	int a = 10;
	int &r = a;
	r++;
	cout << r << endl;
	
	int arr[2] = {27, 84};
	int *p = arr;
	p++;
	cout << *p << endl;
```
输出:

```
	11
	84
```
## 指针
指针就是数据或代码在内存中的地址，指针变量指向的就是内存中的数据或代码。这里有一个关键词需要强调，就是内存，指针只能指向内存，不能指向寄存器或者硬盘，因为寄存器和硬盘没法寻址。  

### 指针无法指向的变量等
例如表达式的结果、函数的返回值等，它们可能会放在内存中，也可能会放在寄存器中。一旦它们被放到了寄存器中，就没法用&获取它们的地址了，也就没法用指针指向它们了。  

`寄存器离 CPU 近，并且速度比内存快，将临时数据放到寄存器是为了加快程序运行.`  

int、double、bool、char 等基本类型的数据往往不超过 8 个字节，用一两个寄存器就能存储，所以这些类型的临时数据通常会放到寄存器中；而对象、结构体变量是自定义类型的数据，大小不可预测，所以这些类型的临时数据通常会放到内存中.  

1. 下面的代码演示了表达式所产生的临时结果, 这些表达式的结果都会被放到寄存器中，尝试用&获取它们的地址都是错误的。


``` cpp
	int n = 100, m = 200;
	int *p1 = &(m + n);    //m + n 的结果为 300
	int *p2 = &(n + 100);  //n + 100 的结果为 200
	bool *p4 = &(m < n);   //m < n 的结果为 false
```
2. 下面的代码演示了函数返回值所产生的临时结果, func() 的返回值 100 也会被放到寄存器中，也没法用&获取它的地址.  


``` cpp
	int func(){
	    int n = 100;
	    return n;
	}
	int *p = &(func());
```
3. 常量表达式由于不包含变量，没有不稳定因素，所以在编译阶段就能求值。编译器不会分配单独的内存来存储常量表达式的值，而是将常量表达式的值和代码合并到一起，放到虚拟地址空间中的代码区.  
诸如 100、200+34、34.5*23、3+7/3 等不包含变量的表达式称为常量表达式（Constant expression).  

### 引用错误使用临时变量
引用作为函数参数时，有时候很容易给它传递临时数据, 这是不允许的, 因为引用和指针在本质上是一样的，引用仅仅是对指针进行了简单的封装.  


``` cpp
	bool isOdd(int &n){
	    if(n%2 == 0){
	        return false;
	    }else{
	        return true;
	    }
	}
	
	int a = 100;
	isOdd(a);      // 正确
	isOdd(a + 9);  // 错误
	isOdd(27);     // 错误
```
### 引用正确使用临时变量
const 引用和普通引用不一样，我们只能通过 const 引用读取数据的值，而不能修改它的值，所以不用考虑同步更新的问题，也不会产生两份不同的数据，为 const 引用创建临时变量反而会使得引用更加灵活和通用.  

``` cpp
	bool isOdd(const int &n){  //改为常引用
	    if(n/2 == 0){
	        return false;
	    }else{
	        return true;
	    }
	}
```
由于在函数体中不会修改 n 的值，所以可以用 const 限制 n，这样一来，下面的函数调用就都是正确的了：

``` cpp
	int a = 100;
	isOdd(a);        //正确
	isOdd(a + 9);    //正确
	isOdd(27);       //正确
	isOdd(23 + 55);  //正确
```
对于第 2 行代码，编译器不会创建临时变量，会直接绑定到变量 a；对于第 3~5 行代码，编译器会创建临时变量来存储临时数据。也就是说，编译器只有在必要时才会创建临时变量

## 引用类型的函数形参请尽可能的使用 const
当引用的类型和数据的类型不一致时，如果它们的类型是相近的，并且遵守「数据类型的自动转换」规则，那么编译器就会创建一个临时变量，并将数据赋值给这个临时变量（这时候会发生自动类型转换），然后再将引用绑定到这个临时的变量，这与「将 const 引用绑定到临时数据时」采用的方案是一样的.  

引用作为函数参数时，如果在函数体内部不会修改引用所绑定的数据，那么请尽量为该引用添加 const 限制.  

``` cpp
	#include <cstdio>
	using namespace std;
	double volume(const double &len, const double &width, const double &hei)
	{
	    return len * width * 2 + len * hei * 2 + width * hei * 2;
	}
	int main()
	{
	    int a = 12, b = 3, c = 20;
	    double v1 = volume(a, b, c);
	    double v2 = volume(10, 20, 30);
	    double v3 = volume(89.4, 32.7, 19);
	    double v4 = volume(a + 12.5, b + 23.4, 16.78);
	    double v5 = volume(a + b, a + c, b + c);
	    printf("%lf, %lf, %lf, %lf, %lf\n", v1, v2, v3, v4, v5);
	    return 0;
	}
```
运行结果：

```
	672.000000, 2200.000000, 10486.560000, 3001.804000, 3122.000000
```
概括起来说，将引用类型的形参添加 const 限制的理由有三个：
 * 使用 const 可以避免无意中修改数据的编程错误；
 * 使用 const 能让函数接收 const 和非 const 类型的实参，否则将只能接收非 const 类型的实参；
 * 使用 const 引用能够让函数正确生成并使用临时变量。


