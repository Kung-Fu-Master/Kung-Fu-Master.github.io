<!-- build time:Wed Mar 17 2021 03:02:11 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Hexo" href="https://kung-fu-master.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Hexo" href="https://kung-fu-master.github.io/atom.xml"><link rel="alternate" type="application/json" title="Hexo" href="https://kung-fu-master.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="docker"><link rel="canonical" href="https://kung-fu-master.github.io/2021/03/13/technologies/docker/docker_01_installation/"><title>docker 01 installation and control commands - docker - technologies | Kung Fu Master = Hexo</title><meta name="generator" content="Hexo 4.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">docker 01 installation and control commands</h1><div class="meta"><span class="item" title="创建时间：2021-03-13 13:00:42"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-03-13T13:00:42+08:00">2021-03-13</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>19k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>17 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Kung Fu Master</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giph4baakhj20zk0m8h5q.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclj9410cj20zk0m8h12.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipeyhsblkj20zk0m81kx.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipeuv80yoj20zk0m8kjl.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipeuibk9fj20zk0m8ay2.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipesng5oej20zk0m87d4.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/technologies/" itemprop="item" rel="index" title="分类于 technologies"><span itemprop="name">technologies</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/technologies/docker/" itemprop="item" rel="index" title="分类于 docker"><span itemprop="name">docker</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://kung-fu-master.github.io/2021/03/13/technologies/docker/docker_01_installation/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Kung-Fu-Master"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hexo"></span><div class="body md" itemprop="articleBody"><h2 id="docker-引擎"><a class="anchor" href="#docker-引擎">#</a> Docker 引擎</h2><p>目前 Docker 支持 Docker 引 擎、 Docker Hub 、 Docker Cloud 等多种服务 。</p><ul><li>Docker 引擎：包括支持在桌面系统或云平台安装 Docker，以及为企业提供简单安全弹性的容器集群编排和管理；</li><li>DockerHub ：官方提供的云托管服务，可以提供公有或私有的镜像仓库；</li><li>DockerCloud ：官方提供的容器云服务，可以完成容器的部署与管理，可以完整地支持容器化项目，还有 CI 、 CD 功能</li></ul><p><a id="more"></a><br>用户可以通过如下命令检查自己的内核版本详细信息 ：</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ <span class="token function">uname</span> -a</pre></td></tr><tr><td data-num="2"></td><td><pre> $ <span class="token function">cat</span> /proc/version</pre></td></tr></table></figure><h2 id="ubuntu1804-docker环境安装"><a class="anchor" href="#ubuntu1804-docker环境安装">#</a> Ubuntu18.04 docker 环境安装：</h2><p>官网: <span class="exturl" data-url="aHR0cHM6Ly93d3cuZG9ja2VyLmNvbS9nZXQtc3RhcnRlZA==">https://www.docker.com/get-started</span><br>查找 image: <span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9zZWFyY2g/dHlwZT1pbWFnZQ==">https://hub.docker.com/search?type=image</span></p><h2 id="简介"><a class="anchor" href="#简介">#</a> 简介</h2><blockquote><p>Docker 是基于 Go 语言实现的开源容器项目 。 它诞生于 2013 年年初，最初发起者是 dotCloud 公司，dotCloud 公司也随之快速发展壮大，在 2013 年年底直接改名为 Docker Inc ，并专注于 Docker 相关技术和产品的开发，目前已经成为全球最大的 Docker 容器服务提供商 。 官方网站为 <span class="exturl" data-url="aHR0cDovL2RvY2tlci5jb20=">docker.com</span><br>在 Linux 基金会最近一次关于 “最受欢 迎的 云 计算开源项目” 的调查中， Docker 仅次于 2010 年发起的 OpenStack 项目，并仍处于上升趋势 。2014 年， Docker 镜像下载数达到了一百万次， 2015 年直接突破十亿次， 2017 年更是突破了惊人的百亿次<br>Docker 的构想是要实现 “Build , Ship and Run Any App, Anywhere”，即通过对应用的封装（ Packaging）、分发（ Distribution ）、部署（ Deployment）、运行（ Runtime ）生命周期进行管理，达到应用组件级别的 “一次封装 ，到处运行”<br>与大部分新兴技术的诞生一样， Docker 也并非 “从石头缝里蹦出来的”，而是站在前人的肩膀上。 其中最重要的就是 Linux 容器（ Linux Containers, LXC ）技术.<br>每个容器内运行着一个应用，不同的容器相互隔离，容器之间也可以通过网络互相通信 。 容器的创建和停止十分快速，几乎跟创建和终止原生应用－致.<br>容器自身对系统资源的额外需求也十分有限，远远低于传统虚拟机。 很多时候，甚至直接把容器当作应用本身也没有任何问题.</p></blockquote><h2 id="为什么用docker"><a class="anchor" href="#为什么用docker">#</a> 为什么用 Docker</h2><blockquote><p>在云时代，开发者创建的应用必须要能很方便地在网络上传播，也就是说应用必须脱离底层物理硬件的限制；同时必须是 “任何时间任何地点” 可获取的 。 因此，开发者们需要一种新型的创建分布式应用程序的方式，快速分发和部署，而这正是 Docker 所能够提供的最大优势<br>Docker 提供了一种更为聪明的方式，通过容器来打包应用、解藕应用和运行平台。这意味着迁移的时候，只需要在新的服务器上启动需要的容器就可以了，无论新旧服务器是否是同一类型的平台 。 这无疑将帮助我们节约大量的宝贵时间，并降低部署过程出现问题的风险<br>传统虚拟机方式运行 N 个不同的应用就要启用 N 个虚拟机（每个虚拟机需要单独分配独占的内存、磁盘等资源），而 Docker 只需要启动 N 个隔离得 “很薄的” 容器，并将应用放进容器内即可 。 应用获得的是接近原生的运行性能<br>传统方式是在硬件层面实现虚拟化，需要有额外的虚拟机管理应用和虚拟机操作系统层。 Docker 容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，因此更加轻量级</p></blockquote><h2 id="docker-ce与-docker-ee区别"><a class="anchor" href="#docker-ce与-docker-ee区别">#</a> docker ce 与 docker ee 区别</h2><ul><li><p>Docker Engine 改为 Docker CE (社区版), 它包含了 CLI 客户端、后台进程 / 服务以及 API。用户像以前以同样的方式获取。<br>docker-ce 是 docker 公司维护的开源项目，是一个基于 moby 项目的免费的容器产品；</p></li><li><p>Docker Data Center 改为 Docker EE（企业版）<br>docker-ee 是 docker 公司维护的闭源产品，是 docker 公司的商业产品；<br>这些 ce 和 ee 版并不影响 Docker Compose 以及 Docker Machine<br>docker-ce project 是 docker 公司维护，docker-ee 是闭源的；</p></li></ul><p>要使用免费的 docker，从网页 docker-ce 上获取；</p><p>要使用收费的 docker，从网页 docker-ee 上获取</p><h2 id="docker-ucp-介绍"><a class="anchor" href="#docker-ucp-介绍">#</a> docker UCP 介绍</h2><blockquote><p>Docker Universal Control Plane（UCP）是 Docker 公司在 2015 年底巴塞罗那的开发者大会上发布的，这是一个跟单信用证，是一个新的 Docker 支付服务的组合的一部分，旨在帮助运维团队轻松地设置一个集群，使开发人员可以快速部署 Dockerized 应用。他们构建 Docker DataCenter 的其中重要的组成部分。<br>UCP 集群包含两种节点：<br>Controller: 管理集群，并持久化集群配置<br>Node：运行容器</p></blockquote><h2 id="安装curl"><a class="anchor" href="#安装curl">#</a> 安装 curl:</h2><blockquote><ul><li>第一种方法:</li></ul></blockquote><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>https://curl.haxx.se/download.html</pre></td></tr><tr><td data-num="2"></td><td><pre>	 $ curl-7.69.1.tar.gz</pre></td></tr><tr><td data-num="3"></td><td><pre>	 $ ./configure --prefix<span class="token operator">=</span>/usr/local/curl</pre></td></tr><tr><td data-num="4"></td><td><pre>	 $ <span class="token function">make</span> -j12</pre></td></tr><tr><td data-num="5"></td><td><pre>	 $ <span class="token function">make</span> <span class="token function">install</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	 $ <span class="token function">ln</span> -s /usr/local/curl/bin/curl /usr/bin</pre></td></tr><tr><td data-num="7"></td><td><pre>	 $ <span class="token function">vim</span> ~/.bashrc 添加 <span class="token builtin class-name">export</span> <span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span><span class="token variable">$LD_LIBRARY_PATH</span>:/usr/local/curl/lib</pre></td></tr><tr><td data-num="8"></td><td><pre>	 $ <span class="token builtin class-name">source</span> ~/.bashrc</pre></td></tr><tr><td data-num="9"></td><td><pre>	 $ <span class="token function">curl</span> --version 		// 查看curl版本和支持的协议如http, https</pre></td></tr></table></figure><blockquote><ul><li>第二种方法 (推荐，方便快捷):</li></ul></blockquote><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ <span class="token function">apt-get</span> update</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ <span class="token function">apt-get</span> upgrade</pre></td></tr><tr><td data-num="3"></td><td><pre>	$ <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">curl</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	$ <span class="token function">curl</span> --version</pre></td></tr></table></figure><blockquote><ul><li>提前设置好系统的 proxy 如:</li></ul></blockquote><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ <span class="token builtin class-name">export</span> <span class="token assign-left variable">http_proxy</span><span class="token operator">=</span>child-prc.intel.com:913</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ <span class="token builtin class-name">export</span> <span class="token assign-left variable">https_proxy</span><span class="token operator">=</span>child-prc.intel.com:913 // https的proxy与上面的http的要一样</pre></td></tr></table></figure><h2 id="安装docker"><a class="anchor" href="#安装docker">#</a> <strong>安装 docker</strong></h2><h3 id="ubuntu安装docker"><a class="anchor" href="#ubuntu安装docker">#</a> Ubuntu 安装 docker</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ <span class="token function">apt-get</span> <span class="token function">install</span> docker</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ <span class="token function">apt-get</span> <span class="token function">install</span> docker.io</pre></td></tr></table></figure><h3 id="centos安装docker"><a class="anchor" href="#centos安装docker">#</a> Centos 安装 docker</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ yum update</pre></td></tr><tr><td data-num="2"></td><td><pre>	yum-utils 提供了 yum-config-manager ，并且 device mapper 存储驱动程序需要 device-mapper-persistent-data 和 lvm2</pre></td></tr><tr><td data-num="3"></td><td><pre>	$ yum <span class="token function">install</span> -y yum-utils device-mapper-persistent-data lvm2</pre></td></tr><tr><td data-num="4"></td><td><pre>	配置docker yum源</pre></td></tr><tr><td data-num="5"></td><td><pre>	第一种: 官方源</pre></td></tr><tr><td data-num="6"></td><td><pre>	$ yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</pre></td></tr><tr><td data-num="7"></td><td><pre>	第二种: 阿里云</pre></td></tr><tr><td data-num="8"></td><td><pre>	$ yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</pre></td></tr><tr><td data-num="9"></td><td><pre>	第三种: 清华云</pre></td></tr><tr><td data-num="10"></td><td><pre>	$ yum-config-manager --add-repo https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo</pre></td></tr><tr><td data-num="11"></td><td><pre>	安装docker</pre></td></tr><tr><td data-num="12"></td><td><pre>	第一种: 安装最新版本的 Docker Engine-Community 和 containerd</pre></td></tr><tr><td data-num="13"></td><td><pre>	<span class="token function">sudo</span> yum <span class="token function">install</span> docker-ce docker-ce-cli containerd.io</pre></td></tr><tr><td data-num="14"></td><td><pre>	第二种: 查看可安装的版本</pre></td></tr><tr><td data-num="15"></td><td><pre>	$ yum list docker-ce --showduplicates <span class="token operator">|</span> <span class="token function">sort</span> -r</pre></td></tr><tr><td data-num="16"></td><td><pre>	软件包名称是软件包名称（docker-ce）加上版本字符串（第二列），从第一个冒号（:）一直到第一个连字符，并用连字符（-）分隔。例如：docker-ce-18.09.1.</pre></td></tr><tr><td data-num="17"></td><td><pre>	安装指定版本</pre></td></tr><tr><td data-num="18"></td><td><pre>	如docker-ce-19.03.9</pre></td></tr><tr><td data-num="19"></td><td><pre>	$ yum <span class="token function">install</span> docker-ce-<span class="token operator">&lt;</span>VERSION_STRING<span class="token operator">></span> docker-ce-cli-<span class="token operator">&lt;</span>VERSION_STRING<span class="token operator">></span> containerd.io</pre></td></tr><tr><td data-num="20"></td><td><pre>	启动docker服务</pre></td></tr><tr><td data-num="21"></td><td><pre>	$ systemctl start docker</pre></td></tr><tr><td data-num="22"></td><td><pre>	$ systemctl <span class="token builtin class-name">enable</span> docker</pre></td></tr></table></figure><h3 id="改变docker运行时存储目录和存储驱动"><a class="anchor" href="#改变docker运行时存储目录和存储驱动">#</a> 改变 docker 运行时存储目录和存储驱动</h3><p>reference: <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vY29uZmlnL2RhZW1vbi9zeXN0ZW1kLyNjdXN0b20tZG9ja2VyLWRhZW1vbi1vcHRpb25z">https://docs.docker.com/config/daemon/systemd/#custom-docker-daemon-options</span></p><p>You may want to control the disk space used for Docker images, containers, and volumes by moving it to a separate partition.</p><p>To accomplish this, set the following flags in the <strong><code>/etc/docker/daemon.json</code> </strong>file on Linux by default.</p><pre><code>{
    &quot;data-root&quot;: &quot;/mnt/docker-data&quot;, // 改变image,container,volumes在宿主机存储目录
    &quot;storage-driver&quot;: &quot;overlay2&quot;     // 改变存储驱动
}
</code></pre><p>daemon.json 所有配置信息参考: <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9kb2NrZXJkLyNkYWVtb24tY29uZmlndXJhdGlvbi1maWxl">https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file</span><br>内容如下:</p><pre><code>{
  &quot;allow-nondistributable-artifacts&quot;: [],
  &quot;api-cors-header&quot;: &quot;&quot;,
  &quot;authorization-plugins&quot;: [],
  &quot;bip&quot;: &quot;&quot;,
  &quot;bridge&quot;: &quot;&quot;,
  &quot;cgroup-parent&quot;: &quot;&quot;,
  &quot;cluster-advertise&quot;: &quot;&quot;,
  &quot;cluster-store&quot;: &quot;&quot;,
  &quot;cluster-store-opts&quot;: {},
  &quot;containerd&quot;: &quot;/run/containerd/containerd.sock&quot;,
  &quot;containerd-namespace&quot;: &quot;docker&quot;,
  &quot;containerd-plugin-namespace&quot;: &quot;docker-plugins&quot;,
  &quot;data-root&quot;: &quot;&quot;,
  &quot;debug&quot;: true,
  &quot;default-address-pools&quot;: [
    {
      &quot;base&quot;: &quot;172.80.0.0/16&quot;,
      &quot;size&quot;: 24
    },
    {
      &quot;base&quot;: &quot;172.90.0.0/16&quot;,
      &quot;size&quot;: 24
    }
  ],
  &quot;default-cgroupns-mode&quot;: &quot;private&quot;,
  &quot;default-gateway&quot;: &quot;&quot;,
  &quot;default-gateway-v6&quot;: &quot;&quot;,
  &quot;default-runtime&quot;: &quot;runc&quot;,
  &quot;default-shm-size&quot;: &quot;64M&quot;,
  &quot;default-ulimits&quot;: {
    &quot;nofile&quot;: {
      &quot;Hard&quot;: 64000,
      &quot;Name&quot;: &quot;nofile&quot;,
      &quot;Soft&quot;: 64000
    }
  },
  &quot;dns&quot;: [],
  &quot;dns-opts&quot;: [],
  &quot;dns-search&quot;: [],
  &quot;exec-opts&quot;: [],
  &quot;exec-root&quot;: &quot;&quot;,
  &quot;experimental&quot;: false,
  &quot;features&quot;: {},
  &quot;fixed-cidr&quot;: &quot;&quot;,
  &quot;fixed-cidr-v6&quot;: &quot;&quot;,
  &quot;group&quot;: &quot;&quot;,
  &quot;hosts&quot;: [],
  &quot;icc&quot;: false,
  &quot;init&quot;: false,
  &quot;init-path&quot;: &quot;/usr/libexec/docker-init&quot;,
  &quot;insecure-registries&quot;: [],
  &quot;ip&quot;: &quot;0.0.0.0&quot;,
  &quot;ip-forward&quot;: false,
  &quot;ip-masq&quot;: false,
  &quot;iptables&quot;: false,
  &quot;ip6tables&quot;: false,
  &quot;ipv6&quot;: false,
  &quot;labels&quot;: [],
  &quot;live-restore&quot;: true,
  &quot;log-driver&quot;: &quot;json-file&quot;,
  &quot;log-level&quot;: &quot;&quot;,
  &quot;log-opts&quot;: {
    &quot;env&quot;: &quot;os,customer&quot;,
    &quot;labels&quot;: &quot;somelabel&quot;,
    &quot;max-file&quot;: &quot;5&quot;,
    &quot;max-size&quot;: &quot;10m&quot;
  },
  &quot;max-concurrent-downloads&quot;: 3,
  &quot;max-concurrent-uploads&quot;: 5,
  &quot;max-download-attempts&quot;: 5,
  &quot;mtu&quot;: 0,
  &quot;no-new-privileges&quot;: false,
  &quot;node-generic-resources&quot;: [
    &quot;NVIDIA-GPU=UUID1&quot;,
    &quot;NVIDIA-GPU=UUID2&quot;
  ],
  &quot;oom-score-adjust&quot;: -500,
  &quot;pidfile&quot;: &quot;&quot;,
  &quot;raw-logs&quot;: false,
  &quot;registry-mirrors&quot;: [],
  &quot;runtimes&quot;: {
    &quot;cc-runtime&quot;: {
      &quot;path&quot;: &quot;/usr/bin/cc-runtime&quot;
    },
    &quot;custom&quot;: {
      &quot;path&quot;: &quot;/usr/local/bin/my-runc-replacement&quot;,
      &quot;runtimeArgs&quot;: [
        &quot;--debug&quot;
      ]
    }
  },
  &quot;seccomp-profile&quot;: &quot;&quot;,
  &quot;selinux-enabled&quot;: false,
  &quot;shutdown-timeout&quot;: 15,
  &quot;storage-driver&quot;: &quot;&quot;,
  &quot;storage-opts&quot;: [],
  &quot;swarm-default-advertise-addr&quot;: &quot;&quot;,
  &quot;tls&quot;: true,
  &quot;tlscacert&quot;: &quot;&quot;,
  &quot;tlscert&quot;: &quot;&quot;,
  &quot;tlskey&quot;: &quot;&quot;,
  &quot;tlsverify&quot;: true,
  &quot;userland-proxy&quot;: false,
  &quot;userland-proxy-path&quot;: &quot;/usr/libexec/docker-proxy&quot;,
  &quot;userns-remap&quot;: &quot;&quot;
}
</code></pre><h3 id="配置docker的proxy"><a class="anchor" href="#配置docker的proxy">#</a> 配置 docker 的 proxy</h3><p>reference: <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vY29uZmlnL2RhZW1vbi9zeXN0ZW1kLyNodHRwaHR0cHMtcHJveHk=">https://docs.docker.com/config/daemon/systemd/#httphttps-proxy</span></p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ <span class="token function">mkdir</span> -p /etc/systemd/system/docker.service.d</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ <span class="token function">touch</span> /etc/systemd/system/docker.service.d/proxy.conf</pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token punctuation">[</span>Service<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token assign-left variable">Environment</span><span class="token operator">=</span><span class="token string">"HTTP_PROXY=http://&lt;proxy>:913"</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token assign-left variable">Environment</span><span class="token operator">=</span><span class="token string">"HTTPS_PROXY=http://&lt;proxy>:913"</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token assign-left variable">Environment</span><span class="token operator">=</span><span class="token string">"NO_PROXY=10.67.108.211,10.67.109.142,10.67.109.147,10.67.109.144,10.67.108.220,127.0.0.1,hce-node01,hce-node02,hce-node03,hce-node04"</span></pre></td></tr></table></figure><p>Flush changes and restart Docker</p><pre><code>sudo systemctl daemon-reload
sudo systemctl restart docker
</code></pre><p>Verify that the configuration has been loaded and matches the changes you made, for example:</p><pre><code>sudo systemctl show --property=Environment docker
    
Environment=HTTP_PROXY=http://proxy.example.com:80 HTTPS_PROXY=https://proxy.example.com:443 NO_PROXY=localhost,127.0.0.1,
</code></pre><h3 id="keep-containers-alive-during-daemon-downtime"><a class="anchor" href="#keep-containers-alive-during-daemon-downtime">#</a> Keep containers alive during daemon downtime</h3><p>reference: <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vY29uZmlnL2NvbnRhaW5lcnMvbGl2ZS1yZXN0b3JlLw==">https://docs.docker.com/config/containers/live-restore/</span><br>Use the <strong><code>/etc/docker/daemon.json</code> </strong>to enable <strong><code>live-restore</code></strong></p><pre><code>{
  &quot;live-restore&quot;: true
}
</code></pre><p>Restart the Docker daemon. On Linux, you can avoid a restart (and avoid any downtime for your containers) by reloading the Docker daemon. If you use <strong><code>systemd</code> </strong>, then use the command <strong><code>systemctl reload docker</code> </strong>. Otherwise, send a SIGHUP signal to the dockerd process.</p><h3 id="additional"><a class="anchor" href="#additional">#</a> Additional</h3><p>可以在 Docker 服务启动配置中增加 --registry-mirror=proxy_URL 来指定镜像代理服务地址（如 https://registry.docker-en.com)</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ <span class="token builtin class-name">cd</span> /etc/docker</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ <span class="token function">touch</span> daemon.json</pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token string">"insecure-registries"</span> :<span class="token punctuation">[</span><span class="token string">"10.239.82.163:5000"</span><span class="token punctuation">]</span>,  // 此文件设置为空, 需要从10.239.82.163这台机器拉镜像时候才需要添加此内容</pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token string">"registry-mirrors"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token string">"https://uxk0ognt.mirror.aliyuncs.com"</span><span class="token punctuation">]</span>	//使用国内镜像下载images</pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	$ systemctl daemon-reload</pre></td></tr><tr><td data-num="8"></td><td><pre>	$ systemctl restart docker</pre></td></tr><tr><td data-num="9"></td><td><pre>	$ docker search redis</pre></td></tr></table></figure><h2 id="安装docker-compose"><a class="anchor" href="#安装docker-compose">#</a> <strong>安装 docker compose</strong></h2><p>// 关于此程序说明可以参考 <span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9kb2NrZXIvZG9ja2VyLWNvbXBvc2UuaHRtbA==">https://www.runoob.com/docker/docker-compose.html</span></p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>https://github.com/docker/compose/releases</pre></td></tr><tr><td data-num="2"></td><td><pre>	 <span class="token function">curl</span> -L https://github.com/docker/compose/releases/download/1.25.4/docker-compose-<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> -s<span class="token variable">`</span></span>-<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> -m<span class="token variable">`</span></span> -o /usr/local/bin/docker-compose</pre></td></tr><tr><td data-num="3"></td><td><pre>	 <span class="token function">chmod</span> +x /usr/local/bin/docker-compose</pre></td></tr></table></figure><h2 id="容器的使用"><a class="anchor" href="#容器的使用">#</a> 容器的使用</h2><h3 id="查看所有的容器"><a class="anchor" href="#查看所有的容器">#</a> 查看所有的容器</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker <span class="token function">ps</span> -a</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ docker <span class="token function">ps</span> -a --no-trunc		// 不截短，全部输出container信息</pre></td></tr><tr><td data-num="3"></td><td><pre>	$ docker inspcet <span class="token operator">&lt;</span>Container<span class="token operator">></span>	// 查看某个container的详细信息</pre></td></tr><tr><td data-num="4"></td><td><pre>	如果在容器内部。可以用 <span class="token function">ps</span> -fe 查看。其中1号进程就是启动命令</pre></td></tr></table></figure><h3 id="查询最后一次创建的容器"><a class="anchor" href="#查询最后一次创建的容器">#</a> 查询最后一次创建的容器</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker <span class="token function">ps</span> -l</pre></td></tr></table></figure><h3 id="启动容器"><a class="anchor" href="#启动容器">#</a> 启动容器</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker run -it --name ubuntu_container ubuntu /bin/bash</pre></td></tr></table></figure><ul><li>-i: 交互式操作，则让容器的标准输入保持打开.</li><li>-t: 终端，让 Docker 分配一个伪终端（ pseudo－即）并绑定到容器的标准输入上，</li><li>ubuntu: ubuntu 镜像。</li><li>/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。<br>当利用 docker [container] run 来创建并启动容器时， Docker 在后台运行的标准操作包括：</li><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载；</li><li>利用镜像创建一个容器，并启动该容器；</li><li>分配一个文件系统给容器，并在只读的镜像层外面挂载一层可读写层 ；</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去；</li><li>从网桥的地址池配置一个 IP 地址给容器；</li><li>执行用户指定的应用程序；</li><li>执行完毕后容器被自动终止。</li></ul><h3 id="启动并进入容器"><a class="anchor" href="#启动并进入容器">#</a> 启动并进入容器</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker run --name ubuntu_18.04_v1.0 ubuntu_test:18.04 /bin/echo <span class="token string">'hello'</span> // 不加 -it容器执行完echo <span class="token string">'hello'</span>后就退出</pre></td></tr><tr><td data-num="2"></td><td><pre>	hello</pre></td></tr><tr><td data-num="3"></td><td><pre>	$ docker run -itd --name ubuntu_18.04_v2.0 ubuntu_test:18.04 /bin/bash // 不加参数d容器退出后，就终止运行，最好加上d，容器退出后容器内进程仍然后台执行</pre></td></tr><tr><td data-num="4"></td><td><pre>	$ docker <span class="token builtin class-name">exec</span> -it ubuntu_18.04_v2.0 /bin/bash</pre></td></tr><tr><td data-num="5"></td><td><pre>	root@1cf8105dbd62:/<span class="token comment"># ps</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	 PID TTY          TIME CMD</pre></td></tr><tr><td data-num="7"></td><td><pre>	   <span class="token number">1</span> pts/0    00:00:00 <span class="token function">bash</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	  <span class="token number">11</span> pts/0    00:00:00 <span class="token function">ps</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	root@1cf8105dbd62:/<span class="token comment">#</span></pre></td></tr></table></figure><p>在容器内用 ps 命令查看进程，可以看到，只运行了 bash 应用，并没有运行其他无关的进程<br>Ctrl+d 或输入 exit 命令来退出容器：</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>root@afBbae53bdd3:/<span class="token comment"># exit</span></pre></td></tr></table></figure><p>进入容器后配置好 proxy 如:</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ <span class="token builtin class-name">export</span> <span class="token assign-left variable">http_proxy</span><span class="token operator">=</span>child-prc.intel.com:913</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ <span class="token function">apt-get</span> update</pre></td></tr><tr><td data-num="3"></td><td><pre>	$ <span class="token function">apt-get</span> <span class="token function">install</span> python <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span></pre></td></tr></table></figure><h3 id="停止一个容器"><a class="anchor" href="#停止一个容器">#</a> 停止一个容器</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker stop <span class="token operator">&lt;</span>容器 ID<span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre>	停止的容器可以通过 docker restart 重启：</pre></td></tr><tr><td data-num="3"></td><td><pre>	$ docker restart <span class="token operator">&lt;</span>容器 ID<span class="token operator">></span></pre></td></tr></table></figure><h3 id="启动已停止运行的容器"><a class="anchor" href="#启动已停止运行的容器">#</a> 启动已停止运行的容器</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker start b750bbbcfd88</pre></td></tr></table></figure><h3 id="后台运行"><a class="anchor" href="#后台运行">#</a> 后台运行</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker run -itd --name ubuntu-test ubuntu /bin/bash</pre></td></tr></table></figure><ul><li>-d: 指定容器的运行模式.</li><li>容器已启动，但是没登录，后端运行，可通过 $ docker ps 查看，再执行 $ docker exec -it &lt;容器 ID&gt; /bin/bash 即可进入</li></ul><h3 id="进入容器"><a class="anchor" href="#进入容器">#</a> 进入容器</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>// docker attach 1e560fca3906 				//  如果从这个容器退出，会导致容器的停止, 不推荐使用</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ docker <span class="token builtin class-name">exec</span> -it 243c32535da7 /bin/bash		// 从这个容器退出，不会导致容器的停止</pre></td></tr></table></figure><h3 id="退出终端"><a class="anchor" href="#退出终端">#</a> 退出终端</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>root@ed09e4490c57:/<span class="token comment"># exit</span></pre></td></tr></table></figure><h3 id="导出容器"><a class="anchor" href="#导出容器">#</a> 导出容器</h3><ul><li>第一种:</li></ul><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker <span class="token builtin class-name">export</span> a1cb4017f313 <span class="token operator">></span> export_ubuntu_container.tar		// 导出容器 1e560fca3906 快照到本地文件 ubuntu.tar。</pre></td></tr></table></figure><ul><li>第二种:</li></ul><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker <span class="token builtin class-name">export</span> -o export_ubuntu_container.tar a1cb4017f313</pre></td></tr></table></figure><p>之后，可将导出的 tar 文件传输到其他机器上，然后再通过导人命令导入到系统中，实现容器的迁移</p><h3 id="导入容器container快照到本地image库"><a class="anchor" href="#导入容器container快照到本地image库">#</a> 导入容器 (container) 快照到本地 image 库</h3><p>导入容器镜像方式:</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ <span class="token function">cat</span> export_ubuntu_container.tar <span class="token operator">|</span> docker <span class="token function">import</span> - in_container/ubuntu:v1.0</pre></td></tr><tr><td data-num="2"></td><td><pre>	  sha256:31bfe55fe553047cd3cf513dc7d19ae15e746166685c90d8ac3afac9dcea755b</pre></td></tr><tr><td data-num="3"></td><td><pre>	$ docker images</pre></td></tr><tr><td data-num="4"></td><td><pre>	  REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE</pre></td></tr><tr><td data-num="5"></td><td><pre>	  in_container/ubuntu     v1.0                31bfe55fe553        <span class="token number">3</span> seconds ago       <span class="token number">64</span>.2MB</pre></td></tr><tr><td data-num="6"></td><td><pre>	  ubuntu_test             <span class="token number">18.04</span>               a4850ad0370a        About an hour ago   <span class="token number">64</span>.2MB</pre></td></tr></table></figure><p>既可以使用 <code>docker load -i ubuntu_18.04.tar</code> 命令来导入 <code>镜像</code> 存储文件到本地镜像库，也可以使用 <code>cat export_ubuntu_container.tar | docker import - in_container/ubuntu:v1.0</code> 命令来导入一个 <code>容器快照</code> 到本地镜像库。<br>这两者的区别在于： 容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积更大。<br>此外，从容器快照文件导人时可以重新指定标签等元数据信息</p><p><strong><code>NOTE:</code> </strong>不能使用 <code>$ docker load -i ubuntu_18.04.tar</code> 来导入容器快照，否则会出错</p><h3 id="清理所有终止状态的容器"><a class="anchor" href="#清理所有终止状态的容器">#</a> 清理所有终止状态的容器</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker container prune</pre></td></tr></table></figure><h3 id="删除容器"><a class="anchor" href="#删除容器">#</a> 删除容器</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker <span class="token function">rm</span> 1e560fca3906</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ docker <span class="token function">rm</span> <span class="token operator">&lt;</span>Container Name<span class="token operator">></span>  // 可以通过docker <span class="token function">ps</span> <span class="token operator">|</span> <span class="token function">grep</span> 1e560fca3906 最后一列查看Container名字</pre></td></tr><tr><td data-num="3"></td><td><pre>	－f, --force<span class="token operator">=</span>false ： 是否强行终止并删除一个运行中的容器 ；</pre></td></tr><tr><td data-num="4"></td><td><pre>	－l, --link<span class="token operator">=</span>false ：删除容器的连接 ，但保留容器；</pre></td></tr><tr><td data-num="5"></td><td><pre>	－v, --volumes<span class="token operator">=</span>false ：删除容器挂载的数据卷</pre></td></tr></table></figure><h3 id="端口映射"><a class="anchor" href="#端口映射">#</a> 端口映射</h3><p><strong>1. 指定 ip、指定宿主机 port、指定容器 port.</strong><br>将容器的 9900 端口映射到指定地址 127.0.0.1 的 9900 端口上</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>docker run --name python-media_data -p <span class="token number">127.0</span>.0.1:9900:9900 media_data:0.1</pre></td></tr></table></figure><p><strong>2. 指定 ip、未指定宿主机 port（随机）、指定容器 port.</strong><br>将容器的 4000 端口映射到 127.0.0.1 的任意端口上</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>docker run -it -d -p <span class="token number">127.0</span>.0.1::4000 docker.io/centos:latest /bin/bash</pre></td></tr></table></figure><p><strong>3. 未指定 ip、指定宿主机 port、指定容器 port.</strong><br>将容器的 80 端口映射到宿主机的 8000 端口上</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>docker run -itd -p <span class="token number">8000</span>:80 docker.io/centos:latest /bin/bash</pre></td></tr></table></figure><h3 id="查看容器内的进程端口映射统计信息容器详情-容器文件变更-更新容器配置等"><a class="anchor" href="#查看容器内的进程端口映射统计信息容器详情-容器文件变更-更新容器配置等">#</a> 查看容器内的进程，端口映射，统计信息，容器详情，容器文件变更， 更新容器配置等</h3><ul><li>查看窑器内进程</li></ul><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker <span class="token function">top</span> a1cb4017f313</pre></td></tr></table></figure><ul><li>查看容器端口与宿主主机端口映射情况</li></ul><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker port a1cb4017f313 // 或者 $ docker container port a1cb4017f313</pre></td></tr></table></figure><ul><li>查看统计信息，会显示 CPU 、内存、存储、网络等使用情况的统计信息</li></ul><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker stats a1cb4017f313</pre></td></tr><tr><td data-num="2"></td><td><pre>	CONTAINER ID        NAME                CPU %               MEM USAGE / LIMIT    MEM %               NET I/O             BLOCK I/O           PIDS</pre></td></tr><tr><td data-num="3"></td><td><pre>	a1cb4017f313        strange_mendeleev   <span class="token number">0.00</span>%               <span class="token number">6</span>.23MiB / <span class="token number">7</span>.612GiB   <span class="token number">0.08</span>%               22kB / 0B           0B / <span class="token number">4</span>.1kB          <span class="token number">1</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	 + －a, -all ：输出所有容器统计信息，默认仅在运行中；</pre></td></tr><tr><td data-num="5"></td><td><pre>	 + －format string ：格式化输出信息；</pre></td></tr><tr><td data-num="6"></td><td><pre>	 + －no-stream ：不持续输出，默认会自动更新持续实时结果；</pre></td></tr><tr><td data-num="7"></td><td><pre>	 + －no-trunc ：不截断输出信息。</pre></td></tr></table></figure><ul><li>查看容器文件变更</li></ul><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker <span class="token punctuation">[</span>container<span class="token punctuation">]</span> <span class="token function">diff</span> a1cb4017f313</pre></td></tr></table></figure><ul><li>查看容器信息</li></ul><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker inspect a1cb4017f313 // 或者 $ docker container inspect a1cb4017f313</pre></td></tr></table></figure><ul><li>更新容器配置</li></ul><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker update --help查看支持的选项</pre></td></tr><tr><td data-num="2"></td><td><pre>	限制总配额为 <span class="token number">1</span> 秒，容器 <span class="token builtin class-name">test</span> 所占用时间为 <span class="token number">10</span>% ，代码如下所示：</pre></td></tr><tr><td data-num="3"></td><td><pre>	$ docker update --cpu-quota <span class="token number">1000000</span> <span class="token builtin class-name">test</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token builtin class-name">test</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	$ docker update --cpu-period <span class="token number">100000</span> <span class="token builtin class-name">test</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token builtin class-name">test</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	支持的选项包括：</pre></td></tr><tr><td data-num="8"></td><td><pre>	 + －blkio-weight uintl6 ：更新块 IO 限制， <span class="token number">10</span>～ <span class="token number">1000</span> ，默认值为 <span class="token number">0</span> ，代表着无限制；</pre></td></tr><tr><td data-num="9"></td><td><pre>	 + －cpu-period int ：限制 CPU 调度器 CFS <span class="token punctuation">(</span>Completely Fair Scheduler）使用时间，单位为微秒，最小 <span class="token number">1000</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	 + －cpu-quota int ：限制 CPU 调度器 CFS 配额，单位为微秒，最小 <span class="token number">1000</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	 + －cpu-rt-period int ：限制 CPU 调度器的实时周期，单位为微秒 ；</pre></td></tr><tr><td data-num="12"></td><td><pre>	 + －cpu-rt-runtime int ：限制 CPU 调度器的实时运行时，单位为微秒；</pre></td></tr><tr><td data-num="13"></td><td><pre>	 + －c, -cpu-shares int ： 限制 CPU 使用份额；</pre></td></tr><tr><td data-num="14"></td><td><pre>	 + －cpus decimal ：限制 CPU 个数；</pre></td></tr><tr><td data-num="15"></td><td><pre>	 + －cpuset-cpus string ：允许使用的 CPU 核，如 <span class="token number">0</span>-3, <span class="token number">0,1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	 + －cpuset-mems string ：允许使用的内存块，如 <span class="token number">0</span>-3, <span class="token number">0,1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>	 + －kernel-memory bytes ：限制使用的内核内存；</pre></td></tr><tr><td data-num="18"></td><td><pre>	 + －m, -memory bytes ： 限制使用的内存；</pre></td></tr><tr><td data-num="19"></td><td><pre>	 + －memory-reservation bytes ：内存软限制；</pre></td></tr><tr><td data-num="20"></td><td><pre>	 + －memory-swap bytes ：内存加上缓存区的限制， － <span class="token number">1</span> 表示为对缓冲区无限制；</pre></td></tr><tr><td data-num="21"></td><td><pre>	 + －restart stri口g ： 容器退出后的重启策略</pre></td></tr><tr><td data-num="22"></td><td><pre>	$ docker update --cpus <span class="token number">0</span> a1cb4017f313</pre></td></tr><tr><td data-num="23"></td><td><pre>	$ docker update -c <span class="token number">4</span> a1cb4017f313</pre></td></tr><tr><td data-num="24"></td><td><pre>	$ docker inspect a1cb4017f313	// 查看容器信息 <span class="token string">"CpuShares"</span><span class="token builtin class-name">:</span> <span class="token number">4</span></pre></td></tr></table></figure><h3 id="容器与主机间复制文件"><a class="anchor" href="#容器与主机间复制文件">#</a> 容器与主机间复制文件</h3><blockquote><p>主机上的 t1.txt 复制到容器 ID 为 a1cb4017f313 的 /home 目录<br>$ docker cp t1.txt a1cb4017f313:/home</p><ul><li>－a, -archive ：打包模式，复制文件会带有原始的 uid/gid 信息；</li><li>－L, -follow-link ：跟随软连接。当原路径为软连接时＼默认只复制链接信息，使用该选项会复制链接的目标内容 。</li></ul></blockquote><h3 id="运行一个-web-应用"><a class="anchor" href="#运行一个-web-应用">#</a> 运行一个 web 应用</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>runoob@runoob:~<span class="token comment"># docker pull training/webapp  # 载入镜像</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	runoob@runoob:~<span class="token comment"># docker run -d -P training/webapp python app.py</span></pre></td></tr></table></figure><ul><li>-d: 让容器在后台运行。</li><li>-P: 将容器内部使用的网络端口映射到我们使用的主机上。</li></ul><ul><li>runoob@runoob:~# docker ps</li><li>CONTAINER ID IMAGE COMMAND ... PORTS</li><li>d3d5e39ed9d3 training/webapp &quot;python <span class="exturl" data-url="aHR0cDovL2FwcC5weQ==">app.py</span>&quot; ... 0.0.0.0:32769-&gt;5000/tcp</li></ul><ul><li>Docker 开放了 5000 端口（默认 Python Flask 端口）映射到主机端口 32769 上。</li><li>这时我们可以通过浏览器访问 WEB 应用 192.168.239.130:32769<br>可以通过 -p 参数来设置不一样的端口：</li></ul><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>runoob@runoob:~$ docker run -d -p <span class="token number">5000</span>:5000 training/webapp python app.py</pre></td></tr></table></figure><h3 id="查看-web-应用程序日志"><a class="anchor" href="#查看-web-应用程序日志">#</a> 查看 WEB 应用程序日志</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>runoob@runoob:~$ docker logs -f bf08b7f2cd89		// -f: 让 docker logs 像使用 <span class="token function">tail</span> -f 一样来输出容器内部的标准输出。</pre></td></tr></table></figure><h3 id="查看web应用程序容器的进程"><a class="anchor" href="#查看web应用程序容器的进程">#</a> 查看 WEB 应用程序容器的进程</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>runoob@runoob:~$ docker <span class="token function">top</span> wizardly_chandrasekhar</pre></td></tr></table></figure><h3 id="查看docker-容器的配置和状态信息"><a class="anchor" href="#查看docker-容器的配置和状态信息">#</a> 查看 Docker 容器的配置和状态信息</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>runoob@runoob:~$ docker inspect wizardly_chandrasekhar	// 它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息。</pre></td></tr></table></figure><h3 id="停止-web-应用容器"><a class="anchor" href="#停止-web-应用容器">#</a> 停止 WEB 应用容器</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>runoob@runoob:~$ docker stop wizardly_chandrasekhar</pre></td></tr></table></figure><h3 id="重启web应用容器"><a class="anchor" href="#重启web应用容器">#</a> 重启 WEB 应用容器</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>runoob@runoob:~$ docker start wizardly_chandrasekhar</pre></td></tr></table></figure><h3 id="移除web应用容器"><a class="anchor" href="#移除web应用容器">#</a> 移除 WEB 应用容器</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>runoob@runoob:~$ docker <span class="token function">rm</span> wizardly_chandrasekhar 		// 删除不需要的容器, 容器必须是停止状态，否则会报错</pre></td></tr></table></figure><p>※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※</p><h2 id="镜像使用"><a class="anchor" href="#镜像使用">#</a> 镜像使用</h2><h3 id="查找镜像"><a class="anchor" href="#查找镜像">#</a> 查找镜像</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>Docker Hub 网址为： https://hub.docker.com/</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ docker search httpd			// 使用 docker search 命令来搜索镜像</pre></td></tr></table></figure><ul><li>搜索官方提供的带 nginx 关键字的镜像</li></ul><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker search --filter<span class="token operator">=</span>is-official<span class="token operator">=</span>true nginx</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME                DESCRIPTION                STARS               OFFICIAL            AUTOMATED</pre></td></tr><tr><td data-num="3"></td><td><pre>	nginx               Official build of Nginx.   <span class="token number">13037</span>               <span class="token punctuation">[</span>OK<span class="token punctuation">]</span></pre></td></tr></table></figure><ul><li>NAME: 镜像仓库源的名称</li><li>DESCRIPTION: 镜像的描述</li><li>STARS: 类似 Github 里面的 star，表示点赞、喜欢的意思。</li><li>OFFICIAL: 是否 docker 官方发布</li><li>AUTOMATED: 自动构建。</li></ul><ul><li>搜索所有收藏数超过 4 的关键词包括 tensorow 的镜像</li></ul><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker search --filter<span class="token operator">=</span>stars<span class="token operator">=</span><span class="token number">200</span> tensorflow</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME                          DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</pre></td></tr><tr><td data-num="3"></td><td><pre>	tensorflow/tensorflow         Official Docker images <span class="token keyword">for</span> the machine learn…   <span class="token number">1662</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	jupyter/tensorflow-notebook   Jupyter Notebook Scientific Python Stack w/ …   <span class="token number">209</span></pre></td></tr></table></figure><ul><li>搜索所有收藏数超过 4 的关键词包括 tensorow 的镜像的前 3 个镜像</li></ul><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker search --filter<span class="token operator">=</span>stars<span class="token operator">=</span><span class="token number">4</span> --limit<span class="token operator">=</span><span class="token number">3</span> tensorflow</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME                          DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</pre></td></tr><tr><td data-num="3"></td><td><pre>	tensorflow/tensorflow         Official Docker images <span class="token keyword">for</span> the machine learn…   <span class="token number">1662</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	jupyter/tensorflow-notebook   Jupyter Notebook Scientific Python Stack w/ …   <span class="token number">209</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	tensorflow/serving            Official images <span class="token keyword">for</span> TensorFlow Serving <span class="token punctuation">(</span>http…   <span class="token number">83</span></pre></td></tr></table></figure><h3 id="列出镜像列表"><a class="anchor" href="#列出镜像列表">#</a> 列出镜像列表</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>runoob@runoob:~$ docker images		// 列出本地主机上的镜像</pre></td></tr></table></figure><ul><li>REPOSITORY：表示镜像的仓库源</li><li>TAG：镜像的标签</li><li>IMAGE ID：镜像 ID, 如果两个镜像的 ID 相同， 说明它们实际上指向了同一个镜像， 只是具有不同标签名称而已，其中镜像的 ID 信息十分重要， 它唯一标识了镜像。在使用镜像 ID 的时候， 一般可以使用该 ID 的前若干个字符组成的可区分串来替代完整的 ID</li><li>CREATED：镜像创建时间</li><li>SIZE：镜像大小，镜像大小信息只是表示了该镜像的逻辑体积大小， 实际上由于相同的镜像层本地只会存储一份， 物理上占用的存储空间会小于各镜像逻辑体积之和<br>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本</li></ul><ul><li>REPOSITORY TAG IMAGE ID CREATED SIZE</li><li>ubuntu 14.04 90d5884b1ee0 5 days ago 188 MB</li><li>php 5.6 f40e9e0f10c8 9 days ago 444.8 MB</li><li>ubuntu 15.10 4e3b13c8a266 4 weeks ago 136.3 MB</li><li>nginx latest 6f8d099c3adc 12 days ago 182.7 MB</li></ul><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>runoob@runoob:~$ docker run -t -i ubuntu:15.10 /bin/bash 	// 使用版本为15.10的ubuntu系统镜像来运行容器</pre></td></tr></table></figure><p>如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。</p><ul><li>-q, --quiet 式 rueI false: 仅输出 ID 信息， 默认为否</li></ul><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker images -q<span class="token operator">=</span>true</pre></td></tr><tr><td data-num="2"></td><td><pre>273c7fcf9499</pre></td></tr><tr><td data-num="3"></td><td><pre>0d40868643c6</pre></td></tr></table></figure><h3 id="获取镜像-如果不显式指定tag-则默认会选择latest标签这会下载仓库中最新版本的镜像"><a class="anchor" href="#获取镜像-如果不显式指定tag-则默认会选择latest标签这会下载仓库中最新版本的镜像">#</a> 获取镜像，如果不显式指定 TAG, 则默认会选择 latest 标签，这会下载仓库中最新版本的镜像</h3><blockquote><p>严格地讲，镜像的仓库名称中还应该添加仓库地址（即 registry, 注册服务器）作为前缀 ，只是默认使用的是官方 DockerHub 服务 ，该前缀可以忽略。<br>例如，$ docker pull ubuntu：18.04 命令相当于 $ docker pull <span class="exturl" data-url="aHR0cDovL3JlZ2lzdHJ5Lmh1Yi5kb2NrZXIuY29tL3VidW50dSVFRiVCQyU5QTE4LjA0JUU1JTkxJUJEJUU0JUJCJUE0JUVGJUJDJThDJUU1JThEJUIzJUU0JUJCJThFJUU5JUJCJTk4JUU4JUFFJUE0JUU3JTlBJTg0JUU2JUIzJUE4JUU1JTg2JThDJUU2JTlDJThEJUU1JThBJUExJUU1JTk5JUE4RG9ja2VySHVi">registry.hub.docker.com/ubuntu：18.04 命令，即从默认的注册服务器 DockerHub</span> Registy 中的 ubuntu 仓库来下载标记为 18.04 的镜像。<br>如果从非官方的仓库下载，则需要在仓库名称前指定完整的仓库地址。例如从网易蜂巢的镜像源来下载 ubuntu:18.04 镜像，可以使用如下命令，<span class="exturl" data-url="aHR0cDovL3huLS1odWIteTI4ZGxpcjVsOTdnNnc1Ym9oazE3MGFubGlwcDFlazdwLmMuMTYzLmNvbS9wdWJsaWMvdWJ1bnR1OjE4LjA0Og==">此时下载的镜像名称为 hub.c.163.com/public/ubuntu:18.04:</span> $ docker pull <span class="exturl" data-url="aHR0cDovL2h1Yi5jLjE2My5jb20vcHVibGljL3VidW50dToxOC4wNA==">hub.c.163.com/public/ubuntu:18.04</span><br>可以在 Docker 服务启动配置中增加 --registry-mirror=proxy_URL 来指定镜像代理服务地址（如 https://registry.docker-en.com)</p></blockquote><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker pull ubuntu:18.04 // 与下方命令一致,默认使用的是官方DockerHub服务 ，该前缀可以忽略.</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ docker pull registry.hub.docker.com/ubuntu:18.04</pre></td></tr><tr><td data-num="3"></td><td><pre>	$ docker pull mysql:5.7</pre></td></tr></table></figure><blockquote><p>一般来说， 镜像的 latest 标签意味着该镜像的内容会跟踪最新版本的变更而变化，内容是不稳定的。 因此，从稳定性上考虑，不要在生产环境中忽略镜像的标签信息或使用默认的 latest 标记的镜像<br>如果从非官方 的仓库 下载，则 需要在仓库 名称前指定完整的仓库地址</p></blockquote><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker pull hub.c.163.com/public/ubuntu:18.04</pre></td></tr></table></figure><h3 id="改变标签"><a class="anchor" href="#改变标签">#</a> 改变标签</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker tag mysql:5.7 my_mysql:5.7.0</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ docker images</pre></td></tr><tr><td data-num="3"></td><td><pre>	REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE</pre></td></tr><tr><td data-num="4"></td><td><pre>	my_mysql                <span class="token number">5.7</span>.0               273c7fcf9499        <span class="token number">4</span> days ago          455MB</pre></td></tr><tr><td data-num="5"></td><td><pre>	mysql                   <span class="token number">5.7</span>                 273c7fcf9499        <span class="token number">4</span> days ago          455MB</pre></td></tr></table></figure><blockquote><p>它们实际上指向了同一个镜像文件，只是别名不同而巳。docker tag 命令添加的标签实际上起到了类似链接的作用</p></blockquote><h3 id="查看imgage制作信息"><a class="anchor" href="#查看imgage制作信息">#</a> 查看 imgage 制作信息</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker inspect mysql:5.7</pre></td></tr><tr><td data-num="2"></td><td><pre>	只要其中一项内容时， 可以使用 -f 来指定</pre></td></tr><tr><td data-num="3"></td><td><pre>	$ docker inspect -f <span class="token operator">&lt;</span><span class="token operator">!</span>--￼0--<span class="token operator">></span> mysql:5.7</pre></td></tr><tr><td data-num="4"></td><td><pre>	$  docker inspect -f <span class="token operator">&lt;</span><span class="token operator">!</span>--￼1--<span class="token operator">></span> mysql:5.7</pre></td></tr></table></figure><h3 id="查看image历史"><a class="anchor" href="#查看image历史">#</a> 查看 image 历史</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker <span class="token function">history</span> mysql:5.7</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ docker <span class="token function">history</span> mysql:5.7 --no-trunc  // get the full output</pre></td></tr></table></figure><h3 id="删除镜像"><a class="anchor" href="#删除镜像">#</a> 删除镜像</h3><blockquote><p>-f, -force: 强制删除镜像， 即使有容器依赖它<br>- no-prune: 不要清理未带标签的父镜像</p></blockquote><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker rmi hello-world</pre></td></tr></table></figure><blockquote><p>docker rmi 命令只是删除了该镜像多个标签中的指定标签而巳， 并不影响镜像文件</p></blockquote><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker rmi my_mysql:5.7.0</pre></td></tr></table></figure><blockquote><p>Untagged: my_mysql:5.7.0<br>docker rmi 命令来删除只有一个标签的镜像， 可以看出会删除这个镜像文件的所有文件层<br>当使用 docker rmi 命令， 并且后面跟上镜像的 ID (也可以是能进行区分的部分 ID 串前缀）时， 会先尝试删除所有指向该镜像的标签， 然后删除该镜像文件本身<br>当有该镜像创建的容器存在时， 镜像文件默认是无法被删除的，如果要想强行删除镜像， 可以使用 - f 参数</p></blockquote><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker rmi -f ubuntu:18.04</pre></td></tr></table></figure><blockquote><p>通常并不推荐使用 - f 参数来强制删除一个存在容器依赖的镜像。 正确的做法是，先删除依赖该镜像的所有容器， 再来删除镜像<br>首先删除容器 a21c0840213e:</p></blockquote><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker <span class="token function">rm</span> a2lc0840213e</pre></td></tr></table></figure><blockquote><p>然后使用 ID 来删除镜像， 此时会正常打印出删除的各层信息：</p></blockquote><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker rmi Bflbd2lbd25c</pre></td></tr></table></figure><h3 id="清理镜像"><a class="anchor" href="#清理镜像">#</a> 清理镜像</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker image prune</pre></td></tr></table></figure><blockquote><p>-a, -all: 删除所有无用镜像， 不光是临时镜像；<br>-filter filter: 只清理符合给定过滤器的镜像；<br>-f, -force: 强制删除镜像， 而不进行提示确认</p></blockquote><h3 id="创建镜像"><a class="anchor" href="#创建镜像">#</a> 创建镜像</h3><ul><li>基于已有容器创建</li></ul><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker run -itd --name ubuntu18.04_v3.0 ubuntu:18.04 /bin/bash</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ docker <span class="token builtin class-name">exec</span> -it ubuntu18.04_v3.0 /bin/bash</pre></td></tr><tr><td data-num="3"></td><td><pre>	root@e2d52bc5c287:/<span class="token comment"># cd /home</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	root@e2d52bc5c287:/home<span class="token comment"># mkdir test		// 把初始的 image 创建一个文件夹再导出成新的 image</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	root@e2d52bc5c287:/home<span class="token comment"># exit</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	root@alpha:~<span class="token comment"># docker commit -m "add test file" -a "Docker Newbee" e2d52bc5c287 test:0.1</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>	$ docker images</pre></td></tr><tr><td data-num="9"></td><td><pre>	REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE</pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token builtin class-name">test</span>                    <span class="token number">0.1</span>                 a4850ad0370a        <span class="token number">15</span> seconds ago      <span class="token number">64</span>.2MB</pre></td></tr><tr><td data-num="11"></td><td><pre>	ubuntu                  <span class="token number">18.04</span>               4e5021d210f6        <span class="token number">4</span> weeks ago         <span class="token number">64</span>.2MB</pre></td></tr></table></figure><ul><li>-a, --author=&quot;&quot;: 作者信息</li><li>-c, - -change=(] : 提交的时候执行 Dockerfle 指令， 包括 CMD | ENTRYPOINT | ENV | EXPOSE |LABEL | ONBUILD | USER | VOLUME | WORKIR 等</li><li>-m, - -message=11 11: 提交消息</li><li>-p, --pause 式 rue: 提交时暂停容器运行</li></ul><ul><li><p>基于本地模板导入</p></li><li><p>基于 Docke 「file 创建</p></li></ul><h3 id="导出和载入镜像"><a class="anchor" href="#导出和载入镜像">#</a> 导出和载入镜像</h3><ul><li>导出镜像</li></ul><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker save -o ubuntu_18.04.tar ubuntu:18.04</pre></td></tr></table></figure><ul><li>载入镜像</li></ul><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker load -i ubuntu_18.04.tar 或者 docker load <span class="token operator">&lt;</span> ubuntu_18.04.tar</pre></td></tr></table></figure><h2 id="重启docker服务"><a class="anchor" href="#重启docker服务">#</a> 重启 docker 服务</h2><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ <span class="token function">service</span> docker restart</pre></td></tr></table></figure><p>运行以下命令会出错，anyway 运行以上命令就可重启</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ systemctl restart docker.service</pre></td></tr></table></figure><h2 id="docker存储路径"><a class="anchor" href="#docker存储路径">#</a> docker 存储路径</h2><p>查看 docker 存储路径</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker info <span class="token operator">|</span><span class="token function">grep</span> <span class="token string">'Docker Root Dir'</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	 Docker Root Dir: /var/lib/docker</pre></td></tr></table></figure><p>修改 docker 存储路径</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>$ vim /etc/docker/daemon.json</pre></td></tr><tr><td data-num="2"></td><td><pre>	&#123;</pre></td></tr><tr><td data-num="3"></td><td><pre>	    "graph": "/home/server/docker"</pre></td></tr><tr><td data-num="4"></td><td><pre>	&#125;</pre></td></tr><tr><td data-num="5"></td><td><pre>	$ systemctl daemon-reload</pre></td></tr><tr><td data-num="6"></td><td><pre>	$ systemctl restart docker</pre></td></tr></table></figure><div class="tags"><a href="/tags/docker/" rel="tag"><i class="ic i-tag"></i> docker</a></div></div><footer><div class="meta"></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Kung-Fu-Master 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Kung-Fu-Master 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="Kung-Fu-Master 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Kung-Fu-Master <i class="ic i-at"><em>@</em></i>Hexo</li><li class="link"><strong>本文链接：</strong> <a href="https://kung-fu-master.github.io/2021/03/13/technologies/docker/docker_01_installation/" title="docker 01 installation and control commands">https://kung-fu-master.github.io/2021/03/13/technologies/docker/docker_01_installation/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2021/03/13/technologies/docker/dockerfile/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclip4jbpj20zk0m87cv.jpg" title="Dockerfile introduction"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> docker</span><h3>Dockerfile introduction</h3></a></div><div class="item right"><a href="/2021/03/13/technologies/docker/regenerateTestingCerts/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giciusoyjnj219g0u0x56.jpg" title="regenerateTestingCerts.sh"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> docker</span><h3>regenerateTestingCerts.sh</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-引擎"><span class="toc-number">1.</span> <span class="toc-text"># Docker 引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ubuntu1804-docker环境安装"><span class="toc-number">2.</span> <span class="toc-text"># Ubuntu18.04 docker 环境安装：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">3.</span> <span class="toc-text"># 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么用docker"><span class="toc-number">4.</span> <span class="toc-text"># 为什么用 Docker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-ce与-docker-ee区别"><span class="toc-number">5.</span> <span class="toc-text"># docker ce 与 docker ee 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-ucp-介绍"><span class="toc-number">6.</span> <span class="toc-text"># docker UCP 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#安装curl"><span class="toc-number">7.</span> <span class="toc-text"># 安装 curl:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#安装docker"><span class="toc-number">8.</span> <span class="toc-text"># 安装 docker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ubuntu安装docker"><span class="toc-number">8.1.</span> <span class="toc-text"># Ubuntu 安装 docker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#centos安装docker"><span class="toc-number">8.2.</span> <span class="toc-text"># Centos 安装 docker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#改变docker运行时存储目录和存储驱动"><span class="toc-number">8.3.</span> <span class="toc-text"># 改变 docker 运行时存储目录和存储驱动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置docker的proxy"><span class="toc-number">8.4.</span> <span class="toc-text"># 配置 docker 的 proxy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#keep-containers-alive-during-daemon-downtime"><span class="toc-number">8.5.</span> <span class="toc-text"># Keep containers alive during daemon downtime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#additional"><span class="toc-number">8.6.</span> <span class="toc-text"># Additional</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#安装docker-compose"><span class="toc-number">9.</span> <span class="toc-text"># 安装 docker compose</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#容器的使用"><span class="toc-number">10.</span> <span class="toc-text"># 容器的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#查看所有的容器"><span class="toc-number">10.1.</span> <span class="toc-text"># 查看所有的容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查询最后一次创建的容器"><span class="toc-number">10.2.</span> <span class="toc-text"># 查询最后一次创建的容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#启动容器"><span class="toc-number">10.3.</span> <span class="toc-text"># 启动容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#启动并进入容器"><span class="toc-number">10.4.</span> <span class="toc-text"># 启动并进入容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#停止一个容器"><span class="toc-number">10.5.</span> <span class="toc-text"># 停止一个容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#启动已停止运行的容器"><span class="toc-number">10.6.</span> <span class="toc-text"># 启动已停止运行的容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#后台运行"><span class="toc-number">10.7.</span> <span class="toc-text"># 后台运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进入容器"><span class="toc-number">10.8.</span> <span class="toc-text"># 进入容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#退出终端"><span class="toc-number">10.9.</span> <span class="toc-text"># 退出终端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#导出容器"><span class="toc-number">10.10.</span> <span class="toc-text"># 导出容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#导入容器container快照到本地image库"><span class="toc-number">10.11.</span> <span class="toc-text"># 导入容器 (container) 快照到本地 image 库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#清理所有终止状态的容器"><span class="toc-number">10.12.</span> <span class="toc-text"># 清理所有终止状态的容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除容器"><span class="toc-number">10.13.</span> <span class="toc-text"># 删除容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#端口映射"><span class="toc-number">10.14.</span> <span class="toc-text"># 端口映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看容器内的进程端口映射统计信息容器详情-容器文件变更-更新容器配置等"><span class="toc-number">10.15.</span> <span class="toc-text"># 查看容器内的进程，端口映射，统计信息，容器详情，容器文件变更， 更新容器配置等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#容器与主机间复制文件"><span class="toc-number">10.16.</span> <span class="toc-text"># 容器与主机间复制文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运行一个-web-应用"><span class="toc-number">10.17.</span> <span class="toc-text"># 运行一个 web 应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看-web-应用程序日志"><span class="toc-number">10.18.</span> <span class="toc-text"># 查看 WEB 应用程序日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看web应用程序容器的进程"><span class="toc-number">10.19.</span> <span class="toc-text"># 查看 WEB 应用程序容器的进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看docker-容器的配置和状态信息"><span class="toc-number">10.20.</span> <span class="toc-text"># 查看 Docker 容器的配置和状态信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#停止-web-应用容器"><span class="toc-number">10.21.</span> <span class="toc-text"># 停止 WEB 应用容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重启web应用容器"><span class="toc-number">10.22.</span> <span class="toc-text"># 重启 WEB 应用容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#移除web应用容器"><span class="toc-number">10.23.</span> <span class="toc-text"># 移除 WEB 应用容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#镜像使用"><span class="toc-number">11.</span> <span class="toc-text"># 镜像使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#查找镜像"><span class="toc-number">11.1.</span> <span class="toc-text"># 查找镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#列出镜像列表"><span class="toc-number">11.2.</span> <span class="toc-text"># 列出镜像列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取镜像-如果不显式指定tag-则默认会选择latest标签这会下载仓库中最新版本的镜像"><span class="toc-number">11.3.</span> <span class="toc-text"># 获取镜像，如果不显式指定 TAG, 则默认会选择 latest 标签，这会下载仓库中最新版本的镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#改变标签"><span class="toc-number">11.4.</span> <span class="toc-text"># 改变标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看imgage制作信息"><span class="toc-number">11.5.</span> <span class="toc-text"># 查看 imgage 制作信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看image历史"><span class="toc-number">11.6.</span> <span class="toc-text"># 查看 image 历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除镜像"><span class="toc-number">11.7.</span> <span class="toc-text"># 删除镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#清理镜像"><span class="toc-number">11.8.</span> <span class="toc-text"># 清理镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建镜像"><span class="toc-number">11.9.</span> <span class="toc-text"># 创建镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#导出和载入镜像"><span class="toc-number">11.10.</span> <span class="toc-text"># 导出和载入镜像</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重启docker服务"><span class="toc-number">12.</span> <span class="toc-text"># 重启 docker 服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker存储路径"><span class="toc-number">13.</span> <span class="toc-text"># docker 存储路径</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2021/03/13/technologies/docker/DCT/" rel="bookmark" title="Docker Content Trust(DCT) and Notary">Docker Content Trust(DCT) and Notary</a></li><li><a href="/2021/03/13/technologies/docker/docker_02_private_hub/" rel="bookmark" title="docker 02 private hub & journal">docker 02 private hub & journal</a></li><li><a href="/2021/03/13/technologies/docker/regenerateTestingCerts/" rel="bookmark" title="regenerateTestingCerts.sh">regenerateTestingCerts.sh</a></li><li class="active"><a href="/2021/03/13/technologies/docker/docker_01_installation/" rel="bookmark" title="docker 01 installation and control commands">docker 01 installation and control commands</a></li><li><a href="/2021/03/13/technologies/docker/dockerfile/" rel="bookmark" title="Dockerfile introduction">Dockerfile introduction</a></li><li><a href="/2021/03/13/technologies/docker/%E5%AE%89%E8%A3%85docker-compose/" rel="bookmark" title="安装 docker compose">安装 docker compose</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Kung-Fu-Master" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Kung-Fu-Master</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">292</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">40</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">12</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lvdXJuYW1l" title="https:&#x2F;&#x2F;github.com&#x2F;yourname"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yourname"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPXlvdXJpZA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;yourid"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2021/03/13/technologies/docker/dockerfile/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2021/03/13/technologies/docker/regenerateTestingCerts/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/storage/" title="分类于 storage">storage</a> <i class="ic i-angle-right"></i> <a href="/categories/storage/ceph/" title="分类于 ceph">ceph</a></div><span><a href="/2021/03/13/storage/ceph/ceph_01_conception/" title="Ceph 01 Storage Conception">Ceph 01 Storage Conception</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/linux/" title="分类于 linux">linux</a></div><span><a href="/2021/03/13/linux/gdb/" title="gdb">gdb</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/storage/" title="分类于 storage">storage</a> <i class="ic i-angle-right"></i> <a href="/categories/storage/minio/" title="分类于 minio">minio</a></div><span><a href="/2021/03/13/storage/minio/minIO_01_conception/" title="MinIO 01 conception">MinIO 01 conception</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/reference/" title="分类于 reference">reference</a> <i class="ic i-angle-right"></i> <a href="/categories/reference/k8s/" title="分类于 k8s">k8s</a></div><span><a href="/2021/03/13/reference/k8s/22.%E6%92%AC%E5%8A%A8%E7%A6%BB%E7%BA%BF%E4%B8%9A%E5%8A%A1%EF%BC%9AJob%E4%B8%8ECronJob/" title="22 | 撬动离线业务：Job与CronJob">22 | 撬动离线业务：Job与CronJob</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/linux/" title="分类于 linux">linux</a></div><span><a href="/2021/03/13/linux/time/" title="time">time</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/technologies/" title="分类于 technologies">technologies</a> <i class="ic i-angle-right"></i> <a href="/categories/technologies/%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="分类于 虚拟机">虚拟机</a></div><span><a href="/2021/03/13/technologies/virtual_machine/vagrant/" title="vagrant">vagrant</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/microService/" title="分类于 microService">microService</a> <i class="ic i-angle-right"></i> <a href="/categories/microService/kubernetes/" title="分类于 kubernetes">kubernetes</a></div><span><a href="/2021/03/13/micro_service/kubernetes/k8s_resources%E5%92%8C%E9%A9%B1%E9%80%90%E7%AD%96%E7%95%A5/" title="k8s resources和驱逐策略">k8s resources和驱逐策略</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/blogs/" title="分类于 blogs">blogs</a> <i class="ic i-angle-right"></i> <a href="/categories/blogs/blog%E6%90%AD%E5%BB%BA/" title="分类于 blog搭建">blog搭建</a></div><span><a href="/2021/03/13/blogs/blog%E6%90%AD%E5%BB%BA/Hexo_03_%E5%86%99%E5%8D%9A%E5%AE%A2%E8%AF%AD%E6%B3%95/" title="Hexo 03 写博客语法">Hexo 03 写博客语法</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/language/" title="分类于 language">language</a> <i class="ic i-angle-right"></i> <a href="/categories/language/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" title="分类于 排序算法">排序算法</a></div><span><a href="/2021/03/13/language/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/" title="希尔排序">希尔排序</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/linux/" title="分类于 linux">linux</a></div><span><a href="/2021/03/13/linux/Linux_kernel_%E6%9B%B4%E6%96%B0/" title="Linux kernel 更新">Linux kernel 更新</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Kung-Fu-Master @ Kung Fu Master</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">1.1m 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">16:30</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2021/03/13/technologies/docker/docker_01_installation/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->