---
title: 09 异常
tags:
categories:
- language
- cpp
---


## **异常**

```cpp
	try{
	    // 可能抛出异常的语句
	}catch(exceptionType variable){
	    // 处理异常的语句
	}
```
 * **`exceptionType`** 是异常类型，它指明了当前的 catch 可以处理什么类型的异常.
 * **`variable`** 是一个变量，用来接收异常信息.
如果不希望 catch 处理异常数据，也可以将 variable 省略掉，也即写作：


```cpp
	try{
	    // 可能抛出异常的语句
	}catch(exceptionType){
	    // 处理异常的语句
	}
```

检测到异常后程序的执行流会发生跳转，从异常点跳转到 catch 所在的位置，位于异常点之后的、并且在当前 try 块内的语句就都不会再执行了；即使 catch 语句成功地处理了错误，程序的执行流也不会再回退到异常点，所以这些语句永远都没有执行的机会了.  

异常既然是一份数据，那么就应该有数据类型。C++ 规定，**`异常类型`**可以是 int、char、float、bool 等基本类型，也可以是指针、数组、字符串、结构体、类等聚合类型。  

**`exceptionType variable`** 和函数的形参非常类似，当异常发生后，会将异常数据传递给 variable 这个变量，这和函数传参的过程类似。当然，只有跟 exceptionType 类型匹配的异常数据才会被传递给 variable，否则 catch 不会接收这份异常数据，也不会执行 catch 块中的语句.  

C++ 语言本身以及标准库中的函数抛出的异常，都是 exception 类或其子类的异常。也就是说，抛出异常时，会创建一个 exception 类或其子类的对象。  

	exception 类位于 <exception> 头文件.  

```cpp
	#include <iostream>
	#include <string>
	#include <exception>
	using namespace std;
	
	class Base
	{
	};
	class Derived : public Base
	{
	};
	
	void func()
	{
	    throw "Unknown Exception"; //抛出异常
	    cout << "[1]This statement will not be executed." << endl;
	}
	
	int main()
	{
	    string str = "http://c.biancheng.net";
	    try
	    {
	        char ch1 = str[100];
	        cout << ch1 << endl;
	    }
	    catch (exception e)
	    {
	        cout << "[1]out of bound!" << endl;
	    }
	
	    try
	    {
	        char ch2 = str.at(100);
	        cout << ch2 << endl;
	    }
	    catch (exception &e)  // 之所以使用引用，是为了提高效率。如果不使用引用，就要经历一次对象拷贝（要调用拷贝构造函数）的过程。
	    { //exception类位于<exception>头文件中
	        cout << "[2]out of bound!" << endl;
	    }
	
	    try
	    {
	        func();
	    }
	    catch (const char *&e)
	    {
	        cout << e << endl;
	    }
	
	    try
	    {
	        throw Derived(); //抛出自己的异常类型，实际上是创建一个Derived类型的匿名对象
	        cout << "This statement will not be executed." << endl;
	    }
	    catch (int)
	    {
	        cout << "Exception type: int" << endl;
	    }
	    catch (char *)
	    {
	        cout << "Exception type: cahr *" << endl;
	    }
	    catch (Base)
	    { //匹配成功（向上转型）
	        cout << "Exception type: Base" << endl;
	    }
	    catch (Derived)
	    {
	        cout << "Exception type: Derived" << endl;
	    }
	
	    int nums[] = {1, 2, 3};
	    try
	    {
	        throw nums;   // 数组类型
	        throw str;    // 数组类型
	        throw 100;    // int 类型
	        cout << "This statement will not be executed." << endl;
	    }
	    catch (const int *)
	    {
	        cout << "Exception type: const int *" << endl;
	    }
	
	    return 0;
	}
```
运行结果；
```
	[2]out of bound!
	Unknown Exception
	Exception type: Base
	Exception type: const int *
```
 * 期望的是，异常被catch(Derived)捕获，但是从输出结果可以看出，异常提前被catch(Base)捕获了，这说明 catch 在匹配异常类型时发生了向上转型（Upcasting）.  
 * nums 本来的类型是int [3]，但是 catch 中没有严格匹配的类型，所以先转换为int *，再转换为const int *.  

## exception类

	exception 类位于 <exception> 头文件.  

C++语言本身或者标准库抛出的异常都是 exception 的子类，称为标准异常（Standard Exception）。你可以通过下面的语句来捕获所有的标准异常：

```cpp
	try{
	    //可能抛出异常的语句
	}catch(exception &e){
	    //处理异常的语句
	}
```
之所以使用引用，是为了提高效率。如果不使用引用，就要经历一次对象拷贝（要调用拷贝构造函数）的过程。




















