<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.1" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://kung-fu-master.github.io/page/26/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Kung-Fu-Master">
<meta name="twitter:card" content="summary"><title>Hexo</title><link ref="canonical" href="https://kung-fu-master.github.io/page/26/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: true,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return false;"><span class="header-nav-menu-item__icon"><i class="fas fa-feather-alt"></i></span><span class="header-nav-menu-item__text">文章</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/categories/"><span class="header-nav-submenu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-submenu-item__text">分类</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/archives/"><span class="header-nav-submenu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-submenu-item__text">归档</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/tags/"><span class="header-nav-submenu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-submenu-item__text">标签</span></a></div></div></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-fingerprint"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Hexo</div><div class="header-banner-info__subtitle"></div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/03/13/reference/k8s/04.%E9%A2%84%E4%B9%A0%E7%AF%87-%E5%B0%8F%E9%B2%B8%E9%B1%BC%E5%A4%A7%E4%BA%8B%E8%AE%B0(%E5%9B%9B)%E5%B0%98%E5%9F%83%E8%90%BD%E5%AE%9A/">04 | 预习篇 · 小鲸鱼大事记（四）：尘埃落定</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">4k</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="1.jpg"  alt="">
      </p>
<p>在上一次的分享中我提到，伴随着 Docker 公司一手打造出来的容器技术生态在云计算市场中站稳了脚跟，围绕着 Docker 项目进行的各个层次的集成与创新产品，也如雨后春笋般出现在这个新兴市场当中。而 Docker 公司，不失时机地发布了 Docker Compose、Swarm 和 Machine“三件套”，在重新定义 PaaS 的方向上走出了最关键的一步。</p>
<p>这段时间，也正是 Docker 生态创业公司们的春天，大量围绕着 Docker 项目的网络、存储、监控、CI/CD，甚至 UI 项目纷纷出台，也涌现出了很多 Rancher、Tutum 这样在开源与商业上均取得了巨大成功的创业公司。</p>
<p>在 2014~2015 年间，整个容器社区可谓热闹非凡。</p>
<p>这令人兴奋的繁荣背后，却浮现出了更多的担忧。这其中最主要的负面情绪，是对 Docker 公司商业化战略的种种顾虑。</p>
<p>事实上，很多从业者也都看得明白，Docker 项目此时已经成为 Docker 公司一个商业产品。而开源，只是 Docker 公司吸引开发者群体的一个重要手段。不过这么多年来，开源社区的商业化其实都是类似的思路，无非是高不高调、心不心急的问题罢了。</p>
<p>而真正令大多数人不满意的是，Docker 公司在 Docker 开源项目的发展上，始终保持着绝对的权威和发言权，并在多个场合用实际行动挑战到了其他玩家（比如，CoreOS、RedHat，甚至谷歌和微软）的切身利益。</p>
<p>那么，这个时候，大家的不满也就不再是在 GitHub 上发发牢骚这么简单了。</p>
<p>相信很多容器领域的老玩家们都听说过，Docker 项目刚刚兴起时，Google 也开源了一个在内部使用多年、经历过生产环境验证的 Linux 容器：lmctfy（Let Me Container That For You）。</p>
<p>然而，面对 Docker 项目的强势崛起，这个对用户没那么友好的 Google 容器项目根本没有招架之力。所以，知难而退的 Google 公司，向 Docker 公司表示了合作的愿望：关停这个项目，和 Docker 公司共同推进一个中立的容器运行时（container runtime）库作为 Docker 项目的核心依赖。</p>
<p>不过，Docker 公司并没有认同这个明显会削弱自己地位的提议，还在不久后，自己发布了一个容器运行时库 Libcontainer。这次匆忙的、由一家主导的、并带有战略性考量的重构，成了 Libcontainer 被社区长期诟病代码可读性差、可维护性不强的一个重要原因。</p>
<p>至此，Docker 公司在容器运行时层面上的强硬态度，以及 Docker 项目在高速迭代中表现出来的不稳定和频繁变更的问题，开始让社区叫苦不迭。</p>
<p>这种情绪在 2015 年达到了一个小高潮，容器领域的其他几位玩家开始商议“切割”Docker 项目的话语权。而“切割”的手段也非常经典，那就是成立一个中立的基金会。</p>
<p>于是，2015 年 6 月 22 日，由 Docker 公司牵头，CoreOS、Google、RedHat 等公司共同宣布，Docker 公司将 Libcontainer 捐出，并改名为 RunC 项目，交由一个完全中立的基金会管理，然后以 RunC 为依据，大家共同制定一套容器和镜像的标准和规范。</p>
<p>这套标准和规范，<strong>就是 OCI（ Open Container Initiative ）。OCI 的提出，意在将容器运行时和镜像的实现从 Docker 项目中完全剥离出来。</strong>这样做，一方面可以改善 Docker 公司在容器技术上一家独大的现状，另一方面也为其他玩家不依赖于 Docker 项目构建各自的平台层能力提供了可能。</p>
<p>不过，不难看出，OCI 的成立更多的是这些容器玩家出于自身利益进行干涉的一个妥协结果。所以，尽管 Docker 是 OCI 的发起者和创始成员，它却很少在 OCI 的技术推进和标准制定等事务上扮演关键角色，也没有动力去积极地推进这些所谓的标准。</p>
<p>这，也正是迄今为止 OCI 组织效率持续低下的根本原因。</p>
<p>眼看着 OCI 并没能改变 Docker 公司在容器领域一家独大的现状，Google 和 RedHat 等公司于是把与第二把武器摆上了台面。</p>
<p>Docker 之所以不担心 OCI 的威胁，原因就在于它的 Docker 项目是容器生态的事实标准，而它所维护的 Docker 社区也足够庞大。可是，一旦这场斗争被转移到容器之上的平台层，或者说 PaaS 层，Docker 公司的竞争优势便立刻捉襟见肘了。</p>
<p>在这个领域里，像 Google 和 RedHat 这样的成熟公司，都拥有着深厚的技术积累；而像 CoreOS 这样的创业公司，也拥有像 Etcd 这样被广泛使用的开源基础设施项目。</p>
<p>可是 Docker 公司呢？它却只有一个 Swarm。</p>
<p>所以这次，<strong>Google、RedHat 等开源基础设施领域玩家们，共同牵头发起了一个名为 CNCF（Cloud Native Computing Foundation）的基金会。这个基金会的目的其实很容易理解：它希望，以 Kubernetes 项目为基础，建立一个由开源基础设施领域厂商主导的、按照独立基金会方式运营的平台级社区，来对抗以 Docker 公司为核心的容器商业生态。</strong></p>
<p>而为了打造出这样一个围绕 Kubernetes 项目的“护城河”，CNCF 社区就需要至少确保两件事情：</p>
<ol>
<li><p>Kubernetes 项目必须能够在容器编排领域取得足够大的竞争优势；</p>
</li>
<li><p>CNCF 社区必须以 Kubernetes 项目为核心，覆盖足够多的场景。</p>
</li>
</ol>
<p>我们先来看看 CNCF 社区如何解决 Kubernetes 项目在编排领域的竞争力的问题。</p>
<p>在容器编排领域，Kubernetes 项目需要面对来自 Docker 公司和 Mesos 社区两个方向的压力。不难看出，Swarm 和 Mesos 实际上分别从两个不同的方向讲出了自己最擅长的故事：Swarm 擅长的是跟 Docker 生态的无缝集成，而 Mesos 擅长的则是大规模集群的调度与管理。</p>
<p>这两个方向，也是大多数人做容器集群管理项目时最容易想到的两个出发点。也正因为如此，Kubernetes 项目如果继续在这两个方向上做文章恐怕就不太明智了。</p>
<p>所以这一次，Kubernetes 选择的应对方式是：Borg。</p>
<p>如果你看过 Kubernetes 项目早期的 GitHub Issue 和 Feature 的话，就会发现它们大多来自于 Borg 和 Omega 系统的内部特性，这些特性落到 Kubernetes 项目上，就是 Pod、Sidecar 等功能和设计模式。</p>
<p>这就解释了，为什么 Kubernetes 发布后，很多人“抱怨”其设计思想过于“超前”的原因：Kubernetes 项目的基础特性，并不是几个工程师突然“拍脑袋”想出来的东西，而是 Google 公司在容器化基础设施领域多年来实践经验的沉淀与升华。这，正是 Kubernetes 项目能够从一开始就避免同 Swarm 和 Mesos 社区同质化的重要手段。</p>
<p>于是，CNCF 接下来的任务就是，如何把这些先进的思想通过技术手段在开源社区落地，并培育出一个认同这些理念的生态？这时，RedHat 就发挥了重要作用。</p>
<p>当时，Kubernetes 团队规模很小，能够投入的工程能力也十分紧张，而这恰恰是 RedHat 的长处。更难得的是，RedHat 是世界上为数不多的、能真正理解开源社区运作和项目研发真谛的合作伙伴。</p>
<p>所以，RedHat 与 Google 联盟的成立，不仅保证了 RedHat 在 Kubernetes 项目上的影响力，也正式开启了容器编排领域“三国鼎立”的局面。</p>
<p>这时，我们再重新审视容器生态的格局，就不难发现 Kubernetes 项目、Docker 公司和 Mesos 社区这三大玩家的关系已经发生了微妙的变化。</p>
<p>其中，Mesos 社区与容器技术的关系，更像是“借势”，而不是这个领域真正的参与者和领导者。这个事实，加上它所属的 Apache 社区固有的封闭性，导致了 Mesos 社区虽然技术最为成熟，却在容器编排领域鲜有创新。</p>
<p>这也是为何，Google 公司很快就把注意力转向了动作更加激进的 Docker 公司。</p>
<p>有意思的是，Docker 公司对 Mesos 社区也是类似的看法。所以从一开始，Docker 公司就把应对 Kubernetes 项目的竞争摆在了首要位置：一方面，不断强调“Docker Native”的“重要性”，另一方面，与 Kubernetes 项目在多个场合进行了直接的碰撞。</p>
<p>不过，这次竞争的发展态势，很快就超过了 Docker 公司的预期。</p>
<p>Kubernetes 项目并没有跟 Swarm 项目展开同质化的竞争，所以“Docker Native”的说辞并没有太大的杀伤力。相反地，Kubernetes 项目让人耳目一新的设计理念和号召力，很快就构建出了一个与众不同的容器编排与管理的生态。</p>
<p>就这样，Kubernetes 项目在 GitHub 上的各项指标开始一骑绝尘，将 Swarm 项目远远地甩在了身后。</p>
<p>有了这个基础，CNCF 社区就可以放心地解决第二个问题了。</p>
<p><strong>在已经囊括了容器监控事实标准的 Prometheus 项目之后，CNCF 社区迅速在成员项目中添加了 Fluentd、OpenTracing、CNI 等一系列容器生态的知名工具和项目。</strong></p>
<p><strong>而在看到了 CNCF 社区对用户表现出来的巨大吸引力之后，大量的公司和创业团队也开始专门针对 CNCF 社区而非 Docker 公司制定推广策略。</strong></p>
<p>面对这样的竞争态势，Docker 公司决定更进一步。在 2016 年，Docker 公司宣布了一个震惊所有人的计划：放弃现有的 Swarm 项目，将容器编排和集群管理功能全部内置到 Docker 项目当中。</p>
<p>显然，Docker 公司意识到了 Swarm 项目目前唯一的竞争优势，就是跟 Docker 项目的无缝集成。那么，如何让这种优势最大化呢？那就是把 Swarm 内置到 Docker 项目当中。</p>
<p>实际上，从工程角度来看，这种做法的风险很大。内置容器编排、集群管理和负载均衡能力，固然可以使得 Docker 项目的边界直接扩大到一个完整的 PaaS 项目的范畴，但这种变更带来的技术复杂度和维护难度，长远来看对 Docker 项目是不利的。</p>
<p>不过，在当时的大环境下，Docker 公司的选择恐怕也带有一丝孤注一掷的意味。</p>
<p>而Kubernetes 的应对策略则是反其道而行之，开始在整个社区推进“民主化”架构，即：<strong>从 API 到容器运行时的每一层，Kubernetes 项目都为开发者暴露出了可以扩展的插件机制，鼓励用户通过代码的方式介入到 Kubernetes 项目的每一个阶段。</strong></p>
<p>Kubernetes 项目的这个变革的效果立竿见影，很快在整个容器社区中催生出了大量的、基于 Kubernetes API 和扩展接口的二次创新工作，比如：</p>
<ul>
<li>目前热度极高的微服务治理项目 Istio；</li>
<li>被广泛采用的有状态应用部署框架 Operator；</li>
<li>还有像 Rook 这样的开源创业项目，它通过 Kubernetes 的可扩展接口，把 Ceph 这样的重量级产品封装成了简单易用的容器存储插件。<br>就这样，在这种鼓励二次创新的整体氛围当中，Kubernetes 社区在 2016 年之后得到了空前的发展。更重要的是，不同于之前局限于“打包、发布”这样的 PaaS 化路线，<strong>这一次容器社区的繁荣，是一次完全以 Kubernetes 项目为核心的“百花争鸣”。</strong></li>
</ul>
<p>面对 Kubernetes 社区的崛起和壮大，Docker 公司也不得不面对自己豪赌失败的现实。但在<strong>早前拒绝了微软的天价收购</strong>之后，Docker 公司实际上已经没有什么回旋余地，只能选择逐步放弃开源社区而专注于自己的商业化转型。</p>
<p>所以，从 2017 年开始，<strong>Docker 公司先是将 Docker 项目的容器运行时部分 Containerd 捐赠给 CNCF 社区，标志着 Docker 项目已经全面升级成为一个 PaaS 平台；紧接着，Docker 公司宣布将 Docker 项目改名为 Moby，然后交给社区自行维护，而 Docker 公司的商业产品将占有 Docker 这个注册商标。</strong></p>
<p>Docker 公司这些举措背后的含义非常明确：<strong>它将全面放弃在开源社区同 Kubernetes 生态的竞争，转而专注于自己的商业业务，并且通过将 Docker 项目改名为 Moby 的举动，将原本属于 Docker 社区的用户转化成了自己的客户。</strong></p>
<p>2017 年 10 月，<strong>Docker 公司出人意料地宣布，将在自己的主打产品 Docker 企业版中内置 Kubernetes 项目，这标志着持续了近两年之久的“编排之争”至此落下帷幕。</strong></p>
<p>2018 年 1 月 30 日，RedHat 宣布斥资 2.5 亿美元收购 CoreOS。</p>
<p>2018 年 3 月 28 日，这一切纷争的始作俑者，<strong>Docker 公司的 CTO Solomon Hykes 宣布辞职，</strong>曾经纷纷扰扰的容器技术圈子，到此尘埃落定。</p>
<p><strong>总结</strong><br>容器技术圈子在短短几年里发生了很多变数，但很多事情其实也都在情理之中。就像 Docker 这样一家创业公司，在通过开源社区的运作取得了巨大的成功之后，就不得不面对来自整个云计算产业的竞争和围剿。而这个产业的垄断特性，对于 Docker 这样的技术型创业公司其实天生就不友好。</p>
<p>在这种局势下，接受微软的天价收购，在大多数人看来都是一个非常明智和实际的选择。可是 Solomon Hykes 却多少带有一些理想主义的影子，既然不甘于“寄人篱下”，那他就必须带领 Docker 公司去对抗来自整个云计算产业的压力。</p>
<p>只不过，<strong>Docker 公司最后选择的对抗方式，是将开源项目与商业产品紧密绑定，打造了一个极端封闭的技术生态。而这，其实违背了 Docker 项目与开发者保持亲密关系的初衷。相比之下，Kubernetes 社区，正是以一种更加温和的方式，承接了 Docker 项目的未尽事业，即：以开发者为核心，构建一个相对民主和开放的容器生态。</strong></p>
<p>这也是为何，Kubernetes 项目的成功其实是必然的。</p>
<p>现在，我们很难想象如果 Docker 公司最初选择了跟 Kubernetes 社区合作，如今的容器生态又将会是怎样的一番景象。不过我们可以肯定的是，Docker 公司在过去五年里的风云变幻，以及 Solomon Hykes 本人的传奇经历，都已经在云计算的长河中留下了浓墨重彩的一笔。</p>
<p>思考题<br>你如何评价 Solomon Hykes 在 Docker 公司发展历程中的所作所为？你又是否看好 Docker 公司在今后的发展呢？</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/03/13/reference/k8s/05.%E7%99%BD%E8%AF%9D%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80(%E4%B8%80)%E4%BB%8E%E8%BF%9B%E7%A8%8B%E8%AF%B4%E5%BC%80%E5%8E%BB/">05 | 白话容器基础（一）：从进程说开去</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">3k</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="2.jpg"  alt="">
      </p>
<p>在前面的 4 篇预习文章中，我梳理了“容器”这项技术的来龙去脉，通过这些内容，我希望你能理解如下几个事实：</p>
<ul>
<li>容器技术的兴起源于 PaaS 技术的普及；</li>
<li>Docker 公司发布的 Docker 项目具有里程碑式的意义；</li>
<li>Docker 项目通过“容器镜像”，解决了应用打包这个根本性难题。<br>紧接着，我详细介绍了容器技术圈在过去五年里的“风云变幻”，而通过这部分内容，我希望你能理解这样一个道理：</li>
</ul>
<blockquote>
<p>容器本身没有价值，有价值的是“容器编排”。</p>
</blockquote>
<p>也正因为如此，容器技术生态才爆发了一场关于“容器编排”的“战争”。<strong><code>而这次战争，最终以 Kubernetes 项目和 CNCF 社区的胜利而告终。</code></strong>所以，这个专栏后面的内容，我会以 Docker 和 Kubernetes 项目为核心，为你详细介绍容器技术的各项实践与其中的原理。</p>
<p>不过在此之前，你还需要搞清楚一个更为基础的问题：</p>
<blockquote>
<p>容器，到底是怎么一回事儿？</p>
</blockquote>
<p>在第一篇预习文章《小鲸鱼大事记（一）：初出茅庐》中，我已经提到过，容器其实是一种沙盒技术。顾名思义，沙盒就是能够像一个集装箱一样，把你的应用“装”起来的技术。这样，应用与应用之间，就因为有了边界而不至于相互干扰；而被装进集装箱的应用，也可以被方便地搬来搬去，这不就是 PaaS 最理想的状态嘛。</p>
<p>不过，这两个能力说起来简单，但要用技术手段去实现它们，可能大多数人就无从下手了。</p>
<p>所以，我就先来跟你说说这个“边界”的实现手段。</p>
<p>假如，现在你要写一个计算加法的小程序，这个程序需要的输入来自于一个文件，计算完成后的结果则输出到另一个文件中。</p>
<p>由于计算机只认识 0 和 1，所以无论用哪种语言编写这段代码，最后都需要通过某种方式翻译成二进制文件，才能在计算机操作系统中运行起来。</p>
<p>而为了能够让这些代码正常运行，我们往往还要给它提供数据，比如我们这个加法程序所需要的输入文件。这些数据加上代码本身的二进制文件，放在磁盘上，就是我们平常所说的一个“程序”，也叫代码的可执行镜像（executable image）。</p>
<p>然后，我们就可以在计算机上运行这个“程序”了。</p>
<p>首先，操作系统从“程序”中发现输入数据保存在一个文件中，所以这些数据就被会加载到内存中待命。同时，操作系统又读取到了计算加法的指令，这时，它就需要指示 CPU 完成加法操作。而 CPU 与内存协作进行加法计算，又会使用寄存器存放数值、内存堆栈保存执行的命令和变量。同时，计算机里还有被打开的文件，以及各种各样的 I/O 设备在不断地调用中修改自己的状态。</p>
<p>就这样，一旦“程序”被执行起来，它就从磁盘上的二进制文件，变成了计算机内存中的数据、寄存器里的值、堆栈中的指令、被打开的文件，以及各种设备的状态信息的一个集合。<code>像这样一个程序运起来后的计算机执行环境的总和，就是我们今天的主角：进程。</code></p>
<p>所以，对于进程来说，它的静态表现就是程序，平常都安安静静地待在磁盘上；而一旦运行起来，它就变成了计算机里的数据和状态的总和，这就是它的动态表现。</p>
<p>而<code>容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”。</code></p>
<p>对于 Docker 等大多数 Linux 容器来说，<code>Cgroups</code> 技术是用来制造约束的主要手段，而 <code>Namespace</code> 技术则是用来修改进程视图的主要方法。</p>
<p>你可能会觉得 Cgroups 和 Namespace 这两个概念很抽象，别担心，接下来我们一起动手实践一下，你就很容易理解这两项技术了。</p>
<p>假设你已经有了一个 Linux 操作系统上的 Docker 项目在运行，比如我的环境是 Ubuntu 16.04 和 Docker CE 18.05。</p>
<p>接下来，让我们首先创建一个容器来试试。</p>
<pre><code>$ docker run -it busybox /bin/sh
/ #</code></pre><p>这个命令是 Docker 项目最重要的一个操作，即大名鼎鼎的 docker run。</p>
<p>而 -it 参数告诉了 Docker 项目在启动容器后，需要给我们分配一个文本输入 / 输出环境，也就是 TTY，跟容器的标准输入相关联，这样我们就可以和这个 Docker 容器进行交互了。而 /bin/sh 就是我们要在 Docker 容器里运行的程序。</p>
<p>所以，上面这条指令翻译成人类的语言就是：请帮我启动一个容器，在容器里执行 /bin/sh，并且给我分配一个命令行终端跟这个容器交互。</p>
<p>这样，我的 Ubuntu 16.04 机器就变成了一个宿主机，而一个运行着 /bin/sh 的容器，就跑在了这个宿主机里面。</p>
<p>上面的例子和原理，如果你已经玩过 Docker，一定不会感到陌生。此时，如果我们在容器里执行一下 ps 指令，就会发现一些更有趣的事情：</p>
<pre><code>/ # ps
PID  USER   TIME COMMAND
  1  root   0:00 /bin/sh
  10 root   0:00 ps</code></pre><p>可以看到，我们在 Docker 里最开始执行的 /bin/sh，就是这个容器内部的第 1 号进程（PID=1），而这个容器里一共只有两个进程在运行。这就意味着，前面执行的 /bin/sh，以及我们刚刚执行的 ps，已经被 Docker 隔离在了一个跟宿主机完全不同的世界当中。</p>
<p>这究竟是怎么做到呢？</p>
<p>本来，每当我们在宿主机上运行了一个 /bin/sh 程序，操作系统都会给它分配一个进程编号，比如 PID=100。这个编号是进程的唯一标识，就像员工的工牌一样。所以 PID=100，可以粗略地理解为这个 /bin/sh 是我们公司里的第 100 号员工，而第 1 号员工就自然是比尔 · 盖茨这样统领全局的人物。</p>
<p>而现在，我们要通过 Docker 把这个 /bin/sh 程序运行在一个容器当中。这时候，Docker 就会在这个第 100 号员工入职时给他施一个“障眼法”，让他永远看不到前面的其他 99 个员工，更看不到比尔 · 盖茨。这样，他就会错误地以为自己就是公司里的第 1 号员工。</p>
<p><code>这种机制，其实就是对被隔离应用的进程空间做了手脚，使得这些进程只能看到重新计算过的进程编号，比如 PID=1。可实际上，他们在宿主机的操作系统里，还是原来的第 100 号进程。</code></p>
<p><code>这种技术，就是 Linux 里面的 Namespace 机制。</code>而 Namespace 的使用方式也非常有意思：它其实只是 Linux 创建新进程的一个可选参数。我们知道，在 Linux 系统中创建线程的系统调用是 clone()，比如：</p>
<pre><code>int pid = clone(main_function, stack_size, SIGCHLD, NULL); </code></pre><p>这个系统调用就会为我们创建一个新的进程，并且返回它的进程号 pid。</p>
<p>而当我们用 clone() 系统调用创建一个新进程时，就可以在参数中指定 CLONE_NEWPID 参数，比如：</p>
<pre><code>int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL); </code></pre><p>这时，新创建的这个进程将会“看到”一个全新的进程空间，在这个进程空间里，它的 PID 是 1。之所以说“看到”，是因为这只是一个“障眼法”，在宿主机真实的进程空间里，这个进程的 PID 还是真实的数值，比如 100。</p>
<p>当然，我们还可以多次执行上面的 clone() 调用，这样就会创建多个 PID Namespace，而每个 Namespace 里的应用进程，都会认为自己是当前容器里的第 1 号进程，它们既看不到宿主机里真正的进程空间，也看不到其他 PID Namespace 里的具体情况。</p>
<p>而<code>除了我们刚刚用到的 PID Namespace，Linux 操作系统还提供了 Mount、UTS、IPC、Network 和 User 这些 Namespace，用来对各种不同的进程上下文进行“障眼法”操作。</code></p>
<p>比如，Mount Namespace，用于让被隔离进程只看到当前 Namespace 里的挂载点信息；Network Namespace，用于让被隔离进程看到当前 Namespace 里的网络设备和配置。</p>
<p>这，<code>就是 Linux 容器最基本的实现原理了。</code></p>
<p>所以，<code>Docker 容器这个听起来玄而又玄的概念，实际上是在创建容器进程时，指定了这个进程所需要启用的一组 Namespace 参数。</code>这样，容器就只能“看”到当前 Namespace 所限定的资源、文件、设备、状态，或者配置。而对于宿主机以及其他不相关的程序，它就完全看不到了。</p>
<p>所以说，<code>容器，其实是一种特殊的进程而已。</code></p>
<p><strong>总结</strong><br>谈到为“进程划分一个独立空间”的思想，相信你一定会联想到虚拟机。而且，你应该还看过一张虚拟机和容器的对比图。<br>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="1.jpg"  alt="">
      </p>
<p>这幅图的左边，画出了虚拟机的工作原理。其中，名为 Hypervisor 的软件是虚拟机最主要的部分。它通过硬件虚拟化功能，模拟出了运行一个操作系统需要的各种硬件，比如 CPU、内存、I/O 设备等等。然后，它在这些虚拟的硬件上安装了一个新的操作系统，即 Guest OS。</p>
<p>这样，用户的应用进程就可以运行在这个虚拟的机器中，它能看到的自然也只有 Guest OS 的文件和目录，以及这个机器里的虚拟设备。这就是为什么虚拟机也能起到将不同的应用进程相互隔离的作用。</p>
<p>而这幅图的右边，则用一个名为 Docker Engine 的软件替换了 Hypervisor。这也是为什么，很多人会把 Docker 项目称为“轻量级”虚拟化技术的原因，实际上就是把虚拟机的概念套在了容器上。</p>
<p>可是这样的说法，却并不严谨。</p>
<p>在理解了 Namespace 的工作方式之后，你就会明白，跟真实存在的虚拟机不同，在使用 Docker 的时候，并没有一个真正的“Docker 容器”运行在宿主机里面。Docker 项目帮助用户启动的，还是原来的应用进程，只不过在创建这些进程时，Docker 为它们加上了各种各样的 Namespace 参数。</p>
<p>这时，这些进程就会觉得自己是各自 PID Namespace 里的第 1 号进程，只能看到各自 Mount Namespace 里挂载的目录和文件，只能访问到各自 Network Namespace 里的网络设备，就仿佛运行在一个个“容器”里面，与世隔绝。</p>
<p>不过，相信你此刻已经会心一笑：这些不过都是“障眼法”罢了。</p>
<p><strong>思考题</strong><br>鉴于我对容器本质的讲解，你觉得上面这张容器和虚拟机对比图右侧关于容器的部分，怎么画才更精确？</p>
<p>你是否知道最新的 Docker 项目默认会为容器启用哪些 Namespace 吗？</p>
<p>感谢你的收听，欢迎你给我留言，也欢迎分享给更多的朋友一起阅读。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/03/13/micro_service/kubernetes/02_kubernetes_roles_introduction/">02 kubernetes introduction</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1k</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="kubernetes组件官网介绍"   >
          <a href="#kubernetes组件官网介绍" class="heading-link"><i class="fas fa-link"></i></a>kubernetes组件官网介绍</h2>
      <p><span class="exturl"><a class="exturl__link"   href="https://kubernetes.io/docs/reference/"  target="_blank" rel="noopener">https://kubernetes.io/docs/reference/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="REST"   >
          <a href="#REST" class="heading-link"><i class="fas fa-link"></i></a>REST</h3>
      <blockquote>
<p>REST（representational state transfer）是由roy博士在他的论文中提出的一个术语，rest本身只是为分布式超媒体系统设计的一种架构风格，而不是标准</p>
<ul>
<li>无状态性：<br>  这是在客户-服务器的基础上添加的又一层规范，它要求通信必须在本质上是无状态的，即从客户端到服务器的每个request都必须包含理解该request所必须的所有信息。这个规范改善了系统的可见性（无状态性使得客户端和服务端不必保存对方的详细信息，服务器只需要处理当前的request，而不必了解所有request的历史）、可靠性（无状态性减少了服务器从局部错误中恢复的任务量）、可伸缩性（无状态使得服务器端可以很容易地释放资源，因为服务端不必在多个request中保存状态）。同时，这种规范的缺点也是显而易见的，由于不能将状态数据保存在服务器上，因此增加了在一系列request中发生重复数据的开销，严重降低了效率。</li>
<li>缓存：<br>  为了改善无状态性带来的网络低效性，我们添加了缓存约束，缓存约束允许隐式或显式标记一个response中的数据，赋予了客户端缓存response数据的功能，这样就可以为以后的request公用缓存的数据，部分或全部地消除一部分交互，提高了网络效率。但是由于客户端缓存了信息，所以增加了客户端与服务器数据不一致的可能性，从而降低了可靠性。<br>REST中的资源所指的不是数据，而是数据和表现形式的组合，比如“最新访问的10位会员”和“最活跃的10位会员”在数据上可能有重叠或者完全相同，而由于它们的表现形式不同，所以被归于不同的资源，这也就是为什么REST的全名是representational state transfer，资源标识符就是URI（uniform resource identifier），不管是图片，word还是视频文件，也不管是什么格式，全部通过URI对资源进行唯一标识.<br>kubernetes API是集群系统中的重要组成部分，kubernetes中各种资源的数据通过该API接口被提交到后端的持久性存储etcd中，kubernetes集群中的各部分之间通过该API接口实现解耦合，同时kubernetes集群中一个重要且便捷的管理工具kubectl也是通过访问该API接口实现其强大的管理功能的。kubernetes API中的资源对象都拥有通用的元数据，资源对象也可能存在嵌套现象，比如在一个pod里面嵌套多个container。创建一个API对象是指通过API调用一条有意义的记录，该记录一旦被创建，kubernetes将确保对应的资源对象会被自动创建并托管维护</li>
</ul>
</blockquote>

        <h3 id="标签"   >
          <a href="#标签" class="heading-link"><i class="fas fa-link"></i></a>标签</h3>
      <blockquote>
<p>我们不会特别说明pod应该调度到哪个节点上， 因为这将会使应用程序与基础架构强耦合， 从而违背了Kubemetes对运行在其上的应用程序隐藏实际 的基础架构的整个构想。<br>但如果你想对一个 pod应该调度到哪里拥有发言权， 那就不应该直接指定一个确切的节点， 而应该用某种方式描述对节点的需求， 使Kubemetes选择一个符合这些需求的节点。这恰恰可以通过节点标签和节点标签选择器完成<br>pod并不是唯一可以附加标签的Kubemetes资源。 标签可以附加到任何Kubemetes对象上， 包括节点。 通常来说， 当运维团队向集群添加新节点时，他们将通过附加标签来对节点进行分类， 这些 标签指定节点提供 的硬件类型 ， 或者任何在调度pod 时能提供便利的其他信息</p>
</blockquote>

        <h2 id="roles"   >
          <a href="#roles" class="heading-link"><i class="fas fa-link"></i></a>roles</h2>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/03/13/micro_service/istio/istio_K8s_SpringCloud/">Istio_K8s_SpringCloud</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">123</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>SpringCloud、Istio比较</p>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   href="https://blog.csdn.net/qq_33873431/article/details/89524554"  target="_blank" rel="noopener">https://blog.csdn.net/qq_33873431/article/details/89524554</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>Spring Cloud Netflix vs. Kubernetes＆Istio</p>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   href="https://my.oschina.net/xiaominmin/blog/1859677"  target="_blank" rel="noopener">https://my.oschina.net/xiaominmin/blog/1859677</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br><span class="exturl"><a class="exturl__link"   href="https://my.oschina.net/xiaominmin?tab=newest&amp;catalogId=5894416"  target="_blank" rel="noopener">https://my.oschina.net/xiaominmin?tab=newest&amp;catalogId=5894416</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>史上最简单的spark系列教程</p>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   href="https://blog.csdn.net/youbitch1/article/details/89925790"  target="_blank" rel="noopener">https://blog.csdn.net/youbitch1/article/details/89925790</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>Spark教程视频:<br><span class="exturl"><a class="exturl__link"   href="https://www.bilibili.com/video/BV1JE411R7Xp?p=55"  target="_blank" rel="noopener">https://www.bilibili.com/video/BV1JE411R7Xp?p=55</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br><span class="exturl"><a class="exturl__link"   href="https://www.bilibili.com/video/BV11J41147iP?p=1"  target="_blank" rel="noopener">https://www.bilibili.com/video/BV11J41147iP?p=1</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br><span class="exturl"><a class="exturl__link"   href="https://www.bilibili.com/video/BV11J41147iP?p=1"  target="_blank" rel="noopener">https://www.bilibili.com/video/BV11J41147iP?p=1</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>Istio B站学习视频和对应的Gihub文档</p>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   href="https://www.bilibili.com/video/BV1vt411H755/?spm_id_from=333.788.videocard.0"  target="_blank" rel="noopener">https://www.bilibili.com/video/BV1vt411H755/?spm_id_from=333.788.videocard.0</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br><span class="exturl"><a class="exturl__link"   href="https://github.com/Kung-Fu-Master/Document"  target="_blank" rel="noopener">https://github.com/Kung-Fu-Master/Document</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>Istio中文社区:</p>
<blockquote>
<ul>
<li><span class="exturl"><a class="exturl__link"   href="https://istio.cn/"  target="_blank" rel="noopener">中文社区</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link"   href="https://istio.cn/t/topic/270"  target="_blank" rel="noopener">Istio 1.5发布</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ul>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/03/13/micro_service/istio/istio_cert_manager/">istio cert-manager</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">43</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="cert-manager"   >
          <a href="#cert-manager" class="heading-link"><i class="fas fa-link"></i></a>cert-manager</h2>
      <p>Official website:<br><span class="exturl"><a class="exturl__link"   href="https://istio.io/latest/zh/docs/ops/integrations/certmanager/"  target="_blank" rel="noopener">https://istio.io/latest/zh/docs/ops/integrations/certmanager/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   href="https://cert-manager.io/"  target="_blank" rel="noopener">cert-manager</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 是一种自动执行证书管理的工具，它可以与 Istio Gateway 集成以管理 TLS 证书。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/03/13/micro_service/istio/istio_problems/">Istio problems</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">111</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="istio-bookinfo部署不成功"   >
          <a href="#istio-bookinfo部署不成功" class="heading-link"><i class="fas fa-link"></i></a>istio bookinfo部署不成功</h2>
      <p>部署istio官网bookinfo出现以下错误</p>
<pre><code>$ kubectl describe replicaset.apps/details-v1-769468b8c -n book-info
  Warning  FailedCreate  3s (x13 over 24s)  replicaset-controller  Error creating: Internal error occurred: failed calling webhook &quot;sidecar-injector.istio.io&quot;: Post &quot;https://istiod.istio-system.svc:443/inject?timeout=30s&quot;: x509: certificate signed by unknown authority</code></pre><p>官网推荐解决方法: <span class="exturl"><a class="exturl__link"   href="https://istio.io/latest/docs/ops/common-problems/injection/#automatic-sidecar-injection-fails-if-the-kubernetes-api-server-has-proxy-settings"  target="_blank" rel="noopener">https://istio.io/latest/docs/ops/common-problems/injection/#automatic-sidecar-injection-fails-if-the-kubernetes-api-server-has-proxy-settings</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>注释掉  /etc/kubernetes/manifests/kube-apiserver.yaml 文件里的proxy</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/03/13/micro_service/istio/istio_%E6%9F%A5%E7%9C%8B%E5%92%8C%E5%BB%B6%E9%95%BF%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6/">istio 查看和延长自签名证书</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">13</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>Official website:<br><span class="exturl"><a class="exturl__link"   href="https://istio.io/latest/zh/docs/ops/configuration/security/root-transition/"  target="_blank" rel="noopener">https://istio.io/latest/zh/docs/ops/configuration/security/root-transition/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/03/13/micro_service/istio/istio_%E9%99%90%E5%88%B6%E8%AE%BF%E9%97%AE%E7%AD%96%E7%95%A5/">istio 限制访问策略</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">26</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>Official website:<br><span class="exturl"><a class="exturl__link"   href="https://istio.io/latest/docs/concepts/security/#authorization-policies"  target="_blank" rel="noopener">https://istio.io/latest/docs/concepts/security/#authorization-policies</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>(已经弃用)<span class="exturl"><a class="exturl__link"   href="https://istio.io/latest/docs/tasks/policy-enforcement/denial-and-list/"  target="_blank" rel="noopener">https://istio.io/latest/docs/tasks/policy-enforcement/denial-and-list/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/03/13/linux/%E6%9F%A5%E7%9C%8BSSD/">查看SSD</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">348</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>[root@wlp10 ~]# lsscsi -ls<br>[6:0:0:0]    disk    ATA      INTEL SSDSC2BB48 0370  /dev/sda    480GB<br>  state=running queue_depth=32 scsi_level=6 type=0 device_blocked=0 timeout=30<br>[7:0:0:0]    disk    ATA      INTEL SSDSC2BB48 0101  /dev/sdb    480GB<br>  state=running queue_depth=32 scsi_level=6 type=0 device_blocked=0 timeout=30<br>[8:0:0:0]    disk    ATA      INTEL SSDSC2BB48 0370  /dev/sdc    480GB<br>  state=running queue_depth=32 scsi_level=6 type=0 device_blocked=0 timeout=30<br>[9:0:0:0]    disk    ATA      INTEL SSDSC2BG01 0015  /dev/sdd   1.20TB<br>  state=running queue_depth=32 scsi_level=6 type=0 device_blocked=0 timeout=30<br>[root@wlp10 ~]#<br>看第四列就知道是否是SSD硬盘了</p>
<p>[root@wlp10 ~]# lsscsi -h<br>Usage: lsscsi   [–classic] [–device] [–generic] [–help] [–hosts]<br>                [–kname] [–list] [–lunhex] [–long] [–protection]<br>                [–scsi_id] [–size] [–sysfsroot=PATH] [–transport]<br>                [–verbose] [–version] [–wwn] [&lt;h:c:t:l&gt;]<br>  where:<br>    –classic|-c      alternate output similar to ‘cat /proc/scsi/scsi’<br>    –device|-d       show device node’s major + minor numbers<br>    –generic|-g      show scsi generic device name<br>    –help|-h         this usage information<br>    –hosts|-H        lists scsi hosts rather than scsi devices<br>    –kname|-k        show kernel name instead of device node name<br>    –list|-L         additional information output one<br>                      attribute=value per line<br>    –long|-l         additional information output<br>    –lunhex|-x       show LUN part of tuple as hex number in T10 format;<br>                      use twice to get full 16 digit hexadecimal LUN<br>    –protection|-p   show target and initiator protection information<br>    –protmode|-P     show negotiated protection information mode<br>    –scsi_id|-i      show udev derived /dev/disk/by-id/scsi* entry<br>    –size|-s         show disk size<br>    –sysfsroot=PATH|-y PATH    set sysfs mount point to PATH (def: /sys)<br>    –transport|-t    transport information for target or, if ‘–hosts’<br>                      given, for initiator<br>    –verbose|-v      output path names where data is found<br>    –version|-V      output version string and exit<br>    –wwn|-w          output WWN for disks (from /dev/disk/by-id/wwn<em>)<br>    &lt;h:c:t:l&gt;         filter output list (def: ‘</em>:<em>:</em>:*’ (all))</p>
<p>List SCSI devices or hosts, optionally with additional information<br>[root@wlp10 ~]#</p>
<p>From <span class="exturl"><a class="exturl__link"   href="https://www.cnblogs.com/laozhuang/p/7110438.html"  target="_blank" rel="noopener">https://www.cnblogs.com/laozhuang/p/7110438.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/03/13/linux/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98-%E4%BD%BF%E7%94%A8dev_mem&amp;mmap/">用户态和内核共享内存----使用 /dev/mem &amp; mmap</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-03-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">938</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>想法的来源是看到chinaunix上有人转载了wheelz的博客，但是wheelz的代码在我的实验平台上是不能正常工作的，可能是wheelz的代码太过久远，我试验的内核版本是：3.4.13。wheelz的源代码如下：<br>// 内核模块<br>#include &lt;linux/config.h&gt;<br>#include &lt;linux/module.h&gt;<br>#include &lt;linux/kernel.h&gt;<br>#include &lt;linux/mm.h&gt;<br>MODULE_LICENSE(“GPL”);<br>MODULE_AUTHOR(“Wheelz”);<br>MODULE_DESCRIPTION(“mmap demo”);<br>static unsigned long p = 0;<br>static int __init init(void)<br>{<br>        //分配共享内存（一个页面）<br>        p = __get_free_pages(GFP_KERNEL, 0);<br>        SetPageReserved(virt_to_page(p));<br>        printk(“&lt;1&gt; p = 0x%08x\n”, p);<br>    //p是内核中的虚拟地址<br>        //在共享内存中写上一个字符串<br>        strcpy(p, “Hello world!\n”);<br>        return 0;<br>}<br>static void __exit fini(void)<br>{<br>        ClearPageReserved(virt_to_page(p));<br>        free_pages(p, 0);<br>}<br>module_init(init);<br>module_exit(fini);</p>
<hr>
<p>// 用户态程序<br>#include &lt;sys/mman.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;stdio.h&gt;<br>#define PAGE_SIZE (4*1024)<br>#define PAGE_OFFSET                0xc0000000<br>#define KERNEL_VIRT_ADDR        0xc5e3c000<br>int main()<br>{<br>        char *buf;<br>        int fd;<br>        unsigned long phy_addr;<br>fd=open(“/dev/mem”,O_RDWR);<br>if(fd == -1)<br>                perror(“open”);<br>        phy_addr=KERNEL_VIRT_ADDR - PAGE_OFFSET;<br>        //此处不太懂，不能理解物理地址phy_addr的计算方法<br>        buf=mmap(0, PAGE_SIZE,<br>                PROT_READ|PROT_WRITE, MAP_SHARED,<br>                fd, phy_addr);<br>        if(buf == MAP_FAILED)<br>                perror(“mmap”);<br>puts(buf);//打印共享内存的内容<br>        munmap(buf,PAGE_SIZE);<br>        close(fd);<br>        return 0;<br>}<br>在网上找了一些资料，导致这段代码不工作的原因可能有一下几个：<br>（1）在编译内核时设置了CONFIG_STRICT_DEVMEM（某些版本中是CONFIG_NONPROMISC_DEVMEM），应该将此设置删除。<br>（2）请求的地址没有通过内核中devmem_is_allowed函数对/dev/mem的保护。<br>（3）物理地址phy_addr计算错误。（PS：wheelz的计算方法是怎么得到的？）</p>
<p>我对上面的几个问题一一做了修改：<br>（1）修改了.config文件</p>

        <h1 id="CONFIG-STRICT-DEVMEM-is-not-set"   >
          <a href="#CONFIG-STRICT-DEVMEM-is-not-set" class="heading-link"><i class="fas fa-link"></i></a>CONFIG_STRICT_DEVMEM is not set</h1>
      <p>（２）重写arch/x86/mm/init.c下的devmem_is_allowed函数，这里我没有做太细致的修改，只是让函数一直返回1。当然这可能会存在一些问题。</p>
<p>/*</p>
<ul>
<li>devmem_is_allowed() checks to see if /dev/mem access to a certain address</li>
<li>is valid. The argument is a physical page number.</li>
<li></li>
<li></li>
<li>On x86, access has to be given to the first megabyte of ram because that area</li>
<li>contains bios code and data regions used by X and dosemu and similar apps.</li>
<li>Access has to be given to non-kernel-ram areas as well, these contain the PCI</li>
<li>mmio resources as well as potential bios/acpi data regions.</li>
<li>/<br>int devmem_is_allowed(unsigned long pagenr)<br>{<br>return 1;<pre><code>if (pagenr &lt;= 256)
        return 1;
if (iomem_is_exclusive(pagenr &lt;&lt; PAGE_SHIFT))
        return 0;
if (!page_is_ram(pagenr))
        return 1;
return 0;</code></pre>}<br>（3）修改物理地址的计算，这里我们直接使用内核中提供的转换函数virt_to_phy()或者__pa()。</li>
</ul>
<p>// 内核模块<br>#include &lt;linux/module.h&gt;<br>#include &lt;linux/kernel.h&gt;<br>#include &lt;linux/mm.h&gt;<br>MODULE_LICENSE(“GPL”);<br>MODULE_AUTHOR(“godjesse”);<br>MODULE_DESCRIPTION(“mmap demo”);<br>static unsigned long p = 0;<br>static unsigned long pp = 0;<br>static int __init init(void)<br>{<br>        p = __get_free_pages(GFP_KERNEL, 0);<br>if(!p)<br>        {<br>                printk(“Allocate memory failure!/n”);<br>        }<br>        else<br>        {<br>                SetPageReserved(virt_to_page(p));<br>// 使用virt_to_phys计算物理地址，供用户态程序使用<br>                pp = (unsigned long)virt_to_phys((void *)p);<br>                printk(“&lt;1&gt; page : pp = 0x%lx\n”,pp);<br>        }<br>        strcpy((char *)p, “Hello world !\n”);<br>        return 0;<br>}<br>static void __exit fini(void)<br>{<br>printk(“The content written by user is: %s/n”, (unsigned char *)p);<br>        ClearPageReserved(virt_to_page(p));<br>        free_pages(p, 0);<br>        printk(“ exit \n”);<br>}<br>module_init(init);<br>module_exit(fini);</p>
<hr>
<p>// 用户态程序<br>#include &lt;sys/mman.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br>//hard coding read after the module installed<br>#define KERNEL_PHY_ADDR  0x3737c000<br>int main()<br>{<br>char *buf;<br>        int fd;<br>        unsigned long phy_addr;<br>        int  pagesize = getpagesize();<br>phy_addr=KERNEL_PHY_ADDR;<br>fd=open(“/dev/mem”,O_RDWR);<br>if(fd == -1)<br>                perror(“open”);<br>buf=mmap(0, pagesize, PROT_READ|PROT_WRITE, MAP_SHARED, fd, phy_addr);<br>if(buf == MAP_FAILED)<br>        {<br>                perror(“mmap”);<br>        }<br>printf(“buf : %s\n”,buf);<br>// test the write<br>        buf[0] = ‘X’;<br>munmap(buf,pagesize);<br>        close(fd);<br>        return 0;<br>}</p>
<p> 经过这些修改后，demo可以正常工作。<br>上文中提到修改devmem_is_allowed实际上是存在问题的，存在其他一些较为优雅的方法，如某牛人写的博客：bypassing devmem_is_allowed with kernel probes，博客链接：<br><span class="exturl"><a class="exturl__link"   href="http://www.libcrack.so/2012/09/02/bypassing-devmem_is_allowed-with-kprobes/"  target="_blank" rel="noopener">http://www.libcrack.so/2012/09/02/bypassing-devmem_is_allowed-with-kprobes/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>相关资料：<br><span class="exturl"><a class="exturl__link"   href="http://stackoverflow.com/questions/11891979/accessing-mmaped-dev-mem"  target="_blank" rel="noopener">http://stackoverflow.com/questions/11891979/accessing-mmaped-dev-mem</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>
<p>From <span class="exturl"><a class="exturl__link"   href="https://www.cnblogs.com/godjesse/archive/2012/11/23/2784093.html"  target="_blank" rel="noopener">https://www.cnblogs.com/godjesse/archive/2012/11/23/2784093.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/25/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><span class="page-number current">26</span><a class="page-number" href="/page/27/">27</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="extend next" rel="next" href="/page/27/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/stun-logo.svg" alt="avatar"></div><p class="sidebar-ov-author__text">Kung-Fu-Master</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://plus.google.com/" target="_blank" rel="noopener" data-popover="Google" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-google"></i></span></a><a class="sidebar-ov-social-item" href="https://twitter.com/" target="_blank" rel="noopener" data-popover="Twitter" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-twitter"></i></span></a><a class="sidebar-ov-social-item" href="https://youtube.com/" target="_blank" rel="noopener" data-popover="Youtube" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-youtube"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">292</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">40</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">12</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Kung-Fu-Master</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v4.2.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.1</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="/js/utils.js?v=2.6.1"></script><script src="/js/stun-boot.js?v=2.6.1"></script><script src="/js/scroll.js?v=2.6.1"></script><script src="/js/header.js?v=2.6.1"></script><script src="/js/sidebar.js?v=2.6.1"></script><script type="application/json" src="/search.json"></script></body></html>