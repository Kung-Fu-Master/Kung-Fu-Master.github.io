<!-- build time:Wed Jun 02 2021 18:25:41 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Hexo" href="https://kung-fu-master.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Hexo" href="https://kung-fu-master.github.io/atom.xml"><link rel="alternate" type="application/json" title="Hexo" href="https://kung-fu-master.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="kubernetes"><link rel="canonical" href="https://kung-fu-master.github.io/2021/03/13/microService/kubernetes/03_kubernetes_ns_pod/"><title>03 Kubernetes nodes, namespace, pod - kubernetes - microService | Kung Fu Master = Hexo</title><meta name="generator" content="Hexo 4.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">03 Kubernetes nodes, namespace, pod</h1><div class="meta"><span class="item" title="创建时间：2021-03-13 13:00:42"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-03-13T13:00:42+08:00">2021-03-13</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>29k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>27 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Kung Fu Master</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipey0a334j20zk0m8qpt.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipesng5oej20zk0m87d4.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclize41wj20zk0m87gk.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclg5ms2rj20zk0m8u0x.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclh3brzpj20zk0m8ann.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipeuv80yoj20zk0m8kjl.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/microService/" itemprop="item" rel="index" title="分类于 microService"><span itemprop="name">microService</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/microService/kubernetes/" itemprop="item" rel="index" title="分类于 kubernetes"><span itemprop="name">kubernetes</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://kung-fu-master.github.io/2021/03/13/microService/kubernetes/03_kubernetes_ns_pod/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Kung-Fu-Master"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hexo"></span><div class="body md" itemprop="articleBody"><h2 id="nodes"><a class="anchor" href="#nodes">#</a> nodes</h2><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get nodes -o wide</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME         STATUS   ROLES    AGE   VERSION   INTERNAL-IP     EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION           CONTAINER-RUNTIME</pre></td></tr><tr><td data-num="3"></td><td><pre>	hci-node01   Ready    master   5d    v1.18.1   <span class="token number">10.67</span>.108.211   <span class="token operator">&lt;</span>none<span class="token operator">></span>        CentOS Linux <span class="token number">7</span> <span class="token punctuation">(</span>Core<span class="token punctuation">)</span>   <span class="token number">3.10</span>.0-1062.el7.x86_64   docker://19.3.8</pre></td></tr><tr><td data-num="4"></td><td><pre>	hci-node02   Ready    <span class="token operator">&lt;</span>none<span class="token operator">></span>   5d    v1.18.1   <span class="token number">10.67</span>.109.142   <span class="token operator">&lt;</span>none<span class="token operator">></span>        CentOS Linux <span class="token number">7</span> <span class="token punctuation">(</span>Core<span class="token punctuation">)</span>   <span class="token number">3.10</span>.0-1062.el7.x86_64   docker://19.3.8</pre></td></tr><tr><td data-num="5"></td><td><pre>	hci-node03   Ready    <span class="token operator">&lt;</span>none<span class="token operator">></span>   5d    v1.18.1   <span class="token number">10.67</span>.109.147   <span class="token operator">&lt;</span>none<span class="token operator">></span>        CentOS Linux <span class="token number">7</span> <span class="token punctuation">(</span>Core<span class="token punctuation">)</span>   <span class="token number">3.10</span>.0-1062.el7.x86_64   docker://19.3.8</pre></td></tr><tr><td data-num="6"></td><td><pre>	hci-node04   Ready    <span class="token operator">&lt;</span>none<span class="token operator">></span>   5d    v1.18.1   <span class="token number">10.67</span>.109.144   <span class="token operator">&lt;</span>none<span class="token operator">></span>        CentOS Linux <span class="token number">7</span> <span class="token punctuation">(</span>Core<span class="token punctuation">)</span>   <span class="token number">3.10</span>.0-1062.el7.x86_64   docker://19.3.8</pre></td></tr><tr><td data-num="7"></td><td><pre>	$ kubectl describe node hci-node02</pre></td></tr><tr><td data-num="8"></td><td><pre>	输出显示了节点的状态、 CPU 和内存数据、系统信息、运行容器的节点等</pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>	查看某台机器的资源</pre></td></tr><tr><td data-num="11"></td><td><pre>	$ kubectl describe node hci-node01</pre></td></tr></table></figure><h3 id="创建别名和补全"><a class="anchor" href="#创建别名和补全">#</a> 创建别名和补全</h3><p>kubectl 会被经常使用。很快你就会发现每次不得不打全命令是非常痛苦的。<br>将下面的代码添加到～/.bashrc 或类似的文件中 ：</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ <span class="token builtin class-name">alias</span> <span class="token assign-left variable">k</span><span class="token operator">=</span>kubectl</pre></td></tr></table></figure><p>为 kuebctl 配置 tab 补全<br>需要先安装一个叫作 bashcompletio 口的包来启用 bash 中的 tab 命令补全， 然后可以运行接下来的命令（也需要加到～/.bashrc 或类似的文件中）</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ <span class="token builtin class-name">source</span> <span class="token operator">&lt;</span><span class="token punctuation">&#123;</span>kubectl completion <span class="token function">bash</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	$ kubectl desc<span class="token operator">&lt;</span>TAB<span class="token operator">></span> nod<span class="token operator">&lt;</span>TAB<span class="token operator">></span> hci<span class="token operator">&lt;</span>TAB<span class="token operator">></span></pre></td></tr></table></figure><p>但是需要注意的是， tab 命令行补全只在使用完整的 kubectl 命令时会起作用，(当使用别名 k 时不会起作用). 需要改变 kubectl completion 的输出来修复：</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ <span class="token builtin class-name">source</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span>kubectl completion <span class="token function">bash</span> <span class="token operator">|</span> <span class="token function">sed</span> s/kubectl/k/g<span class="token punctuation">)</span></pre></td></tr></table></figure><h3 id="node-标签"><a class="anchor" href="#node-标签">#</a> node 标签</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get nodes</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ kubectl label node server02 <span class="token assign-left variable">gpu</span><span class="token operator">=</span>false</pre></td></tr><tr><td data-num="3"></td><td><pre>	$ kubectl label node server02 <span class="token assign-left variable">gpu</span><span class="token operator">=</span>true --overwrite	//修改node标签</pre></td></tr><tr><td data-num="4"></td><td><pre>	$ kubectl get node -L gpu		// 列出所有node，并添加GPU一列进行展示</pre></td></tr><tr><td data-num="5"></td><td><pre>	$ kubectl get node -l gpu		// 只列出含标签的key为gpu的node</pre></td></tr><tr><td data-num="6"></td><td><pre>	$ kubectl get node -l <span class="token assign-left variable">gpu</span><span class="token operator">=</span>false	// 只列出含gpu<span class="token operator">=</span>false的node</pre></td></tr></table></figure><p>将 POD 调度到指定的 node 上: kubia-gpu.yaml</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apiVersion: v1</pre></td></tr><tr><td data-num="2"></td><td><pre>	kind: Pod</pre></td></tr><tr><td data-num="3"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="4"></td><td><pre>	name: kubia-gpu		// 指定生成的POD名字</pre></td></tr><tr><td data-num="5"></td><td><pre>	spec:</pre></td></tr><tr><td data-num="6"></td><td><pre>	nodeSelector:		// node选择器,选择含标签gpu=true的node机器</pre></td></tr><tr><td data-num="7"></td><td><pre>		gpu: "true"		</pre></td></tr><tr><td data-num="8"></td><td><pre>	containers:</pre></td></tr><tr><td data-num="9"></td><td><pre>	- image: luksa/kubia	// 要拉取的 image 名字</pre></td></tr><tr><td data-num="10"></td><td><pre>		name: kubia			// 生成的 container 名字</pre></td></tr></table></figure><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl create -f kubia-gpu.yaml</pre></td></tr></table></figure><p>如果没有标签为 gpu=true 的合适 node， 通过 $ kubectl describe pod/kubia-nogpu 查看 Message， 会报 0/2 nodes are available: 2 node (s) didn't match node selector. 信息</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl describe pod/kubia-gpu</pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	Node-Selectors:  <span class="token assign-left variable">gpu</span><span class="token operator">=</span>true</pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span></pre></td></tr></table></figure><h3 id="taint污点"><a class="anchor" href="#taint污点">#</a> taint 污点</h3><p>给 Node 添加污点可以让配置 tolerations 的 Pod 部署上来，而不让平常的 Pod 部署.<br>配置 tolerations 的 Pod 可以部署到添加污点的机器也可以部署到其它平常机器</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>// 查看node机器污点</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ kubectl describe node/<span class="token operator">&lt;</span>Node-Name<span class="token operator">></span> <span class="token operator">|</span> <span class="token function">grep</span> Taint</pre></td></tr><tr><td data-num="3"></td><td><pre>	  Taints:             node-role.kubernetes.io/master:NoSchedule</pre></td></tr><tr><td data-num="4"></td><td><pre>	// 去掉污点</pre></td></tr><tr><td data-num="5"></td><td><pre>	$  kubectl taint nodes <span class="token operator">&lt;</span>Node-Name<span class="token operator">></span> node-role.kubernetes.io/master:NoSchedule-</pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>	$ kubectl taint nodes NodeName <span class="token assign-left variable">gpu</span><span class="token operator">=</span>true:NoSchedule</pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>	apiVersion: apps/v1</pre></td></tr><tr><td data-num="10"></td><td><pre>	kind: Deployment</pre></td></tr><tr><td data-num="11"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="12"></td><td><pre>	  name: web-demo</pre></td></tr><tr><td data-num="13"></td><td><pre>	  namespace: dev</pre></td></tr><tr><td data-num="14"></td><td><pre>	spec:</pre></td></tr><tr><td data-num="15"></td><td><pre>	  selector:</pre></td></tr><tr><td data-num="16"></td><td><pre>	    matchLabels:</pre></td></tr><tr><td data-num="17"></td><td><pre>	      app: web-demo</pre></td></tr><tr><td data-num="18"></td><td><pre>	  replicas: <span class="token number">3</span>			// 副本数3来测试能部署到哪些机器</pre></td></tr><tr><td data-num="19"></td><td><pre>	  template:</pre></td></tr><tr><td data-num="20"></td><td><pre>	    metadata:</pre></td></tr><tr><td data-num="21"></td><td><pre>	      labels:</pre></td></tr><tr><td data-num="22"></td><td><pre>	        app: web-demo</pre></td></tr><tr><td data-num="23"></td><td><pre>	    spec:</pre></td></tr><tr><td data-num="24"></td><td><pre>	      selector:</pre></td></tr><tr><td data-num="25"></td><td><pre>	        matchLabels:</pre></td></tr><tr><td data-num="26"></td><td><pre>	          app: web-demo</pre></td></tr><tr><td data-num="27"></td><td><pre>	      replicas: <span class="token number">1</span></pre></td></tr><tr><td data-num="28"></td><td><pre>	      template:</pre></td></tr><tr><td data-num="29"></td><td><pre>	        metadata:</pre></td></tr><tr><td data-num="30"></td><td><pre>	          labels:</pre></td></tr><tr><td data-num="31"></td><td><pre>	            app: web-demo</pre></td></tr><tr><td data-num="32"></td><td><pre>	        spec:</pre></td></tr><tr><td data-num="33"></td><td><pre>	          containers:</pre></td></tr><tr><td data-num="34"></td><td><pre>	          - name: web-demo</pre></td></tr><tr><td data-num="35"></td><td><pre>	            image: hub.mooc.com/kubernetes/web:v1</pre></td></tr><tr><td data-num="36"></td><td><pre>	            ports:</pre></td></tr><tr><td data-num="37"></td><td><pre>	            - containerPort: <span class="token number">8080</span></pre></td></tr><tr><td data-num="38"></td><td><pre>	          tolerations:		// 可以部署到有设置taint的机器，也可以部署到其它机器</pre></td></tr><tr><td data-num="39"></td><td><pre>	          - key: <span class="token string">"gpu"</span></pre></td></tr><tr><td data-num="40"></td><td><pre>	            operator: <span class="token string">"Equal"</span></pre></td></tr><tr><td data-num="41"></td><td><pre>	            value: <span class="token string">"true"</span></pre></td></tr><tr><td data-num="42"></td><td><pre>	            effect: <span class="token string">"NoSchedule"</span></pre></td></tr></table></figure><blockquote><p>典型的使用 kubeadm 部署和初始化的 Kubernetes 集群，<span class="exturl" data-url="aHR0cDovL3huLS1tYXN0ZXJub2RlLXJvbGUtNWUzeG91dzVjeTc3N2FwcXBjMHJuazQ1YWcxby5rdWJlcm5ldGVzLmlvL21hc3RlcjpOb1NjaGVkdWxlJUU3JTlBJTg0JUU2JUIxJUExJUU3JTgyJUI5JUVGJUJDJThDJUU1JThGJUFGJUU0JUJCJUE1JUU0JUJEJUJGJUU3JTk0JUE4a3ViZWN0bA==">master 节点被设置了一个 node-role.kubernetes.io/master:NoSchedule 的污点，可以使用 kubectl</span> describe node &lt;node-name&gt; 命令查看<br>这个污点表示默认情况下 master 节点将不会调度运行 Pod，即不运行工作负载，对于使用二进制手动部署的集群设置和移除这个污点的命令如下:</p></blockquote><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl taint nodes <span class="token operator">&lt;</span>node-name<span class="token operator">></span> node-role.kubernetes.io/master<span class="token operator">=</span>:NoSchedule</pre></td></tr><tr><td data-num="2"></td><td><pre>$ kubectl taint nodes <span class="token operator">&lt;</span>node-name<span class="token operator">></span> node-role.kubernetes.io/master:NoSchedule-</pre></td></tr></table></figure><blockquote><p>kubeadm 初始化的 Kubernetes 集群，<span class="exturl" data-url="aHR0cDovL3huLS1tYXN0ZXJub2RlLXJvbGUtNWUzeDNlMXdtNWFsd3AwNDRhNGcyYzdxOGRwNTRhLmt1YmVybmV0ZXMuaW8vbWFzdGVyPSVFNyU5QSU4NGxhYmVsJUVGJUJDJThDJUU2JUEwJTg3JUU4JUFGJTg2JUU4JUJGJTk5JUU0JUI4JUFBJUU4JThBJTgyJUU3JTgyJUI5JUU3JTlBJTg0JUU4JUE3JTkyJUU4JTg5JUIyJUU0JUI4JUJBbWFzdGVyJUUzJTgwJTgyJUU3JUJCJTk5Tm9kZSVFOCVBRSVCRSVFNyVCRCVBRUxhYmVsJUU1JTkyJThDJUU4JUFFJUJFJUU3JUJEJUFFJUU2JUIxJUExJUU3JTgyJUI5JUU2JTk4JUFGJUU0JUI4JUE0JUU0JUI4JUFBJUU0JUI4JThEJUU1JTkwJThDJUU3JTlBJTg0JUU2JTkzJThEJUU0JUJEJTlDJUUzJTgwJTgyJUU4JUFFJUJFJUU3JUJEJUFFTGFiZWwlRTUlOTIlOEMlRTclQTclQkIlRTklOTklQTRMYWJlbCVFNyU5QSU4NCVFNiU5MyU4RCVFNCVCRCU5QyVFNSU5MSVCRCVFNCVCQiVBNCVFNSVBNiU4MiVFNCVCOCU4Qg==">master 节点也被打上了一个 node-role.kubernetes.io/master = 的 label，标识这个节点的角色为 master。给 Node 设置 Label 和设置污点是两个不同的操作。设置 Label 和移除 Label 的操作命令如下</span></p></blockquote><p>设置 Label</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl label node node1 node-role.kubernetes.io/master<span class="token operator">=</span></pre></td></tr></table></figure><p>移除 Label</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl label node node1 node-role.kubernetes.io/master-</pre></td></tr></table></figure><h2 id="namespace"><a class="anchor" href="#namespace">#</a> Namespace</h2><blockquote><p>大多数对象的名称必须符合 RFC 1035 （域名）中规定的命名规范 ，这意味着它们可能只包含字母、数字、横杠（－）和点号，但命名空间（和另外几个）不允许包含点号</p></blockquote><h3 id="隔离性"><a class="anchor" href="#隔离性">#</a> 隔离性</h3><blockquote><p>名字的隔离只是 通过 svc 名称 (DNS) 访问的隔离，通过 svc 的 IP 和 Pod 的 IP 再加上端口号 (Port) 照样可以访问不同命名空间下的服务.</p></blockquote><h3 id="设置默认命名空间"><a class="anchor" href="#设置默认命名空间">#</a> 设置默认命名空间</h3><blockquote><p>默认 Kubeclt 获取 default 命名空间下的资源，可以通过设置 K8s 上下文配置文件如 kube.config 使得某个命名空间变为默认 namespace，获取 pod 时候不需要在加上 -n 参数</p></blockquote><h3 id="创建命名空间"><a class="anchor" href="#创建命名空间">#</a> 创建命名空间</h3><blockquote><p>namespace 不提供网络隔离，如果命名空间 foo 中的某个 pod 知道命名空间 bar 中 pod 的 IP 地址，那它就可以将流量（例如 HTTP 请求）发送到另一个 pod<br>第一种： commands 方式</p></blockquote><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl create namespace custom-namespace</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ kubectl create ns custom-namespace</pre></td></tr></table></figure><p>第二种： Yaml 方式， 之所以选择使用 YAML 文件，只是为了强化 Kubemetes 中的所有内容都是一 个 API 对象这一概念</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ <span class="token function">touch</span> custom-namespace.yaml</pre></td></tr><tr><td data-num="2"></td><td><pre>	apiVersion: v1</pre></td></tr><tr><td data-num="3"></td><td><pre>	kind: Namespace</pre></td></tr><tr><td data-num="4"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="5"></td><td><pre>	  name: custom-namespace</pre></td></tr><tr><td data-num="6"></td><td><pre>	$ kubectl create -f custom-namespace.yaml</pre></td></tr></table></figure><h3 id="划分方式"><a class="anchor" href="#划分方式">#</a> 划分方式</h3><pre><code>* 按环境划分: dev(开发), test(测试)
* 按团队划分
* 自定义多级划分
</code></pre><h3 id="标记命名空间"><a class="anchor" href="#标记命名空间">#</a> 标记命名空间</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl label namespace default istio-injection<span class="token operator">=</span>enabled --overwrite         // enabled</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ kubectl label namespace default istio-injection<span class="token operator">=</span>disabled --overwrite        // disabled</pre></td></tr><tr><td data-num="3"></td><td><pre>	$ kubectl label namespace default istio-injection<span class="token operator">=</span> --overwrite                // cancel <span class="token builtin class-name">set</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	namespace/default labeled</pre></td></tr></table></figure><h3 id="查看标记-istio-injectionenabled-标签的命名空间"><a class="anchor" href="#查看标记-istio-injectionenabled-标签的命名空间">#</a> 查看标记 istio-injection=enabled 标签的命名空间</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get namespace -L istio-injection</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME              STATUS   AGE   ISTIO-INJECTION</pre></td></tr><tr><td data-num="3"></td><td><pre>	default           Active   85m   enabled</pre></td></tr><tr><td data-num="4"></td><td><pre>	istio-system      Active   25m   disabled</pre></td></tr><tr><td data-num="5"></td><td><pre>	kube-node-lease   Active   85m</pre></td></tr><tr><td data-num="6"></td><td><pre>	kube-public       Active   85m</pre></td></tr><tr><td data-num="7"></td><td><pre>	kube-system       Active   85m</pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token punctuation">[</span>root@hci-node01 istio-1.5.2<span class="token punctuation">]</span><span class="token comment">#</span></pre></td></tr></table></figure><h3 id="删除namespace"><a class="anchor" href="#删除namespace">#</a> 删除 namespace</h3><p>删除当前命名空间中的所有资源，可以删除 ReplicationCcontroller 和 pod, 以及我们创建的所有 service<br>第一个 all 指定正在删除所有资源类型，--all 选项指定将删除所有资源实例，而不是按名称指定它们<br>使用 all 关键字删除所有内容并不是真的完全删除所有内容。 一些资源比如 Secret 会被保留下来， 并且需要被明确指定删除</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl delete all --all		// 命令也会删除名为 kubernetes 的Service, 但它应该会在几分钟后自动重新创建</pre></td></tr></table></figure><p>可以简单地删除整个命名空间（ pod 将会伴随命名空间 自动删除〉</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl delete ns custom-namespace</pre></td></tr></table></figure><p>强制删除 NAMESPACE</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl delete namespace NAMESPACENAME --force --grace-period<span class="token operator">=</span><span class="token number">0</span></pre></td></tr></table></figure><p>进入 kube-system 下得 etcd pod 删除需要删除的 NAMESPACE</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get po -n kube-system</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME                                 READY   STATUS    RESTARTS   AGE</pre></td></tr><tr><td data-num="3"></td><td><pre>	etcd-hci-node01                      <span class="token number">1</span>/1     Running   <span class="token number">5</span>          16d</pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	</pre></td></tr><tr><td data-num="6"></td><td><pre>	$ kubectl <span class="token builtin class-name">exec</span> -it etcd-hci-node01 <span class="token function">sh</span> -n kube-system</pre></td></tr><tr><td data-num="7"></td><td><pre>	$ etcdctl del /registry/namespaces/NAMESPACENAME</pre></td></tr></table></figure><h2 id="pod"><a class="anchor" href="#pod">#</a> POD</h2><h3 id="查看pod解释"><a class="anchor" href="#查看pod解释">#</a> 查看 pod 解释</h3><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl explain pod</pre></td></tr><tr><td data-num="2"></td><td><pre>	KIND:     Pod</pre></td></tr><tr><td data-num="3"></td><td><pre>	VERSION:  v1</pre></td></tr><tr><td data-num="4"></td><td><pre>	</pre></td></tr><tr><td data-num="5"></td><td><pre>	DESCRIPTION:</pre></td></tr><tr><td data-num="6"></td><td><pre>		Pod is a collection of containers that can run on a host. This resource is</pre></td></tr><tr><td data-num="7"></td><td><pre>		created by clients and scheduled onto hosts.</pre></td></tr><tr><td data-num="8"></td><td><pre>	</pre></td></tr><tr><td data-num="9"></td><td><pre>	FIELDS:</pre></td></tr><tr><td data-num="10"></td><td><pre>	apiVersion   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="11"></td><td><pre>		APIVersion defines the versioned schema of this representation of an</pre></td></tr><tr><td data-num="12"></td><td><pre>		object. Servers should convert recognized schemas to the latest internal</pre></td></tr><tr><td data-num="13"></td><td><pre>		value, and may reject unrecognized values. More info:</pre></td></tr><tr><td data-num="14"></td><td><pre>		https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources</pre></td></tr><tr><td data-num="15"></td><td><pre>	</pre></td></tr><tr><td data-num="16"></td><td><pre>	kind <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="17"></td><td><pre>		Kind is a string value representing the REST resource this object</pre></td></tr><tr><td data-num="18"></td><td><pre>		represents. Servers may infer this from the endpoint the client submits</pre></td></tr><tr><td data-num="19"></td><td><pre>		requests to. Cannot be updated. In CamelCase. More info:</pre></td></tr><tr><td data-num="20"></td><td><pre>		https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</pre></td></tr><tr><td data-num="21"></td><td><pre>	</pre></td></tr><tr><td data-num="22"></td><td><pre>	metadata     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Object</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="23"></td><td><pre>		Standard object's metadata. More info:</pre></td></tr><tr><td data-num="24"></td><td><pre>		https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata</pre></td></tr><tr><td data-num="25"></td><td><pre>	</pre></td></tr><tr><td data-num="26"></td><td><pre>	spec <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Object</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="27"></td><td><pre>		Specification of the desired behavior of the pod. More info:</pre></td></tr><tr><td data-num="28"></td><td><pre>		https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status</pre></td></tr><tr><td data-num="29"></td><td><pre>	</pre></td></tr><tr><td data-num="30"></td><td><pre>	status       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Object</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="31"></td><td><pre>		Most recently observed status of the pod. This data may not be up to date.</pre></td></tr><tr><td data-num="32"></td><td><pre>		Populated by the system. Read-only. More info:</pre></td></tr><tr><td data-num="33"></td><td><pre>		https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status</pre></td></tr></table></figure><p>深入理解 POD 属性</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl explain pod.apiVersion</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ kubectl explain pod.kind</pre></td></tr><tr><td data-num="3"></td><td><pre>	$ kubectl explain pod.spec</pre></td></tr></table></figure><p>pods 的缩写是 po, service 的缩写是 SVC, replicationcontroller 的缩写 rc</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get pods -n kube-system</pre></td></tr></table></figure><blockquote><p>我们提到过每个 pod 都有自己的 IP 地址，但是这个地址是集群 内部的，不能从集群外部访问。<br>要让 pod 能够从外部访问 ， 需要通过服务对象公开它， 要创建一个特殊的 LoadBalancer 类型的服务。<br>因为如果你创建一个常规服务（ 一个 Cluster IP 服务）， 比如 pod ，它也 只能从集群内部访问。<br>通过创建 LoadBalanc er 类型 的服务，将创建一个外部的负载均衡 ，可以通过 负载均衡的公共 IP 访问 pod</p></blockquote><h3 id="创建pod"><a class="anchor" href="#创建pod">#</a> 创建 POD</h3><p>通过上传 JSON 或 YAML 描述文件到 Kubemetes API 服务器来创建 pod.<br>kubectl create -f 命令用于从 YAML 或 JSON 文件创建任何资源（不只是 pod).</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl create -f kubia-manual.yaml</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ kubectl create -f kubia-gpu.yaml -n custom-namespace	//创建pod到custom-namespace命名空间下</pre></td></tr><tr><td data-num="3"></td><td><pre>	$ kubectl describe pod/kubia</pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	Events:</pre></td></tr><tr><td data-num="6"></td><td><pre>	Type    Reason     Age    From               Message</pre></td></tr><tr><td data-num="7"></td><td><pre>	----    ------     ----   ----               -------</pre></td></tr><tr><td data-num="8"></td><td><pre>	Normal  Scheduled  5m12s  default-scheduler  Successfully assigned default/kubia-liveness to server02</pre></td></tr><tr><td data-num="9"></td><td><pre>	Normal  Pulling    5m8s   kubelet, server02  Pulling image <span class="token string">"luksa/kubia-unhealthy"</span></pre></td></tr></table></figure><p>编写好 yaml 文件在本地某个目录后，cd 到此目录，用一条 command 全部创建或删除资源</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl apply -f <span class="token builtin class-name">.</span>	// 添加所有资源</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ kubectl delete -f <span class="token builtin class-name">.</span>	// 删除所有资源</pre></td></tr></table></figure><h3 id="一直查看pod状态"><a class="anchor" href="#一直查看pod状态">#</a> 一直查看 pod 状态</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get pods -w</pre></td></tr></table></figure><h3 id="pod标签labels"><a class="anchor" href="#pod标签labels">#</a> pod 标签 labels</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get po --show-labels</pre></td></tr></table></figure><p>查看 pod 标签的 key 值为 creation_method 和 env 的信息</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get po -L creation_method,env</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME                           READY   STATUS    RESTARTS   AGE   CREATION_METHOD   ENV</pre></td></tr><tr><td data-num="3"></td><td><pre>	kubia                          <span class="token number">1</span>/1     Running   <span class="token number">0</span>          16h</pre></td></tr><tr><td data-num="4"></td><td><pre>	kubia-manual-v2                <span class="token number">1</span>/1     Running   <span class="token number">0</span>          34m   manual            pod</pre></td></tr></table></figure><p>POD 添加标签</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl label po kubia  <span class="token assign-left variable">creation_method</span><span class="token operator">=</span>manual</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME                           READY   STATUS    RESTARTS   AGE   CREATION_METHOD   ENV</pre></td></tr><tr><td data-num="3"></td><td><pre>	kubia                          <span class="token number">1</span>/1     Running   <span class="token number">0</span>          16h   manual</pre></td></tr><tr><td data-num="4"></td><td><pre>	kubia-manual-v2                <span class="token number">1</span>/1     Running   <span class="token number">0</span>          43m   manual            pod</pre></td></tr></table></figure><p>更改现有标签，在更改现有标签时， 需要使用 --overwrite 选项</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl label po kubia-manual-v2 <span class="token assign-left variable">env</span><span class="token operator">=</span>debug --overwrite</pre></td></tr></table></figure><p>使用标签列出 POD</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get po -1 <span class="token assign-left variable">creation_method</span><span class="token operator">=</span>manual</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ kubectl get po -l <span class="token function">env</span></pre></td></tr></table></figure><p>同样列出没有 env 标签的 pod<br>确保使用单引号来圈引！env, 这样 bash shell 才不会解释感叹号（译者注：感叹号在 bash 中有特殊含义， 表示事件指示器)</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get po -l <span class="token string">'!env'</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	creation_method<span class="token operator">!=</span>manual 选择带有creation_method标签， 并且值不等于manual的pod</pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token function">env</span> <span class="token keyword">in</span> <span class="token punctuation">(</span>prod, devel<span class="token punctuation">)</span>选择带有env标签且值为prod或devel的pod</pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token function">env</span> notin <span class="token punctuation">(</span>prod, devel<span class="token punctuation">)</span>选择带有env标签， 但其 值不是prod或devel的pod</pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token assign-left variable">app</span><span class="token operator">=</span>pc,rel<span class="token operator">=</span>beta 选择pc微服务的beta版本pod</pre></td></tr></table></figure><h3 id="pod-注解"><a class="anchor" href="#pod-注解">#</a> pod 注解</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl annotate pod kubia-gpu mycompany.com/someannotion<span class="token operator">=</span><span class="token string">"foo bar"</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	$ kubectl describe pod/kubia-gpu</pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	Annotations:  mycompany.com/someannotion: foo bar</pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span></pre></td></tr></table></figure><h3 id="查看该-pod-的完整描述文件"><a class="anchor" href="#查看该-pod-的完整描述文件">#</a> 查看该 pod 的完整描述文件：</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get po kubia-manual -o yaml	// 获取yaml格式信息</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ kubect1 get po kubia-manual -o json	// 获取json格式信息</pre></td></tr></table></figure><h3 id="执行pod容器"><a class="anchor" href="#执行pod容器">#</a> 执行 pod 容器</h3><p>直接执行:</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl <span class="token builtin class-name">exec</span> fortioclient-f8d65c6bb-5k4td -c captured <span class="token function">date</span> -n twopods</pre></td></tr></table></figure><p>进入容器执行，当 pod 中只有一个容器时可以不加 - c 参数指定某个容器</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl <span class="token builtin class-name">exec</span> fortioclient-f8d65c6bb-5k4td -c captured -i -t /bin/sh -n twopods</pre></td></tr></table></figure><h3 id="容器进程-网络等"><a class="anchor" href="#容器进程-网络等">#</a> 容器进程，网络等</h3><p>查看进程 command 完整信息</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ <span class="token function">ps</span> auxwww</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ pa -ef</pre></td></tr></table></figure><p>查看网络</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ <span class="token function">netstat</span> -ntlp</pre></td></tr></table></figure><h3 id="查看pod-svc日志"><a class="anchor" href="#查看pod-svc日志">#</a> 查看 Pod, svc 日志</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl logs pod/istiod-774777b79-ddfk4 -n istio-system</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ kubectl logs -f pod/<span class="token operator">&lt;</span>pod_name<span class="token operator">></span> <span class="token comment">#类似 tail -f 的方式查看 (tail -f 实时查看日志文件 tail -f 日志文件 log)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	$ kubectl logs svc/istiod -n istio-system</pre></td></tr><tr><td data-num="4"></td><td><pre>	如果该pod中有其他容器， 可以通过如下命令获取其日志：</pre></td></tr><tr><td data-num="5"></td><td><pre>	$ kubectl logs kubia-manual -c kubia</pre></td></tr></table></figure><p>查看容器重启后前一个容器为什么重启的日志信息</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl logs mypod --previous</pre></td></tr></table></figure><h3 id="部署应用程序"><a class="anchor" href="#部署应用程序">#</a> 部署应用程序</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml</pre></td></tr></table></figure><h3 id="重启pod"><a class="anchor" href="#重启pod">#</a> 重启 Pod</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get pod <span class="token punctuation">&#123;</span>podname<span class="token punctuation">&#125;</span> -n <span class="token punctuation">&#123;</span>namespace<span class="token punctuation">&#125;</span> -o yaml <span class="token operator">|</span> kubectl replace --force -f -</pre></td></tr></table></figure><h3 id="删除pod"><a class="anchor" href="#删除pod">#</a> 删除 Pod</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl delete pod PODNAME -n custom-namespace		// 删除指定命名空间下的POD</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ kubectl delete po -l <span class="token assign-left variable">creation_method</span><span class="token operator">=</span>manual			// 通过标签选择器来删除</pre></td></tr><tr><td data-num="3"></td><td><pre>	$ kubectl delete po --all -n custom-namespace			// 删除当前命名空间中的所有 pod</pre></td></tr><tr><td data-num="4"></td><td><pre>	$ kubectl delete all --all -n custom-namespace			// 删除所有pod和svc，系统带的kubernetes服务会过一会重启</pre></td></tr></table></figure><p>可使用 kubectl 中的强制删除命令删除 POD</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl delete pod PODNAME --force --grace-period<span class="token operator">=</span><span class="token number">0</span></pre></td></tr></table></figure><p>直接从 ETCD 中删除源数据<br>删除 default namespace 下的 pod 名为 pod-to-be-deleted-0</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ <span class="token assign-left variable">ETCDCTL_API</span><span class="token operator">=</span><span class="token number">3</span> etcdctl del /registry/pods/default/pod-to-be-deleted-0</pre></td></tr></table></figure><h2 id="livenessprobe-存活探针-readinessprobe"><a class="anchor" href="#livenessprobe-存活探针-readinessprobe">#</a> livenessProbe 存活探针，readinessProbe</h2><p>Kubemetes 可以通过存活探针 (liveness probe) 检查容器是否还在运行.<br>Kubemetes 可以通过 readinessProbe 探针 检查容器是否准备完毕可以挂到负载均衡上供外部访问.<br>livenessProbe 与 readinessProbe 探针用法完全一样，都有三种，下面介绍这三种健康检查方式.</p><p>可以为 pod 中的每个容器单独指定存活探针。 如果探测失败， Kubemetes 将定期执行探针并重新启动容器</p><ul><li>第一种健康检查方式：执行命令检查存活探针是否存活</li></ul><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apiVersion: apps/v1</pre></td></tr><tr><td data-num="2"></td><td><pre>	kind: Deployment</pre></td></tr><tr><td data-num="3"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="4"></td><td><pre>	  name: web-demo</pre></td></tr><tr><td data-num="5"></td><td><pre>	  namespace: dev</pre></td></tr><tr><td data-num="6"></td><td><pre>	spec:</pre></td></tr><tr><td data-num="7"></td><td><pre>	  selector:</pre></td></tr><tr><td data-num="8"></td><td><pre>	    matchLabels:</pre></td></tr><tr><td data-num="9"></td><td><pre>	      app: web-demo</pre></td></tr><tr><td data-num="10"></td><td><pre>	  replicas: 1</pre></td></tr><tr><td data-num="11"></td><td><pre>	  template:</pre></td></tr><tr><td data-num="12"></td><td><pre>	    metadata:</pre></td></tr><tr><td data-num="13"></td><td><pre>	      labels:</pre></td></tr><tr><td data-num="14"></td><td><pre>	        app: web-demo</pre></td></tr><tr><td data-num="15"></td><td><pre>	    spec:</pre></td></tr><tr><td data-num="16"></td><td><pre>	      selector:</pre></td></tr><tr><td data-num="17"></td><td><pre>	        matchLabels:</pre></td></tr><tr><td data-num="18"></td><td><pre>	          app: web-demo</pre></td></tr><tr><td data-num="19"></td><td><pre>	      replicas: 1</pre></td></tr><tr><td data-num="20"></td><td><pre>	      template:</pre></td></tr><tr><td data-num="21"></td><td><pre>	        metadata:</pre></td></tr><tr><td data-num="22"></td><td><pre>	          labels:</pre></td></tr><tr><td data-num="23"></td><td><pre>	            app: web-demo</pre></td></tr><tr><td data-num="24"></td><td><pre>	        spec:</pre></td></tr><tr><td data-num="25"></td><td><pre>	          containers:</pre></td></tr><tr><td data-num="26"></td><td><pre>	          - name: web-demo</pre></td></tr><tr><td data-num="27"></td><td><pre>	            image: hub.mooc.com/kubernetes/web:v1</pre></td></tr><tr><td data-num="28"></td><td><pre>	            ports:</pre></td></tr><tr><td data-num="29"></td><td><pre>	            - containerPort: 8080</pre></td></tr><tr><td data-num="30"></td><td><pre>	            livenessProbe:				// 检查应用是否存活的探针, 和容器一个级别</pre></td></tr><tr><td data-num="31"></td><td><pre>	              exec:						// 第一种健康检查方式, 通过执行命令</pre></td></tr><tr><td data-num="32"></td><td><pre>	                command:</pre></td></tr><tr><td data-num="33"></td><td><pre>	                - /bin/sh</pre></td></tr><tr><td data-num="34"></td><td><pre>	                - -c</pre></td></tr><tr><td data-num="35"></td><td><pre>	                - ps -ef|grep java|grep -v grep</pre></td></tr><tr><td data-num="36"></td><td><pre>	              initialDelaySeconds: 10		// 容器起来后过10s开始检查</pre></td></tr><tr><td data-num="37"></td><td><pre>	              periodSeconds: 10				// 每隔10s检查一次</pre></td></tr><tr><td data-num="38"></td><td><pre>	              failureThreshold: 2			// 连续健康检查失败2次放弃检查, 重启容器</pre></td></tr><tr><td data-num="39"></td><td><pre>	              successThreshold: 1			// 检查一次满足条件就认为健康检查通过</pre></td></tr><tr><td data-num="40"></td><td><pre>	              timeoutSeconds: 5				// 每次健康检查delay时间是5s, 超时也认为健康检查失败, 重启容器</pre></td></tr><tr><td data-num="41"></td><td><pre>	            readinessProbe:				// readinessProbe与livenessProbe用法完全一样.</pre></td></tr><tr><td data-num="42"></td><td><pre>	              exec:						// 第一种检查方式, 通过执行命令</pre></td></tr><tr><td data-num="43"></td><td><pre>	                command:</pre></td></tr><tr><td data-num="44"></td><td><pre>	                - /bin/sh</pre></td></tr><tr><td data-num="45"></td><td><pre>	                - -c</pre></td></tr><tr><td data-num="46"></td><td><pre>	                - ps -ef|grep java|grep -v grep</pre></td></tr><tr><td data-num="47"></td><td><pre>	              initialDelaySeconds: 10		// 容器起来后过10s开始检查</pre></td></tr><tr><td data-num="48"></td><td><pre>	              periodSeconds: 10				// 每隔10s检查一次</pre></td></tr><tr><td data-num="49"></td><td><pre>	              failureThreshold: 2			// 连续健康检查失败2次放弃检查, 重启容器</pre></td></tr><tr><td data-num="50"></td><td><pre>	              successThreshold: 1			// 检查一次满足条件就认为健康检查通过</pre></td></tr><tr><td data-num="51"></td><td><pre>	              timeoutSeconds: 5				// 每次健康检查delay时间是5s, 超时也认为健康检查失败, 重启容器</pre></td></tr></table></figure><ul><li>第二种健康检查方式：执行网络请求检查存活探针是否存活</li></ul><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>$ touch kubia-liveness-probe.yaml</pre></td></tr><tr><td data-num="2"></td><td><pre>	apiVersion: v1</pre></td></tr><tr><td data-num="3"></td><td><pre>	kind: Pod</pre></td></tr><tr><td data-num="4"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="5"></td><td><pre>	  name: kubia-liveness</pre></td></tr><tr><td data-num="6"></td><td><pre>	spec:</pre></td></tr><tr><td data-num="7"></td><td><pre>	  containers:</pre></td></tr><tr><td data-num="8"></td><td><pre>	  - image: luksa/kubia-unhealthy</pre></td></tr><tr><td data-num="9"></td><td><pre>	    name: kubia</pre></td></tr><tr><td data-num="10"></td><td><pre>	    livenessProbe:		// 一个 HTTP GET 存活探针</pre></td></tr><tr><td data-num="11"></td><td><pre>	      httpGet:			// 第二种健康检查方式, 通过httpGet</pre></td></tr><tr><td data-num="12"></td><td><pre>	        path: /			// 应用要访问的路径</pre></td></tr><tr><td data-num="13"></td><td><pre>	        port: 8080		// 容器本身启动的端口</pre></td></tr><tr><td data-num="14"></td><td><pre>	        scheme: HTTP</pre></td></tr><tr><td data-num="15"></td><td><pre>	      initialDelaySeconds: 15		// 容器起来后过10s开始检查</pre></td></tr><tr><td data-num="16"></td><td><pre>	      periodSeconds: 5</pre></td></tr></table></figure><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get pods</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME                           READY   STATUS    RESTARTS   AGE</pre></td></tr><tr><td data-num="3"></td><td><pre>	kubia-liveness                 <span class="token number">1</span>/1     Running   <span class="token number">1</span>          13m</pre></td></tr></table></figure><p>查看该 pod 描述</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl describe pod/kubia-liveness</pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	Last State:     Terminated</pre></td></tr><tr><td data-num="4"></td><td><pre>	  Reason:       Error</pre></td></tr><tr><td data-num="5"></td><td><pre>	  Exit Code:    <span class="token number">137</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	  Started:      Wed, <span class="token number">13</span> May <span class="token number">2020</span> <span class="token number">15</span>:49:36 +0800</pre></td></tr><tr><td data-num="7"></td><td><pre>	  Finished:     Wed, <span class="token number">13</span> May <span class="token number">2020</span> <span class="token number">15</span>:51:25 +0800</pre></td></tr><tr><td data-num="8"></td><td><pre>	Ready:          True</pre></td></tr><tr><td data-num="9"></td><td><pre>	Restart Count:  <span class="token number">1</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	Liveness:       http-get http://:8080/ <span class="token assign-left variable">delay</span><span class="token operator">=</span>0s <span class="token assign-left variable">timeout</span><span class="token operator">=</span>1s <span class="token assign-left variable">period</span><span class="token operator">=</span>10s <span class="token comment">#success=1 #failure=3</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span></pre></td></tr></table></figure><p>数字 137 是两个 数字的总和：128+x, 其中 x 是终止进程的信号编号.<br>在这个例子中，x 等于 9, 这是 SIGKILL 的信号编号，意味着这个进程被强行终止.<br>当容器被强行终止时，会创建一个全新的容器 —- 而不是重启原来的容器.<br>delay=Os 部分显示在容器启动后立即开始探测.<br>timeout 仅设置为 1 秒，因此容器必须在 1 秒内进行响应， 不然这次探测记作失败.<br>每 10 秒探测一次容器 (period=lOs), 并在探测连续三次失败 (#failure=3) 后重启容器.<br>定义探 针时可以自定义这些附加参数。例如，要设 置初始延迟，请将 initialDelaySeconds 属性添加到存活探针的配置中.</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>livenessProbe:		// 一个 HTTP GET 存活探针</pre></td></tr><tr><td data-num="2"></td><td><pre>	      httpGet:</pre></td></tr><tr><td data-num="3"></td><td><pre>	        path: /</pre></td></tr><tr><td data-num="4"></td><td><pre>	        port: 8080</pre></td></tr><tr><td data-num="5"></td><td><pre>	      initialDelaySeconds: 15	// Kubernetes会在第—次探测前等待15秒</pre></td></tr></table></figure><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl describe pod/kubia-liveness</pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	Liveness:       http-get http://:8080/ <span class="token assign-left variable">delay</span><span class="token operator">=</span>15s <span class="token assign-left variable">timeout</span><span class="token operator">=</span>1s <span class="token assign-left variable">period</span><span class="token operator">=</span>10s <span class="token comment">#success=1 #failure=3</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre> * 第三种健康检查方式: 通过TCP检查端口是否处于监听状态</pre></td></tr><tr><td data-num="6"></td><td><pre>	    livenessProbe:		// 一个 HTTP GET 存活探针</pre></td></tr><tr><td data-num="7"></td><td><pre>	      tcpSocket:</pre></td></tr><tr><td data-num="8"></td><td><pre>	        port: <span class="token number">8080</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	      initialDelaySeconds: <span class="token number">20</span>	// Kubernetes会在第—次探测前等待15秒 </pre></td></tr><tr><td data-num="10"></td><td><pre>	      periodSeconds: <span class="token number">5</span></pre></td></tr></table></figure><blockquote><p>如果没有设置初始延迟，探针将在启动时立即开始探测容器， 这通常会导致探测失败， 因为应用程序还没准备好开始接收请求.<br>务必记得设置一个初始延迟未说明应用程序的启动时间.<br>对于在生产中运行的 pod, 一定要定义一个存活探针。没有探针的话，Kubemetes 无法知道你的应用是否还活着。只要进程还在运行， Kubemetes 会认为容器是健康的<br>Kubernetes 会在你的容器崩溃或其存活探针失败时， 通过重启容器来保持运行。 这项任务由承载 pod 的节点上的 Kubelet 执行 一 — 在主服务器上运行的 Kubernetes Control Plane 组件不会参与此过程.<br>但如果节点本身崩溃， 那么 Control Plane 必须为所有随节点停止运行的 pod 创建替代品。 它不 会为你直接创建的 pod 执行此操作 。 这些 pod 只被 Kubelet 管理.</p></blockquote><h3 id="查看-readinessprobe-healthprobe"><a class="anchor" href="#查看-readinessprobe-healthprobe">#</a> 查看 readinessProbe, healthProbe</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl edit po -n istio-system istio-ingressgateway-6489d9556d-wjr58</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ kubectl edit deployment -n istio-system istio-ingressgateway</pre></td></tr><tr><td data-num="3"></td><td><pre>	$ kubectl logs po/istio-ingressgateway-6489d9556d-wjr58 -n istio-system</pre></td></tr><tr><td data-num="4"></td><td><pre>	$ kubectl get po -A</pre></td></tr></table></figure><h3 id="affinity"><a class="anchor" href="#affinity">#</a> affinity</h3><p>匹配 Node 标签，Pod 部署到哪台机器上.</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apiVersion: apps/v1</pre></td></tr><tr><td data-num="2"></td><td><pre>	kind: Deployment</pre></td></tr><tr><td data-num="3"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="4"></td><td><pre>	  name: web-demo</pre></td></tr><tr><td data-num="5"></td><td><pre>	  namespace: dev</pre></td></tr><tr><td data-num="6"></td><td><pre>	spec:</pre></td></tr><tr><td data-num="7"></td><td><pre>	  selector:</pre></td></tr><tr><td data-num="8"></td><td><pre>	    matchLabels:</pre></td></tr><tr><td data-num="9"></td><td><pre>	      app: web-demo</pre></td></tr><tr><td data-num="10"></td><td><pre>	  replicas: 1</pre></td></tr><tr><td data-num="11"></td><td><pre>	  template:</pre></td></tr><tr><td data-num="12"></td><td><pre>	    metadata:</pre></td></tr><tr><td data-num="13"></td><td><pre>	      labels:</pre></td></tr><tr><td data-num="14"></td><td><pre>	        app: web-demo</pre></td></tr><tr><td data-num="15"></td><td><pre>	    spec:</pre></td></tr><tr><td data-num="16"></td><td><pre>	      selector:</pre></td></tr><tr><td data-num="17"></td><td><pre>	        matchLabels:</pre></td></tr><tr><td data-num="18"></td><td><pre>	          app: web-demo</pre></td></tr><tr><td data-num="19"></td><td><pre>	      replicas: 1</pre></td></tr><tr><td data-num="20"></td><td><pre>	      template:</pre></td></tr><tr><td data-num="21"></td><td><pre>	        metadata:</pre></td></tr><tr><td data-num="22"></td><td><pre>	          labels:</pre></td></tr><tr><td data-num="23"></td><td><pre>	            app: web-demo</pre></td></tr><tr><td data-num="24"></td><td><pre>	        spec:</pre></td></tr><tr><td data-num="25"></td><td><pre>	          containers:</pre></td></tr><tr><td data-num="26"></td><td><pre>	          - name: web-demo</pre></td></tr><tr><td data-num="27"></td><td><pre>	            image: hub.mooc.com/kubernetes/web:v1</pre></td></tr><tr><td data-num="28"></td><td><pre>	            ports:</pre></td></tr><tr><td data-num="29"></td><td><pre>	            - containerPort: 8080</pre></td></tr><tr><td data-num="30"></td><td><pre>	          affinity:</pre></td></tr><tr><td data-num="31"></td><td><pre>	            nodeAffinity:		// node亲和性, 要部署到哪台机器，不要部署到哪台机器</pre></td></tr><tr><td data-num="32"></td><td><pre>	              requiredDuringSchedulingIgnoredDuringExecution:	// 必须满足下面条件才会执行调度</pre></td></tr><tr><td data-num="33"></td><td><pre>	                nodeSelectorTerms:		// 数组形式, 下面可以定义多个Terms, 它们之间是或的关系</pre></td></tr><tr><td data-num="34"></td><td><pre>	                - matchExpressions:		// 数组形式, 如果定义多个matchExpressions它们之间是与的关系</pre></td></tr><tr><td data-num="35"></td><td><pre>	                  - key: beta.kubernetes.io/arch	// 节点的label含有的key名字, 这里的是由K8s根据机器自动生成的</pre></td></tr><tr><td data-num="36"></td><td><pre>	                    operator: In</pre></td></tr><tr><td data-num="37"></td><td><pre>	                    values:				// 前提是Node机器有amd64标签K8s才会把容器部署到次Node机器</pre></td></tr><tr><td data-num="38"></td><td><pre>	                    - amd64				// 通过kubectl get nodes NodeName -o yaml进行查看</pre></td></tr><tr><td data-num="39"></td><td><pre>	              preferredDuringSchedulingIgnoredDuringExecution:	// 最好是怎样调度</pre></td></tr><tr><td data-num="40"></td><td><pre>	              - weight: 1				// 权重</pre></td></tr><tr><td data-num="41"></td><td><pre>	                perference:</pre></td></tr><tr><td data-num="42"></td><td><pre>	                  matchExpressions:</pre></td></tr><tr><td data-num="43"></td><td><pre>	                  - key: disktype		// 通过kubectl get nodes --show-labels查看</pre></td></tr><tr><td data-num="44"></td><td><pre>	                    operator: NotIn</pre></td></tr><tr><td data-num="45"></td><td><pre>	                    values:</pre></td></tr><tr><td data-num="46"></td><td><pre>	                    - ssd</pre></td></tr><tr><td data-num="47"></td><td><pre>	            podAffinity:		// Pod亲和性, 想和哪些Pod部署到一台机器, 不想和哪些Pod部署在一台机器</pre></td></tr><tr><td data-num="48"></td><td><pre>	              requiredDuringSchedulingIgnoredDuringExecution:</pre></td></tr><tr><td data-num="49"></td><td><pre>	              - labelSelector:</pre></td></tr><tr><td data-num="50"></td><td><pre>	                  matchExpressions:</pre></td></tr><tr><td data-num="51"></td><td><pre>	                  - key: app</pre></td></tr><tr><td data-num="52"></td><td><pre>	                    operator: In		// 要跟app=web-demo的Pod运行在同一个节点上</pre></td></tr><tr><td data-num="53"></td><td><pre>	                    values:</pre></td></tr><tr><td data-num="54"></td><td><pre>	                    - web-demo-node</pre></td></tr><tr><td data-num="55"></td><td><pre>	                topologyKey: kubernetes.io/hostname		// 节点的label名字</pre></td></tr><tr><td data-num="56"></td><td><pre>	              preferredDuringSchedulingIgnoredDuringExecution:</pre></td></tr><tr><td data-num="57"></td><td><pre>	              - weight: 100</pre></td></tr><tr><td data-num="58"></td><td><pre>	                podAffinityTerm:</pre></td></tr><tr><td data-num="59"></td><td><pre>	                  labelSelector:</pre></td></tr><tr><td data-num="60"></td><td><pre>	                    matchExpressions:</pre></td></tr><tr><td data-num="61"></td><td><pre>	                    - key: app</pre></td></tr><tr><td data-num="62"></td><td><pre>	                      operator: In</pre></td></tr><tr><td data-num="63"></td><td><pre>	                      values:</pre></td></tr><tr><td data-num="64"></td><td><pre>	                      - web-demo-node</pre></td></tr><tr><td data-num="65"></td><td><pre>	                  topologyKey: kubernetes.io/hostname</pre></td></tr><tr><td data-num="66"></td><td><pre>	            podAntiAffinity:		// Pod反亲和性, 不想和哪些Pod部署到一台机器, 用法和podAffinity用法完全一样</pre></td></tr><tr><td data-num="67"></td><td><pre>	            pod反亲和性用的很多的是上面的replicas: 的值 >=2 时候会把容器副本分别部署到不同机器</pre></td></tr></table></figure><h3 id="pod启动停止控制"><a class="anchor" href="#pod启动停止控制">#</a> Pod 启动停止控制</h3><p>Pod 容器启动时候和停止前所做的事</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apiVersion: apps/v1</pre></td></tr><tr><td data-num="2"></td><td><pre>	kind: Deployment</pre></td></tr><tr><td data-num="3"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="4"></td><td><pre>	  name: web-demo</pre></td></tr><tr><td data-num="5"></td><td><pre>	  namespace: dev</pre></td></tr><tr><td data-num="6"></td><td><pre>	spec:</pre></td></tr><tr><td data-num="7"></td><td><pre>	  selector:</pre></td></tr><tr><td data-num="8"></td><td><pre>	    matchLabels:</pre></td></tr><tr><td data-num="9"></td><td><pre>	      app: web-demo</pre></td></tr><tr><td data-num="10"></td><td><pre>	  replicas: 1</pre></td></tr><tr><td data-num="11"></td><td><pre>	  template:</pre></td></tr><tr><td data-num="12"></td><td><pre>	    metadata:</pre></td></tr><tr><td data-num="13"></td><td><pre>	      labels:</pre></td></tr><tr><td data-num="14"></td><td><pre>	        app: web-demo</pre></td></tr><tr><td data-num="15"></td><td><pre>	    spec:</pre></td></tr><tr><td data-num="16"></td><td><pre>	      selector:</pre></td></tr><tr><td data-num="17"></td><td><pre>	        matchLabels:</pre></td></tr><tr><td data-num="18"></td><td><pre>	          app: web-demo</pre></td></tr><tr><td data-num="19"></td><td><pre>	      replicas: 1</pre></td></tr><tr><td data-num="20"></td><td><pre>	      template:</pre></td></tr><tr><td data-num="21"></td><td><pre>	        metadata:</pre></td></tr><tr><td data-num="22"></td><td><pre>	          labels:</pre></td></tr><tr><td data-num="23"></td><td><pre>	            app: web-demo</pre></td></tr><tr><td data-num="24"></td><td><pre>	        spec:</pre></td></tr><tr><td data-num="25"></td><td><pre>	          containers:</pre></td></tr><tr><td data-num="26"></td><td><pre>	          - name: web-demo</pre></td></tr><tr><td data-num="27"></td><td><pre>	            image: hub.mooc.com/kubernetes/web:v1</pre></td></tr><tr><td data-num="28"></td><td><pre>	            ports:</pre></td></tr><tr><td data-num="29"></td><td><pre>	            - containerPort: 8080</pre></td></tr><tr><td data-num="30"></td><td><pre>	            volumeMounts:</pre></td></tr><tr><td data-num="31"></td><td><pre>	            - name: shared-volume</pre></td></tr><tr><td data-num="32"></td><td><pre>	              mounthPath: /shared-web</pre></td></tr><tr><td data-num="33"></td><td><pre>	            lifecycle:				Pod里容器启动前和停止前要做的事</pre></td></tr><tr><td data-num="34"></td><td><pre>	              postStart:</pre></td></tr><tr><td data-num="35"></td><td><pre>	                exec:</pre></td></tr><tr><td data-num="36"></td><td><pre>	                  command: ["/bin/sh", "-c", "echo web starting ... >> /var/log/messages"]</pre></td></tr><tr><td data-num="37"></td><td><pre>	              preStop:</pre></td></tr><tr><td data-num="38"></td><td><pre>	                exec:</pre></td></tr><tr><td data-num="39"></td><td><pre>	                  command: ["/bin/sh", "-c", "echo web stopping ... >> /var/log/messages &amp;&amp; sleep 3"]</pre></td></tr></table></figure><h2 id="replicationcontroller"><a class="anchor" href="#replicationcontroller">#</a> ReplicationController</h2><p>一个 ReplicationController 有三个主要部分<br>・label selector ( 标签选择器）， 用于确定 ReplicationController 作用域中有哪些 pod<br>・replica count (副本个数）， 指定应运行的 pod 数量<br>・pod template (pod 模板）， 用于创建新的 pod 副本<br>使用 ReplicationController 的好处<br>・确保一 个 pod (或多个 pod 副本）持续运行， 方法是在现有 pod 丢失时启动一个新 pod。<br>・集群节点发生故障时， 它将为故障节 点 上运 行的所有 pod (即受 ReplicationController 控制的节点上的那些 pod) 创建替代副本。<br>・它能轻松实现 pod 的水平伸缩 手动和自动都可以</p><h3 id="由rc创建pod"><a class="anchor" href="#由rc创建pod">#</a> 由 RC 创建 POD</h3><p>kubia-rc.yaml, 内容如下:</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apiVersion: v1</pre></td></tr><tr><td data-num="2"></td><td><pre>	kind: ReplicationController		// 这里的配置定义了ReplicationController(RC)</pre></td></tr><tr><td data-num="3"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="4"></td><td><pre>	  name: kubia		// ReplicationController 的名字</pre></td></tr><tr><td data-num="5"></td><td><pre>	spec:</pre></td></tr><tr><td data-num="6"></td><td><pre>	  replicas: 3		// pod 实例的目标数目</pre></td></tr><tr><td data-num="7"></td><td><pre>	  selector:			// selector也可以不写，replica 直接根据下面的template模板里的lables标签选择创建POD</pre></td></tr><tr><td data-num="8"></td><td><pre>	    app: kubia		// pod 选择器决定了 RC 的操作对象</pre></td></tr><tr><td data-num="9"></td><td><pre>	  template:			// 从此以下都是创建新 pod 所用的 pod 模板, 与单独创建的pod定义yaml文件内容几乎相同</pre></td></tr><tr><td data-num="10"></td><td><pre>	    metadata:</pre></td></tr><tr><td data-num="11"></td><td><pre>	      labels:</pre></td></tr><tr><td data-num="12"></td><td><pre>	        app: kubia</pre></td></tr><tr><td data-num="13"></td><td><pre>	    spec:</pre></td></tr><tr><td data-num="14"></td><td><pre>	      containers:</pre></td></tr><tr><td data-num="15"></td><td><pre>	      - name: kubia</pre></td></tr><tr><td data-num="16"></td><td><pre>	        image: luksa/kubia</pre></td></tr><tr><td data-num="17"></td><td><pre>	        ports:</pre></td></tr><tr><td data-num="18"></td><td><pre>	        - containerPort: 8080</pre></td></tr></table></figure><p>创建 ReplicationController 并由其创建 pod</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl create -f kubia-rc.yaml</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ kubectl get po -o wide</pre></td></tr><tr><td data-num="3"></td><td><pre>	NAME          READY   STATUS    RESTARTS   AGE   IP          NODE       NOMINATED NODE   READINESS GATES</pre></td></tr><tr><td data-num="4"></td><td><pre>	kubia-6wnj5   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          56s   <span class="token number">10.44</span>.0.3   server02   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr><tr><td data-num="5"></td><td><pre>	kubia-788p8   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          56s   <span class="token number">10.44</span>.0.2   server02   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr><tr><td data-num="6"></td><td><pre>	kubia-c9kn6   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          56s   <span class="token number">10.44</span>.0.1   server02   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>	$ kubectl delete po kubia-6wnj5</pre></td></tr><tr><td data-num="9"></td><td><pre>	NAME          READY   STATUS              RESTARTS   AGE</pre></td></tr><tr><td data-num="10"></td><td><pre>	kubia-6ntgt   <span class="token number">0</span>/1     ContainerCreating   <span class="token number">0</span>          12s</pre></td></tr><tr><td data-num="11"></td><td><pre>	kubia-6wnj5   <span class="token number">1</span>/1     Terminating         <span class="token number">0</span>          3m3s</pre></td></tr><tr><td data-num="12"></td><td><pre>	kubia-788p8   <span class="token number">1</span>/1     Running             <span class="token number">0</span>          3m3s</pre></td></tr><tr><td data-num="13"></td><td><pre>	kubia-c9kn6   <span class="token number">1</span>/1     Running             <span class="token number">0</span>          3m3s</pre></td></tr></table></figure><p>上面重新列出 pod 会显示四个， 因为你删除的 pod 己终止， 并且己创建一个新的 pod<br>虽然 ReplicationController 会立即收到删除 pod 的通知 (API 服务器允许客户端监听资源和资源列表的更改），但这不是它创建替代 pod 的原因。<br>该通知会触发控制器检查实际的 pod 数量并采取适当的措施.</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get po -o wide</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME          READY   STATUS    RESTARTS   AGE     IP          NODE       NOMINATED NODE   READINESS GATES</pre></td></tr><tr><td data-num="3"></td><td><pre>	kubia-6ntgt   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          53s     <span class="token number">10.44</span>.0.4   server02   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr><tr><td data-num="4"></td><td><pre>	kubia-788p8   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          3m44s   <span class="token number">10.44</span>.0.2   server02   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr><tr><td data-num="5"></td><td><pre>	kubia-c9kn6   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          3m44s   <span class="token number">10.44</span>.0.1   server02   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr></table></figure><h3 id="获取有关-replicationcontroller-的信息"><a class="anchor" href="#获取有关-replicationcontroller-的信息">#</a> 获取有关 ReplicationController 的信息</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get rc -o wide</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ kubectl get rc -o wide -n default		// RC是针对某个namespace下做的副本pod控制</pre></td></tr><tr><td data-num="3"></td><td><pre>	NAME    DESIRED   CURRENT   READY   AGE   CONTAINERS   IMAGES        SELECTOR</pre></td></tr><tr><td data-num="4"></td><td><pre>	kubia   <span class="token number">3</span>         <span class="token number">3</span>         <span class="token number">3</span>       17m   kubia        luksa/kubia   <span class="token assign-left variable">app</span><span class="token operator">=</span>kubia</pre></td></tr><tr><td data-num="5"></td><td><pre>	获取RC的详细信息</pre></td></tr><tr><td data-num="6"></td><td><pre>	$ kubectl describe rc kubia</pre></td></tr></table></figure><p>如果你更改了 一个 pod 的标签，使它不再 与 ReplicationController 的标签选择器相匹配 ， 那么该 pod 就变得和其他手动创建的 pod 一样了<br>更改 pod 的标签时， ReplicationController 发现一个 pod 丢失了 ， 并启动一个新的 pod 替换它.</p><p>给其中一个 pod 添加了 type=special 标签，再次列出所有 pod 会显示和以前一样的三个 pod 。 因为从 ReplicationCon 位 oiler 角度而言， 没发生任何更改.</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl label pod/kubia-6ntgt <span class="token assign-left variable">type</span><span class="token operator">=</span>special</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ kubectl get pod --show-labels</pre></td></tr><tr><td data-num="3"></td><td><pre>	NAME          READY   STATUS    RESTARTS   AGE   LABELS</pre></td></tr><tr><td data-num="4"></td><td><pre>	kubia-6ntgt   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          27m   <span class="token assign-left variable">app</span><span class="token operator">=</span>kubia,type<span class="token operator">=</span>special</pre></td></tr><tr><td data-num="5"></td><td><pre>	kubia-788p8   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          30m   <span class="token assign-left variable">app</span><span class="token operator">=</span>kubia</pre></td></tr><tr><td data-num="6"></td><td><pre>	kubia-c9kn6   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          30m   <span class="token assign-left variable">app</span><span class="token operator">=</span>kubia</pre></td></tr></table></figure><p>更改 app 标签该 pod 不再与 RC 的标签选择器相匹配</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl label pod/kubia-6ntgt <span class="token assign-left variable">app</span><span class="token operator">=</span>foo --overwrite</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ kubectl get pod --show-labels</pre></td></tr><tr><td data-num="3"></td><td><pre>	NAME          READY   STATUS              RESTARTS   AGE   LABELS</pre></td></tr><tr><td data-num="4"></td><td><pre>	kubia-6ntgt   <span class="token number">1</span>/1     Running             <span class="token number">0</span>          30m   <span class="token assign-left variable">app</span><span class="token operator">=</span>foo,type<span class="token operator">=</span>special</pre></td></tr><tr><td data-num="5"></td><td><pre>	kubia-788p8   <span class="token number">1</span>/1     Running             <span class="token number">0</span>          33m   <span class="token assign-left variable">app</span><span class="token operator">=</span>kubia</pre></td></tr><tr><td data-num="6"></td><td><pre>	kubia-c9kn6   <span class="token number">1</span>/1     Running             <span class="token number">0</span>          33m   <span class="token assign-left variable">app</span><span class="token operator">=</span>kubia</pre></td></tr><tr><td data-num="7"></td><td><pre>	kubia-dqshz   <span class="token number">0</span>/1     ContainerCreating   <span class="token number">0</span>          4s    <span class="token assign-left variable">app</span><span class="token operator">=</span>kubia</pre></td></tr></table></figure><p>使用 -L app 选项在列 中显示 app 标签</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get pod -L app</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME          READY   STATUS    RESTARTS   AGE     APP</pre></td></tr><tr><td data-num="3"></td><td><pre>	kubia-6ntgt   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          32m     foo</pre></td></tr><tr><td data-num="4"></td><td><pre>	kubia-788p8   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          35m     kubia</pre></td></tr><tr><td data-num="5"></td><td><pre>	kubia-c9kn6   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          35m     kubia</pre></td></tr><tr><td data-num="6"></td><td><pre>	kubia-dqshz   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          2m17s   kubia</pre></td></tr></table></figure><p>可能有一个 bug 导致你的 pod 在特定时间或特定事件后开始出问题。<br>如果你知道某个 pod 发生了故障， 就可以将它从 Replication-Controller 的管理范围中移除， 让控制器将它替换为新 pod, 接着这个 pod 就任你处置了。 完成后删除该 pod 即可。</p><h3 id="编辑rc的yaml配置"><a class="anchor" href="#编辑rc的yaml配置">#</a> 编辑 RC 的 YAML 配置</h3><p>用默认文本编辑器中打开 ReplicationController 的 YAML 配置，会在 /tmp 目录生成一个临时 yaml 文件，退出后 /tmp 目录下的 yaml 文件也会删掉<br>如果你想使用 nano 编辑 Kubernetes 资源，请执行以下命令（或将其放入～/.bashrc 或等效文件中）<br>export KUBE_EDITOR=&quot;/usr/bin/nano&quot;</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl edit rc kubia</pre></td></tr><tr><td data-num="2"></td><td><pre>	......</pre></td></tr><tr><td data-num="3"></td><td><pre>	 spec:</pre></td></tr><tr><td data-num="4"></td><td><pre>	   replicas: 3</pre></td></tr><tr><td data-num="5"></td><td><pre>	   selector:</pre></td></tr><tr><td data-num="6"></td><td><pre>	     app: kubia1				 RC selector 修改，需要配合下面的label一起修改</pre></td></tr><tr><td data-num="7"></td><td><pre>	   template:</pre></td></tr><tr><td data-num="8"></td><td><pre>	     metadata:</pre></td></tr><tr><td data-num="9"></td><td><pre>	       creationTimestamp: null</pre></td></tr><tr><td data-num="10"></td><td><pre>	       labels:</pre></td></tr><tr><td data-num="11"></td><td><pre>	         app: kubia1			 Pod label 修改，需要配合上面的 RC selector 一起修改</pre></td></tr><tr><td data-num="12"></td><td><pre>	     spec:</pre></td></tr><tr><td data-num="13"></td><td><pre>	       containers:</pre></td></tr><tr><td data-num="14"></td><td><pre>	       - image: luksa/kubia</pre></td></tr><tr><td data-num="15"></td><td><pre>	         imagePullPolicy: Always</pre></td></tr><tr><td data-num="16"></td><td><pre>	         name: kubia</pre></td></tr><tr><td data-num="17"></td><td><pre>	         ports:</pre></td></tr><tr><td data-num="18"></td><td><pre>	         - containerPort: 8080</pre></td></tr><tr><td data-num="19"></td><td><pre>	           protocol: TCP</pre></td></tr><tr><td data-num="20"></td><td><pre>	......</pre></td></tr></table></figure><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get pod</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME          READY   STATUS              RESTARTS   AGE   APP</pre></td></tr><tr><td data-num="3"></td><td><pre>	kubia-279wl   <span class="token number">0</span>/1     ContainerCreating   <span class="token number">0</span>          2s    kubia1</pre></td></tr><tr><td data-num="4"></td><td><pre>	kubia-6ntgt   <span class="token number">1</span>/1     Running             <span class="token number">0</span>          44m   foo</pre></td></tr><tr><td data-num="5"></td><td><pre>	kubia-788p8   <span class="token number">1</span>/1     Running             <span class="token number">0</span>          47m   kubia</pre></td></tr><tr><td data-num="6"></td><td><pre>	kubia-c9kn6   <span class="token number">1</span>/1     Running             <span class="token number">0</span>          47m   kubia</pre></td></tr><tr><td data-num="7"></td><td><pre>	kubia-dqshz   <span class="token number">1</span>/1     Running             <span class="token number">0</span>          14m   kubia</pre></td></tr><tr><td data-num="8"></td><td><pre>	kubia-m6vml   <span class="token number">0</span>/1     Pending             <span class="token number">0</span>          2s    kubia1</pre></td></tr><tr><td data-num="9"></td><td><pre>	kubia-xxjqr   <span class="token number">0</span>/1     ContainerCreating   <span class="token number">0</span>          2s    kubia1</pre></td></tr></table></figure><h3 id="rc-扩容"><a class="anchor" href="#rc-扩容">#</a> RC 扩容</h3><p>扩展 / 缩容 RC 管理的 pod 为 5 个<br>第一种，commands 方式:</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl scale rc kubia --replicas<span class="token operator">=</span><span class="token number">5</span></pre></td></tr></table></figure><p>第二种， edit rc yaml 文件</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl edit rc kubia</pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	spec:</pre></td></tr><tr><td data-num="4"></td><td><pre>	  replicas: <span class="token number">5</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span></pre></td></tr></table></figure><h3 id="删除rc"><a class="anchor" href="#删除rc">#</a> 删除 RC</h3><p>当使用 kubectl delete 删除 ReplicationController 时， 可以通过给命令增加 --cascade= false 选项来保持 pod 的运行.</p><pre><code>$ kubectl delete rc kubia --cascade=false
</code></pre><p>已经删除了 ReplicationController, 所以这些 pod 独立了， 它们不再被管理。但是你始终可以使用适当的标签选择器创建新的 ReplicationController, 并再次将它们管理起来</p><h2 id="replicaset"><a class="anchor" href="#replicaset">#</a> ReplicaSet</h2><blockquote><p>最 初， ReplicationController 是用于复制和在异常时重新调度节点的唯 一 Kubemetes 组件， 后来又引入了 一个名为 ReplicaSet 的类似资源 。 它是新一代的 ReplicationController, 并且将其完全替换掉 (ReplicationController 最终将被弃用）。<br>也就是说从现在起， 你应该始终创建 ReplicaSet 而不是 ReplicationController。 它们几乎完全相同， 所以你不会碰到任何麻烦<br>ReplicaSet 的行为与 ReplicationController 完全相同， 但 pod 选择器的表达能力更强<br>ReplicationController 都无法仅基千标签名的存在来匹配 pod, 而 ReplicaSet 则可以。 例如， ReplicaSet 可匹配所有包含名为 env 的标签的 pod, 无论 ReplicaSet 的实际值是什么（可以理解为 env=*)</p></blockquote><p>kubia-replicaset.yaml</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apiVersion: apps/v1</pre></td></tr><tr><td data-num="2"></td><td><pre>	kind: ReplicaSet</pre></td></tr><tr><td data-num="3"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="4"></td><td><pre>	  name: kubia</pre></td></tr><tr><td data-num="5"></td><td><pre>	spec:</pre></td></tr><tr><td data-num="6"></td><td><pre>	  replicas: 3</pre></td></tr><tr><td data-num="7"></td><td><pre>	  selector:</pre></td></tr><tr><td data-num="8"></td><td><pre>	    matchLabels:</pre></td></tr><tr><td data-num="9"></td><td><pre>	      app: kubia</pre></td></tr><tr><td data-num="10"></td><td><pre>	  template:</pre></td></tr><tr><td data-num="11"></td><td><pre>	    metadata:</pre></td></tr><tr><td data-num="12"></td><td><pre>	      labels:</pre></td></tr><tr><td data-num="13"></td><td><pre>	        app: kubia</pre></td></tr><tr><td data-num="14"></td><td><pre>	    spec:</pre></td></tr><tr><td data-num="15"></td><td><pre>	      containers:</pre></td></tr><tr><td data-num="16"></td><td><pre>	      - name: kubia</pre></td></tr><tr><td data-num="17"></td><td><pre>	        image: luksa/kubia</pre></td></tr><tr><td data-num="18"></td><td><pre>	        ports:</pre></td></tr><tr><td data-num="19"></td><td><pre>	        - containerPort: 8080</pre></td></tr></table></figure><p>检查 replicaset:</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get rs</pre></td></tr></table></figure><h3 id="matchexpressions选择器"><a class="anchor" href="#matchexpressions选择器">#</a> matchExpressions 选择器</h3><p>创建个 yaml 文件<br>kubia-replicaset-matchexpressions.yaml</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>selector:</pre></td></tr><tr><td data-num="2"></td><td><pre>	   matchExpressions:</pre></td></tr><tr><td data-num="3"></td><td><pre>	     - key: app</pre></td></tr><tr><td data-num="4"></td><td><pre>	       operator: In</pre></td></tr><tr><td data-num="5"></td><td><pre>	       values:</pre></td></tr><tr><td data-num="6"></td><td><pre>	         - kubia</pre></td></tr></table></figure><p>每个表达式都必须 包含一个 key, 一个 operator (运算符），并且可能还有一个 values 的列表（取决于 运算符）.<br>・In : Label 的值 必须与其中 一个指定的 values 匹配。<br>・Notln : Label 的值与任何指定的 values 不匹配。<br>・Exists : pod 必须包含一个指定名称的标签（值不重要）。使用此运算符时，<br>不应指定 values 字段。<br>・DoesNotExist : pod 不得包含有指定名称的标签。values 属性不得指定<br>如果同时指定 matchLabels 和 matchExpressions, 则所有标签都必须匹配，并且所有表达式必须计算为 true 以使该 pod 与选择器匹配.</p><h3 id="查看-replicaset-和-deployment-的详细信息"><a class="anchor" href="#查看-replicaset-和-deployment-的详细信息">#</a> 查看 replicaset 和 deployment 的详细信息</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl describe deployment details-v1</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ kubectl describe rs details-v1-6fc55d65c9</pre></td></tr></table></figure><h3 id="删除replicaset"><a class="anchor" href="#删除replicaset">#</a> 删除 ReplicaSet</h3><p>删除 ReplicaSet 会删除所有的 pod, 这种情况下是需要列出 pod 来确认.</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl delete rs kubia</pre></td></tr></table></figure><h2 id="daemonset"><a class="anchor" href="#daemonset">#</a> DaemonSet</h2><p>如果节点下线， DaemonSet 不会在其他地方重新创建 pod。 但是， 当将一个新节点添加到集群中时， DaemonSet 会立刻部署一个新的 pod 实例。<br>如果有人无意中删除了 一个 pod ， 那么它也会重新创建 一个新的 pod。<br>与 ReplicaSet 一样，DaemonSet 从配置的 pod 模板创建 pod.</p><blockquote><p>如果节点可以被设置为不可调度的 ， 防止 pod 被部署到节点上. DaemonSet 甚至会将 pod 部署到这些节点上，因为无法调度的属性只会被调度器使用，而 DaemonSet 管理的 pod 则完全绕过调度器。这是预期的，因为 DaemonSet 的目的是运行系统服务，即使是在不可调度的节点上，系统服务通常也需要运行.</p></blockquote><p>给 node 节点打上 label</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl label node server02 <span class="token assign-left variable">disk</span><span class="token operator">=</span>ssd</pre></td></tr></table></figure><p>ssd-monitor-daemonset.yaml</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apiVersion: apps/v1			// DaemooSet在apps的API组 中，版本是v1</pre></td></tr><tr><td data-num="2"></td><td><pre>	kind: DaemonSet</pre></td></tr><tr><td data-num="3"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="4"></td><td><pre>	  name: ssd-monitor</pre></td></tr><tr><td data-num="5"></td><td><pre>	spec:</pre></td></tr><tr><td data-num="6"></td><td><pre>	  selector:</pre></td></tr><tr><td data-num="7"></td><td><pre>	    matchLabels:</pre></td></tr><tr><td data-num="8"></td><td><pre>	      app: ssd-monitor</pre></td></tr><tr><td data-num="9"></td><td><pre>	  template:</pre></td></tr><tr><td data-num="10"></td><td><pre>	    metadata:</pre></td></tr><tr><td data-num="11"></td><td><pre>	      labels:</pre></td></tr><tr><td data-num="12"></td><td><pre>	        app: ssd-monitor</pre></td></tr><tr><td data-num="13"></td><td><pre>	    spec:</pre></td></tr><tr><td data-num="14"></td><td><pre>	      nodeSelector:			// pod模板包含 会选择有disk=ssd标签的节点 一个节点选择器</pre></td></tr><tr><td data-num="15"></td><td><pre>	        disk: ssd</pre></td></tr><tr><td data-num="16"></td><td><pre>	      containers:</pre></td></tr><tr><td data-num="17"></td><td><pre>	      - name: main</pre></td></tr><tr><td data-num="18"></td><td><pre>	        image: luksa/ssd-monitor</pre></td></tr></table></figure><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl create -f ssd-monitor-daemonset.yaml</pre></td></tr></table></figure><h3 id="查看daemonset"><a class="anchor" href="#查看daemonset">#</a> 查看 DaemonSet</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get ds</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME          DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE     CONTAINERS   IMAGES              SELECTOR</pre></td></tr><tr><td data-num="3"></td><td><pre>	ssd-monitor   <span class="token number">1</span>         <span class="token number">1</span>         <span class="token number">1</span>       <span class="token number">1</span>            <span class="token number">1</span>           <span class="token assign-left variable">disk</span><span class="token operator">=</span>ssd        3m29s   main         luksa/ssd-monitor   <span class="token assign-left variable">app</span><span class="token operator">=</span>ssd-monitor</pre></td></tr></table></figure><p>如果你有多个节点并且其他的节点也加上了同样的标签，将会看到 DaemonSet 在每个节点上都启动 pod.<br>给其中一个节点修改标签 disk=hdd, 假设它的硬盘换成磁盘而不是 SSD, 那个节点上的 pod 会如预期中被终止.<br>如果还有其他的 pod 在运行， 删除 DaemonSet 也会一起删除这些 pod。</p><h3 id="删除ds"><a class="anchor" href="#删除ds">#</a> 删除 ds</h3><p>删除 ds 会删除由 ds 控制 schedule 到每个节点的 pod</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl delete ds ssd-monitor</pre></td></tr></table></figure><h2 id="job资源"><a class="anchor" href="#job资源">#</a> Job 资源</h2><p>Kubemetes 通过 Job 资源提供了对此的支持，它允许你运行一种 pod, 该 pod 在内部进程成功结束时， 不重启容器。<br>一旦任务完成， pod 就被认为处于完成状态.<br>由 Job 管理的 pod 会一直被重新安排，直到它们成功完成任务.</p><p>exporter.yaml</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apiVersion: batch/v1</pre></td></tr><tr><td data-num="2"></td><td><pre>	kind: Job</pre></td></tr><tr><td data-num="3"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="4"></td><td><pre>	  name: batch-job</pre></td></tr><tr><td data-num="5"></td><td><pre>	spec:</pre></td></tr><tr><td data-num="6"></td><td><pre>	  template:</pre></td></tr><tr><td data-num="7"></td><td><pre>	    metadata:</pre></td></tr><tr><td data-num="8"></td><td><pre>	      labels:</pre></td></tr><tr><td data-num="9"></td><td><pre>	        app: batch-job</pre></td></tr><tr><td data-num="10"></td><td><pre>	    spec:</pre></td></tr><tr><td data-num="11"></td><td><pre>	      restartPolicy: OnFailure		// 默认为Always,Job pod不能使用默认策略， 因为它们不是要无限期地运行</pre></td></tr><tr><td data-num="12"></td><td><pre>	      containers:</pre></td></tr><tr><td data-num="13"></td><td><pre>	      - name: main</pre></td></tr><tr><td data-num="14"></td><td><pre>	        image: luksa/batch-job		// 运行luksa/batch-job镜像，该镜像调用 一个运行120秒的进程，然后退出</pre></td></tr></table></figure><p>需要明确地将重启策略 restartPolicy 设置为 OnFailure 或 Never。 此设置防止容器在完成任务时重新启动</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl create -f exporter.yaml</pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>	$ kubectl get pod</pre></td></tr><tr><td data-num="4"></td><td><pre>	NAME                READY   STATUS    RESTARTS   AGE</pre></td></tr><tr><td data-num="5"></td><td><pre>	batch-job-lhnfg     <span class="token number">1</span>/1     Running   <span class="token number">0</span>          113s</pre></td></tr><tr><td data-num="6"></td><td><pre>	</pre></td></tr><tr><td data-num="7"></td><td><pre>	$ kubectl get <span class="token function">jobs</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	NAME        COMPLETIONS   DURATION   AGE</pre></td></tr><tr><td data-num="9"></td><td><pre>	batch-job   <span class="token number">0</span>/1           111s       111s</pre></td></tr></table></figure><p>等待两三分钟后</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get pod</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME                READY   STATUS      RESTARTS   AGE</pre></td></tr><tr><td data-num="3"></td><td><pre>	batch-job-lhnfg     <span class="token number">0</span>/1     Completed   <span class="token number">0</span>          3m21s</pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>	$ kubectl get job</pre></td></tr><tr><td data-num="6"></td><td><pre>	NAME        COMPLETIONS   DURATION   AGE</pre></td></tr><tr><td data-num="7"></td><td><pre>	batch-job   <span class="token number">1</span>/1           2m41s      3m27s</pre></td></tr></table></figure><p>完成后 pod 未被删除的原因是允许你查阅其日志</p><pre><code>	$ kubectl logs po/batch-job-lhnfg
	Thu May 14 05:04:38 UTC 2020 Batch job starting
	Thu May 14 05:06:38 UTC 2020 Finished succesfully
</code></pre><p>pod 可以被直接删除， 或者在删除创建它的 Job 时被删除.<br>作业可以配置为创建多个 pod 实例，并以并行或串行方式运行它们.<br>在 Job 配置中设置 completions 和 parallelism 属性来完成的.<br>如果你需要 一个 Job 运行多次，则可以将 comple 巨 ons 设为你希望作业的 pod 运行多少次.</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apiVersion: batch/v1</pre></td></tr><tr><td data-num="2"></td><td><pre>	kind: Job</pre></td></tr><tr><td data-num="3"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="4"></td><td><pre>	  name: multi-completion-batch-job</pre></td></tr><tr><td data-num="5"></td><td><pre>	spec:</pre></td></tr><tr><td data-num="6"></td><td><pre>	  completions: 5	// job将一个接一个地运行五个pod</pre></td></tr><tr><td data-num="7"></td><td><pre>	  parallelism: 2	// 最多两个pod可以并行运行</pre></td></tr><tr><td data-num="8"></td><td><pre>	  template:</pre></td></tr><tr><td data-num="9"></td><td><pre>	    metadata:</pre></td></tr><tr><td data-num="10"></td><td><pre>	      labels:</pre></td></tr><tr><td data-num="11"></td><td><pre>	        app: batch-job</pre></td></tr><tr><td data-num="12"></td><td><pre>	    spec:</pre></td></tr><tr><td data-num="13"></td><td><pre>	      restartPolicy: OnFailure</pre></td></tr><tr><td data-num="14"></td><td><pre>	      containers:</pre></td></tr><tr><td data-num="15"></td><td><pre>	      - name: main</pre></td></tr><tr><td data-num="16"></td><td><pre>	        image: luksa/batch-job</pre></td></tr></table></figure><p>它最初创建一个 pod, 当 pod 的容器运行完成时，它创建第二个 pod, 以此类推，直到五个 pod 成功完成。<br>如果其中 一个 pod 发生故障，工作会创建一个新的 pod, 所以 Job 总共可以创建五个以上的 pod.</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl create -f multi-completion-batch-job.yaml</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME                               READY   STATUS              RESTARTS   AGE</pre></td></tr><tr><td data-num="3"></td><td><pre>	multi-completion-batch-job-8kzd5   <span class="token number">0</span>/1     ContainerCreating   <span class="token number">0</span>          4s</pre></td></tr><tr><td data-num="4"></td><td><pre>	multi-completion-batch-job-9rnxs   <span class="token number">0</span>/1     ContainerCreating   <span class="token number">0</span>          4s</pre></td></tr></table></figure><p>只要其中 一个 pod 完成任务，工作将运行下 一个 pod, 直到五个 pod 都成功完成任务.</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>kubectl get po</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME                               READY   STATUS    RESTARTS   AGE</pre></td></tr><tr><td data-num="3"></td><td><pre>	multi-completion-batch-job-8kzd5   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          2m8s</pre></td></tr><tr><td data-num="4"></td><td><pre>	multi-completion-batch-job-9rnxs   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          2m8s</pre></td></tr><tr><td data-num="5"></td><td><pre>	</pre></td></tr><tr><td data-num="6"></td><td><pre>	$ kubectl get job</pre></td></tr><tr><td data-num="7"></td><td><pre>	NAME                         COMPLETIONS   DURATION   AGE</pre></td></tr><tr><td data-num="8"></td><td><pre>	multi-completion-batch-job   <span class="token number">0</span>/5           2m13s      2m13s</pre></td></tr></table></figure><p>POD 虽然创建，但是 POD 里的进程任务还没有完成，因此 job 显示任然是 0/5 没有一个 pod 任务完成<br>再等待一会时间</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get po</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME                               READY   STATUS      RESTARTS   AGE</pre></td></tr><tr><td data-num="3"></td><td><pre>	multi-completion-batch-job-8kzd5   <span class="token number">0</span>/1     Completed   <span class="token number">0</span>          4m18s</pre></td></tr><tr><td data-num="4"></td><td><pre>	multi-completion-batch-job-9rnxs   <span class="token number">0</span>/1     Completed   <span class="token number">0</span>          4m18s</pre></td></tr><tr><td data-num="5"></td><td><pre>	multi-completion-batch-job-blntb   <span class="token number">1</span>/1     Running     <span class="token number">0</span>          107s</pre></td></tr><tr><td data-num="6"></td><td><pre>	multi-completion-batch-job-qhsr5   <span class="token number">1</span>/1     Running     <span class="token number">0</span>          92s</pre></td></tr><tr><td data-num="7"></td><td><pre>	ssd-monitor-jbhpd                  <span class="token number">1</span>/1     Running     <span class="token number">0</span>          176m</pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>	$ kubectl get job</pre></td></tr><tr><td data-num="10"></td><td><pre>	NAME                         COMPLETIONS   DURATION   AGE</pre></td></tr><tr><td data-num="11"></td><td><pre>	multi-completion-batch-job   <span class="token number">2</span>/5           4m16s      4m16s</pre></td></tr></table></figure><p>如上显示已经有 2 个 POD 任务完成，POD 退出.<br>甚至可以在 Job 运行时更改 Job 的 parallelism 属性，command 如下，实验环境没有成功使用</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl scale job multi-completion-batch-job --replicas <span class="token number">3</span></pre></td></tr></table></figure><blockquote><p>通过在 pod 配置中设置 activeDeadlineSeconds 属性，可以限制 pod 的时间。如果 pod 运行时间超过此时间， 系统将尝试终止 pod, 并将 Job 标记为失败。<br>通过指定 Job manifest 中的 spec.backoff 巨 m 辽字段， 可以配置 Job 在被标记为失败之前可以重试的次数。 如果你没有明确指定它， 则默认为 6</p></blockquote><h3 id="删除job"><a class="anchor" href="#删除job">#</a> 删除 job</h3><p>删除 job 时，由 job 创建的 pod 也被直接删除</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl delete job multi-completion-batch-job</pre></td></tr></table></figure><h2 id="cornjob-资源"><a class="anchor" href="#cornjob-资源">#</a> CornJob 资源</h2><blockquote><p>批处理任务需要在特定的时间运行，或者在指定的时间间隔内重复运行，在 Linux 和类 UNIX 操作系统中， 这些任务通常被称为 cron 任务。 Kubemetes 也支持这种任务<br>Kubemetes 中的 cron 任务通过创建 CronJob 资源进行配置，运行任务的时间表以知名的 cron 格式指定<br>时间表从左到右包含以下五个条目<br>・分钟<br>・小时<br>・每月中的第几天<br>・月<br>・星期几</p></blockquote><p>创建资源文件 (kube API 对象文件) cronjob.yaml</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apiVersion: batch/v1beta1</pre></td></tr><tr><td data-num="2"></td><td><pre>	kind: CronJob</pre></td></tr><tr><td data-num="3"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="4"></td><td><pre>	  name: batch-job-every-fifteen-minutes</pre></td></tr><tr><td data-num="5"></td><td><pre>	spec:</pre></td></tr><tr><td data-num="6"></td><td><pre>	  schedule: "0,15,30,55 * * * *"</pre></td></tr><tr><td data-num="7"></td><td><pre>	  startingDeadlineSeconds: 15	// pod最迟必须在预定时间后15秒开始运行， 如果因为任何原因到该启动时间15s后仍不启动，任务将不会运行，并将显示为Failed</pre></td></tr><tr><td data-num="8"></td><td><pre>	  jobTemplate:</pre></td></tr><tr><td data-num="9"></td><td><pre>	    spec:</pre></td></tr><tr><td data-num="10"></td><td><pre>	      template:</pre></td></tr><tr><td data-num="11"></td><td><pre>	        metadata:</pre></td></tr><tr><td data-num="12"></td><td><pre>	          labels:</pre></td></tr><tr><td data-num="13"></td><td><pre>	            app: periodic-batch-job</pre></td></tr><tr><td data-num="14"></td><td><pre>	        spec:</pre></td></tr><tr><td data-num="15"></td><td><pre>	          restartPolicy: OnFailure</pre></td></tr><tr><td data-num="16"></td><td><pre>	          containers:</pre></td></tr><tr><td data-num="17"></td><td><pre>	          - name: main</pre></td></tr><tr><td data-num="18"></td><td><pre>	            image: luksa/batch-job</pre></td></tr></table></figure><blockquote><p>希望每 15 分钟运行一 次任务因此 schedule 字段的值应该是 &quot;0, 15, 30, 45****&quot; 这意味着每小时的 0 、 15 、 30 和 45 分钟（第一个星号），每月的每一天（第二个星号），每月（第三个星号）和每周的每一天（第四个星号）。<br>相反，如果你希望每隔 30 分钟运行一 次，但仅在每月的第一天运行，则应将计划设置为 &quot;0,30 * 1 * *&quot;, 并且如果你希望它每个星期天的 3AM 运行，将它设置为 &quot;0 3 * * 0&quot; (最后一个零代表星期天）。</p></blockquote><h3 id="查看cronjob"><a class="anchor" href="#查看cronjob">#</a> 查看 cronjob</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get cronjob -o wide</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME                              SCHEDULE             SUSPEND   ACTIVE   LAST SCHEDULE   AGE    CONTAINERS   IMAGES            SELECTOR</pre></td></tr><tr><td data-num="3"></td><td><pre>	batch-job-every-fifteen-minutes   <span class="token number">0,15</span>,30,55 * * * *   False     <span class="token number">0</span>        18m             112m   main         luksa/batch-job   <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr></table></figure><h3 id="cronjob运行状态"><a class="anchor" href="#cronjob运行状态">#</a> cronjob 运行状态</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get po</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME                                               READY   STATUS      RESTARTS   AGE</pre></td></tr><tr><td data-num="3"></td><td><pre>	batch-job-every-fifteen-minutes-1589439300-4v8wd   <span class="token number">0</span>/1     Completed   <span class="token number">0</span>          36m</pre></td></tr><tr><td data-num="4"></td><td><pre>	batch-job-every-fifteen-minutes-1589439600-99pns   <span class="token number">0</span>/1     Completed   <span class="token number">0</span>          31m</pre></td></tr><tr><td data-num="5"></td><td><pre>	batch-job-every-fifteen-minutes-1589440500-vs5vm   <span class="token number">0</span>/1     Completed   <span class="token number">0</span>          16m</pre></td></tr><tr><td data-num="6"></td><td><pre>	batch-job-every-fifteen-minutes-1589441400-52rzb   <span class="token number">1</span>/1     Running     <span class="token number">0</span>          112s</pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>	$ kubectl get job</pre></td></tr><tr><td data-num="9"></td><td><pre>	NAME                                         COMPLETIONS   DURATION   AGE</pre></td></tr><tr><td data-num="10"></td><td><pre>	batch-job-every-fifteen-minutes-1589439300   <span class="token number">1</span>/1           2m24s      36m</pre></td></tr><tr><td data-num="11"></td><td><pre>	batch-job-every-fifteen-minutes-1589439600   <span class="token number">1</span>/1           2m24s      31m</pre></td></tr><tr><td data-num="12"></td><td><pre>	batch-job-every-fifteen-minutes-1589440500   <span class="token number">1</span>/1           2m22s      16m</pre></td></tr><tr><td data-num="13"></td><td><pre>	batch-job-every-fifteen-minutes-1589441400   <span class="token number">0</span>/1           116s       116s</pre></td></tr></table></figure><p>再过一点时间查看</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get po</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME                                               READY   STATUS      RESTARTS   AGE</pre></td></tr><tr><td data-num="3"></td><td><pre>	batch-job-every-fifteen-minutes-1589439600-99pns   <span class="token number">0</span>/1     Completed   <span class="token number">0</span>          32m</pre></td></tr><tr><td data-num="4"></td><td><pre>	batch-job-every-fifteen-minutes-1589440500-vs5vm   <span class="token number">0</span>/1     Completed   <span class="token number">0</span>          17m</pre></td></tr><tr><td data-num="5"></td><td><pre>	batch-job-every-fifteen-minutes-1589441400-52rzb   <span class="token number">0</span>/1     Completed   <span class="token number">0</span>          2m34s</pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>	$ kubectl get job</pre></td></tr><tr><td data-num="8"></td><td><pre>	NAME                                         COMPLETIONS   DURATION   AGE</pre></td></tr><tr><td data-num="9"></td><td><pre>	batch-job-every-fifteen-minutes-1589439600   <span class="token number">1</span>/1           2m24s      32m</pre></td></tr><tr><td data-num="10"></td><td><pre>	batch-job-every-fifteen-minutes-1589440500   <span class="token number">1</span>/1           2m22s      17m</pre></td></tr><tr><td data-num="11"></td><td><pre>	batch-job-every-fifteen-minutes-1589441400   <span class="token number">1</span>/1           2m20s      2m37s</pre></td></tr></table></figure><p>总结: CornJob 过指定的时间执行一次 POD，执行完退出，会保留三个 POD 和 Job 记录.</p><h3 id="删除cronjob"><a class="anchor" href="#删除cronjob">#</a> 删除 cronjob</h3><p>运行中的 Job 将不会被终止，不会删除 Job 或 它们的 Pod。为了清理那些 Job 和 Pod，需要列出该 Cron Job 创建的 Job，然后删除它们.</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ batch-job-every-fifteen-minutes</pre></td></tr><tr><td data-num="2"></td><td><pre>	cronjob.batch <span class="token string">"batch-job-every-fifteen-minutes"</span> deleted</pre></td></tr></table></figure><h2 id="secret"><a class="anchor" href="#secret">#</a> secret</h2><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get secret -n default</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME                  TYPE                                  DATA   AGE</pre></td></tr><tr><td data-num="3"></td><td><pre>	default-token-gtcjx   kubernetes.io/service-account-token   <span class="token number">3</span>      32d</pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>	$ kubectl get pods -o wide</pre></td></tr><tr><td data-num="6"></td><td><pre>	NAME                               READY   STATUS    RESTARTS   AGE     IP           NODE         NOMINATED NODE   READINESS GATES</pre></td></tr><tr><td data-num="7"></td><td><pre>	wordpress-7bfc545758-vtfvm         <span class="token number">1</span>/1     Running   <span class="token number">5</span>          10d     <span class="token number">10.36</span>.0.10   hci-node04   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr><tr><td data-num="8"></td><td><pre>	wordpress-mysql-764fc64f97-sjnjk   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          10d     <span class="token number">10.36</span>.0.8    hci-node04   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>	$ kubectl get po/wordpress-7bfc545758-vtfvm -o yaml</pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span></pre></td></tr><tr><td data-num="12"></td><td><pre>	spec:</pre></td></tr><tr><td data-num="13"></td><td><pre>	  containers:</pre></td></tr><tr><td data-num="14"></td><td><pre>	  - env:</pre></td></tr><tr><td data-num="15"></td><td><pre>	    volumeMounts:</pre></td></tr><tr><td data-num="16"></td><td><pre>	    - mountPath: /var/www/html</pre></td></tr><tr><td data-num="17"></td><td><pre>	      name: wordpress-persistent-storage</pre></td></tr><tr><td data-num="18"></td><td><pre>	    - mountPath: /var/run/secrets/kubernetes.io/serviceaccount</pre></td></tr><tr><td data-num="19"></td><td><pre>	      name: default-token-gtcjx</pre></td></tr><tr><td data-num="20"></td><td><pre>	      readOnly: <span class="token boolean">true</span></pre></td></tr><tr><td data-num="21"></td><td><pre>	<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span></pre></td></tr><tr><td data-num="22"></td><td><pre>	  volumes:</pre></td></tr><tr><td data-num="23"></td><td><pre>	  - name: wordpress-persistent-storage</pre></td></tr><tr><td data-num="24"></td><td><pre>	    persistentVolumeClaim:</pre></td></tr><tr><td data-num="25"></td><td><pre>	      claimName: wp-pv-claim</pre></td></tr><tr><td data-num="26"></td><td><pre>	  - name: default-token-gtcjx</pre></td></tr><tr><td data-num="27"></td><td><pre>	    secret:</pre></td></tr><tr><td data-num="28"></td><td><pre>	      defaultMode: <span class="token number">420</span>		// 访问权限</pre></td></tr><tr><td data-num="29"></td><td><pre>	      secretName: default-token-gtcjx</pre></td></tr><tr><td data-num="30"></td><td><pre>	<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span></pre></td></tr></table></figure><p>进入 wordpress-7bfc545758-vtfvm 所在机器的容器里查看 /var/run/secrets/kubernetes.io/serviceaccount 路径文件</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ docker <span class="token builtin class-name">exec</span> -it daec0458a397 /bin/sh</pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token comment"># ls /var/run/secrets/kubernetes.io/serviceaccount</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	  ca.crt  namespace  token</pre></td></tr></table></figure><h3 id="创建自己的secret"><a class="anchor" href="#创建自己的secret">#</a> 创建自己的 Secret</h3><p>serviceAccount 用来跟 Apiserver 通信，用来授权，可以创建自己的 Secret<br>编写 Secret 配置文件 secret.yaml</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apiVersion: v1</pre></td></tr><tr><td data-num="2"></td><td><pre>	kind: Secret</pre></td></tr><tr><td data-num="3"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="4"></td><td><pre>	  name: dbpass</pre></td></tr><tr><td data-num="5"></td><td><pre>	type: Opaque		// 不透明，浑浊的.</pre></td></tr><tr><td data-num="6"></td><td><pre>	data:</pre></td></tr><tr><td data-num="7"></td><td><pre>	  username: aW1vb2M=		// base64加密的用户名</pre></td></tr><tr><td data-num="8"></td><td><pre>	  passwd: aW1vb2MxMjM=		// base64加密的密码</pre></td></tr></table></figure><p>把字符串生成 base64 很简单，命令如下</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ <span class="token builtin class-name">echo</span> -n imooc <span class="token operator">|</span> base64	// -n 表示换行</pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token assign-left variable">aW1vb2M</span><span class="token operator">=</span></pre></td></tr></table></figure><p>编写 Pod 资源配置文件 pod-secret.yaml</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apiVersion: v1</pre></td></tr><tr><td data-num="2"></td><td><pre>	kind: Pod</pre></td></tr><tr><td data-num="3"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="4"></td><td><pre>	  name: pod-secret</pre></td></tr><tr><td data-num="5"></td><td><pre>	spec:</pre></td></tr><tr><td data-num="6"></td><td><pre>	  containers:</pre></td></tr><tr><td data-num="7"></td><td><pre>	  - name: springbook-web</pre></td></tr><tr><td data-num="8"></td><td><pre>	    image: hub.mooc.com/kubernetes/springboot-web:v1</pre></td></tr><tr><td data-num="9"></td><td><pre>	    ports:</pre></td></tr><tr><td data-num="10"></td><td><pre>	    - containerPort: 8080</pre></td></tr><tr><td data-num="11"></td><td><pre>	    volumeMounts:</pre></td></tr><tr><td data-num="12"></td><td><pre>	    - name: db-secret</pre></td></tr><tr><td data-num="13"></td><td><pre>	      mountPath: /db-secret</pre></td></tr><tr><td data-num="14"></td><td><pre>	      readOnly: true</pre></td></tr><tr><td data-num="15"></td><td><pre>	  volumes:</pre></td></tr><tr><td data-num="16"></td><td><pre>	  - name: db-secret</pre></td></tr><tr><td data-num="17"></td><td><pre>	    projected:</pre></td></tr><tr><td data-num="18"></td><td><pre>	      sources:			// secret 来源</pre></td></tr><tr><td data-num="19"></td><td><pre>	      - secret:</pre></td></tr><tr><td data-num="20"></td><td><pre>	        name: dbpass	// secret 名字</pre></td></tr></table></figure><p>生成 Pod 并进入查看</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ / <span class="token comment"># cd /db-secret/</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	$ <span class="token function">ls</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	  <span class="token function">passwd</span> username</pre></td></tr><tr><td data-num="4"></td><td><pre>	$ <span class="token function">cat</span> -n username		// 查看容器里存放的是base64解码过的数据</pre></td></tr><tr><td data-num="5"></td><td><pre>	  immoc</pre></td></tr><tr><td data-num="6"></td><td><pre>	$ <span class="token function">cat</span> -n <span class="token function">passwd</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	  imooc123</pre></td></tr></table></figure><p>可以通过修改 secret.yaml 文件修改 secret 账号密码等再 $ kubectl apply -f secret.yaml 来更改密码.</p><h2 id="configmap"><a class="anchor" href="#configmap">#</a> Configmap</h2><blockquote><p>configmap 常用来存储不需要加密的数据，比如应用的启动参数，一些参数的配置等</p></blockquote><ul><li>第一种向 k8s 添加很多 key value 的键值对属性值，就可以用 configmap</li></ul><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ <span class="token function">touch</span> game.properties</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ <span class="token function">vim</span> game.properties</pre></td></tr><tr><td data-num="3"></td><td><pre>	  <span class="token assign-left variable">enemies</span><span class="token operator">=</span>aliens</pre></td></tr><tr><td data-num="4"></td><td><pre>	  <span class="token assign-left variable">lives</span><span class="token operator">=</span><span class="token number">3</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	  enemies.cheat<span class="token operator">=</span>true</pre></td></tr><tr><td data-num="6"></td><td><pre>	  secret.code.allowed<span class="token operator">=</span>true</pre></td></tr><tr><td data-num="7"></td><td><pre>	  <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span></pre></td></tr></table></figure><p>配置到 K8S 里</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl create configmap web-game --from-file game.properties</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ kubectl get cm</pre></td></tr></table></figure><p>使用 configmap, Pod-game.yaml</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apiVersion: v1</pre></td></tr><tr><td data-num="2"></td><td><pre>	kind: Pod</pre></td></tr><tr><td data-num="3"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="4"></td><td><pre>	  name: pod-game</pre></td></tr><tr><td data-num="5"></td><td><pre>	spec:</pre></td></tr><tr><td data-num="6"></td><td><pre>	  containers:</pre></td></tr><tr><td data-num="7"></td><td><pre>	  - name: web</pre></td></tr><tr><td data-num="8"></td><td><pre>	    image: hub.mooc.com/kubernetes/springboot-web:v1</pre></td></tr><tr><td data-num="9"></td><td><pre>	    ports:</pre></td></tr><tr><td data-num="10"></td><td><pre>	    - containerPort: 8080</pre></td></tr><tr><td data-num="11"></td><td><pre>	    volumeMounts:</pre></td></tr><tr><td data-num="12"></td><td><pre>	    - name: game</pre></td></tr><tr><td data-num="13"></td><td><pre>	      mountPath: /etc/config/game</pre></td></tr><tr><td data-num="14"></td><td><pre>	      readOnly: true</pre></td></tr><tr><td data-num="15"></td><td><pre>	  volumes:</pre></td></tr><tr><td data-num="16"></td><td><pre>	  - name: game</pre></td></tr><tr><td data-num="17"></td><td><pre>	    configMap:</pre></td></tr><tr><td data-num="18"></td><td><pre>	      name: web-game</pre></td></tr></table></figure><p>生成 Pod 并进入查看</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ <span class="token builtin class-name">cd</span> /etc/config/game</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ <span class="token function">ls</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	  game.properties</pre></td></tr><tr><td data-num="4"></td><td><pre>	$ <span class="token function">cat</span> game.properties</pre></td></tr><tr><td data-num="5"></td><td><pre>	  <span class="token assign-left variable">enemies</span><span class="token operator">=</span>aliens</pre></td></tr><tr><td data-num="6"></td><td><pre>	  <span class="token assign-left variable">lives</span><span class="token operator">=</span><span class="token number">3</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	  enemies.cheat<span class="token operator">=</span>true</pre></td></tr><tr><td data-num="8"></td><td><pre>	  secret.code.allowed<span class="token operator">=</span>true</pre></td></tr><tr><td data-num="9"></td><td><pre>	  <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span></pre></td></tr></table></figure><p>可以通过 kubectl edit 修改 configMap 账号密码等</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl edit cm web-game -o yaml</pre></td></tr><tr><td data-num="2"></td><td><pre>	  enemies.cheat<span class="token operator">=</span>false	//等等操作</pre></td></tr></table></figure><ul><li>第二种配置文件方式创建 configMap<br>configmap.yaml</li></ul><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apeVersion: v1</pre></td></tr><tr><td data-num="2"></td><td><pre>	kind: Configmap</pre></td></tr><tr><td data-num="3"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="4"></td><td><pre>	  name: configs</pre></td></tr><tr><td data-num="5"></td><td><pre>	data:</pre></td></tr><tr><td data-num="6"></td><td><pre>	  Java_OPTS: -Xms1024m</pre></td></tr><tr><td data-num="7"></td><td><pre>	  LOG_LEVEL: DEBUG</pre></td></tr></table></figure><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl create -f configmap.yaml</pre></td></tr></table></figure><p>编写资源配置文件 pod-env.yaml</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apiVersion: v1</pre></td></tr><tr><td data-num="2"></td><td><pre>	kind: Pod</pre></td></tr><tr><td data-num="3"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="4"></td><td><pre>	  name: pod-env</pre></td></tr><tr><td data-num="5"></td><td><pre>	spec:</pre></td></tr><tr><td data-num="6"></td><td><pre>	  containers:</pre></td></tr><tr><td data-num="7"></td><td><pre>	  - name: web</pre></td></tr><tr><td data-num="8"></td><td><pre>	    image: hub.mooc.com/kubernetes/springboot-web:v1</pre></td></tr><tr><td data-num="9"></td><td><pre>	    ports:</pre></td></tr><tr><td data-num="10"></td><td><pre>	    - containerPort: 8080</pre></td></tr><tr><td data-num="11"></td><td><pre>	    env:</pre></td></tr><tr><td data-num="12"></td><td><pre>	      - name: LOG_LEVEL_CONFIG</pre></td></tr><tr><td data-num="13"></td><td><pre>	        valueFrom:</pre></td></tr><tr><td data-num="14"></td><td><pre>	          configMapKeyRef:</pre></td></tr><tr><td data-num="15"></td><td><pre>	            name: configs		// 指定configMap名字</pre></td></tr><tr><td data-num="16"></td><td><pre>	            key: LOG_LEVEL		// configs下面的LOG_LEVEL</pre></td></tr></table></figure><p>进入容器查看环境变量</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ <span class="token function">env</span> <span class="token operator">|</span> <span class="token function">grep</span> LOG</pre></td></tr><tr><td data-num="2"></td><td><pre>	  <span class="token assign-left variable">LOG_LEVEL_CONFIG</span><span class="token operator">=</span>DEBUG</pre></td></tr></table></figure><p>之后次容器就可以通过环境变量获取值</p><ul><li>第三种 通过命令行方式传进参数<br>也是先跟第二种一样创建 configMap 资源</li></ul><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl create -f configmap.yaml</pre></td></tr></table></figure><p>编写资源配置文件 pod-cmd.yaml</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apiVersion: v1</pre></td></tr><tr><td data-num="2"></td><td><pre>	kind: Pod</pre></td></tr><tr><td data-num="3"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="4"></td><td><pre>	  name: pod-cmd</pre></td></tr><tr><td data-num="5"></td><td><pre>	spec:</pre></td></tr><tr><td data-num="6"></td><td><pre>	  containers:</pre></td></tr><tr><td data-num="7"></td><td><pre>	  - name: web</pre></td></tr><tr><td data-num="8"></td><td><pre>	    image: hub.mooc.com/kubernetes/springboot-web:v1</pre></td></tr><tr><td data-num="9"></td><td><pre>	    command: ["/bin/sh", "-c", "java -jar /springboot-web.jar -DJAVA_OPTS=$(JAVA_OPTS)"]</pre></td></tr><tr><td data-num="10"></td><td><pre>	    ports:</pre></td></tr><tr><td data-num="11"></td><td><pre>	    - containerPort: 8080</pre></td></tr><tr><td data-num="12"></td><td><pre>	    env:</pre></td></tr><tr><td data-num="13"></td><td><pre>	      - name: Java_OPTS</pre></td></tr><tr><td data-num="14"></td><td><pre>	        valueFrom:</pre></td></tr><tr><td data-num="15"></td><td><pre>	          configMapKeyRef:</pre></td></tr><tr><td data-num="16"></td><td><pre>	            name: configs		// 指定configMap名字</pre></td></tr><tr><td data-num="17"></td><td><pre>	            key: Java_OPTS		// configs下面的LOG_LEVEL</pre></td></tr></table></figure><p>进入容器查看进程</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ <span class="token function">ps</span> -ef</pre></td></tr><tr><td data-num="2"></td><td><pre>	  java -jar /springboot-web.jar -DJAVA_OPTS<span class="token operator">=</span>-Xms1024m</pre></td></tr></table></figure><h2 id="downwardapi"><a class="anchor" href="#downwardapi">#</a> downwardAPI</h2><p>downwardAPI 主要作用是在程序中取得 Pod 对象本身的一些相关信息<br>pod-downwardapi.yaml</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apiVersion: v1</pre></td></tr><tr><td data-num="2"></td><td><pre>	kind: Pod</pre></td></tr><tr><td data-num="3"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="4"></td><td><pre>	  name: pod-downwardapi</pre></td></tr><tr><td data-num="5"></td><td><pre>	  labels:</pre></td></tr><tr><td data-num="6"></td><td><pre>	    app： downwardapi</pre></td></tr><tr><td data-num="7"></td><td><pre>	    type: webapp</pre></td></tr><tr><td data-num="8"></td><td><pre>	spec:</pre></td></tr><tr><td data-num="9"></td><td><pre>	  containers:</pre></td></tr><tr><td data-num="10"></td><td><pre>	  - name: web</pre></td></tr><tr><td data-num="11"></td><td><pre>	    image: hub.mooc.com/kubernetes/springboot-web:v1</pre></td></tr><tr><td data-num="12"></td><td><pre>	    ports:</pre></td></tr><tr><td data-num="13"></td><td><pre>	    - containerPort: 8080</pre></td></tr><tr><td data-num="14"></td><td><pre>	    volumeMounts:</pre></td></tr><tr><td data-num="15"></td><td><pre>	      - name: podinfo</pre></td></tr><tr><td data-num="16"></td><td><pre>	        mountPath: /etc/podinfo</pre></td></tr><tr><td data-num="17"></td><td><pre>	  volumes:</pre></td></tr><tr><td data-num="18"></td><td><pre>	    - name: podinfo</pre></td></tr><tr><td data-num="19"></td><td><pre>	      projected:</pre></td></tr><tr><td data-num="20"></td><td><pre>	        sources:</pre></td></tr><tr><td data-num="21"></td><td><pre>	        - downwardAPI:</pre></td></tr><tr><td data-num="22"></td><td><pre>	          items:</pre></td></tr><tr><td data-num="23"></td><td><pre>	            - path: "labels"</pre></td></tr><tr><td data-num="24"></td><td><pre>	              fieldRef:</pre></td></tr><tr><td data-num="25"></td><td><pre>	                fieldPath: metadata.labels</pre></td></tr><tr><td data-num="26"></td><td><pre>	            - path: "name"</pre></td></tr><tr><td data-num="27"></td><td><pre>	              fieldRef:</pre></td></tr><tr><td data-num="28"></td><td><pre>	                fieldPath: metadata.name</pre></td></tr><tr><td data-num="29"></td><td><pre>	            - path: "namespace"</pre></td></tr><tr><td data-num="30"></td><td><pre>	              fieldRef:</pre></td></tr><tr><td data-num="31"></td><td><pre>	                fieldPath: metadata.namespace</pre></td></tr><tr><td data-num="32"></td><td><pre>	            - path: "mem-request"</pre></td></tr><tr><td data-num="33"></td><td><pre>	              resourceFieldRef:</pre></td></tr><tr><td data-num="34"></td><td><pre>	                containerName: web</pre></td></tr><tr><td data-num="35"></td><td><pre>	                resource: limits.memory</pre></td></tr></table></figure><p>进入容器查看文件信息</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ <span class="token builtin class-name">cd</span> /etc/podinfo</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ <span class="token function">ls</span> -l</pre></td></tr><tr><td data-num="3"></td><td><pre>	  labels mem-request name namespace</pre></td></tr><tr><td data-num="4"></td><td><pre>	$ <span class="token function">cat</span> -n labels</pre></td></tr><tr><td data-num="5"></td><td><pre>	  <span class="token assign-left variable">app</span><span class="token operator">=</span><span class="token string">"downwardapi"</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	  <span class="token assign-left variable">type</span><span class="token operator">=</span><span class="token string">"webapp"</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	$ <span class="token function">cat</span> -n namespace</pre></td></tr><tr><td data-num="8"></td><td><pre>	  default</pre></td></tr><tr><td data-num="9"></td><td><pre>	$ <span class="token function">cat</span> -n name</pre></td></tr><tr><td data-num="10"></td><td><pre>	  pod-downwardapi</pre></td></tr></table></figure><div class="tags"><a href="/tags/kubernetes/" rel="tag"><i class="ic i-tag"></i> kubernetes</a></div></div><footer><div class="meta"></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Kung-Fu-Master 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Kung-Fu-Master 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="Kung-Fu-Master 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Kung-Fu-Master <i class="ic i-at"><em>@</em></i>Hexo</li><li class="link"><strong>本文链接：</strong> <a href="https://kung-fu-master.github.io/2021/03/13/microService/kubernetes/03_kubernetes_ns_pod/" title="03 Kubernetes nodes, namespace, pod">https://kung-fu-master.github.io/2021/03/13/microService/kubernetes/03_kubernetes_ns_pod/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2021/03/13/microService/kubernetes/06_kubernetes_deployment/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipexj2jgzj20zk0m8b09.jpg" title="06 Kubernetes deployment"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> kubernetes</span><h3>06 Kubernetes deployment</h3></a></div><div class="item right"><a href="/2021/03/13/microService/kubernetes/04_kubernetes_service/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipexoj0moj20zk0m8kgu.jpg" title="04 Kubernetes service"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> kubernetes</span><h3>04 Kubernetes service</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#nodes"><span class="toc-number">1.</span> <span class="toc-text"># nodes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建别名和补全"><span class="toc-number">1.1.</span> <span class="toc-text"># 创建别名和补全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#node-标签"><span class="toc-number">1.2.</span> <span class="toc-text"># node 标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#taint污点"><span class="toc-number">1.3.</span> <span class="toc-text"># taint 污点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#namespace"><span class="toc-number">2.</span> <span class="toc-text"># Namespace</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#隔离性"><span class="toc-number">2.1.</span> <span class="toc-text"># 隔离性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置默认命名空间"><span class="toc-number">2.2.</span> <span class="toc-text"># 设置默认命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建命名空间"><span class="toc-number">2.3.</span> <span class="toc-text"># 创建命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#划分方式"><span class="toc-number">2.4.</span> <span class="toc-text"># 划分方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标记命名空间"><span class="toc-number">2.5.</span> <span class="toc-text"># 标记命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看标记-istio-injectionenabled-标签的命名空间"><span class="toc-number">2.6.</span> <span class="toc-text"># 查看标记 istio-injection&#x3D;enabled 标签的命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除namespace"><span class="toc-number">2.7.</span> <span class="toc-text"># 删除 namespace</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pod"><span class="toc-number">3.</span> <span class="toc-text"># POD</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#查看pod解释"><span class="toc-number">3.1.</span> <span class="toc-text"># 查看 pod 解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建pod"><span class="toc-number">3.2.</span> <span class="toc-text"># 创建 POD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一直查看pod状态"><span class="toc-number">3.3.</span> <span class="toc-text"># 一直查看 pod 状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pod标签labels"><span class="toc-number">3.4.</span> <span class="toc-text"># pod 标签 labels</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pod-注解"><span class="toc-number">3.5.</span> <span class="toc-text"># pod 注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看该-pod-的完整描述文件"><span class="toc-number">3.6.</span> <span class="toc-text"># 查看该 pod 的完整描述文件：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行pod容器"><span class="toc-number">3.7.</span> <span class="toc-text"># 执行 pod 容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#容器进程-网络等"><span class="toc-number">3.8.</span> <span class="toc-text"># 容器进程，网络等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看pod-svc日志"><span class="toc-number">3.9.</span> <span class="toc-text"># 查看 Pod, svc 日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#部署应用程序"><span class="toc-number">3.10.</span> <span class="toc-text"># 部署应用程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重启pod"><span class="toc-number">3.11.</span> <span class="toc-text"># 重启 Pod</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除pod"><span class="toc-number">3.12.</span> <span class="toc-text"># 删除 Pod</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#livenessprobe-存活探针-readinessprobe"><span class="toc-number">4.</span> <span class="toc-text"># livenessProbe 存活探针，readinessProbe</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#查看-readinessprobe-healthprobe"><span class="toc-number">4.1.</span> <span class="toc-text"># 查看 readinessProbe, healthProbe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#affinity"><span class="toc-number">4.2.</span> <span class="toc-text"># affinity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pod启动停止控制"><span class="toc-number">4.3.</span> <span class="toc-text"># Pod 启动停止控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#replicationcontroller"><span class="toc-number">5.</span> <span class="toc-text"># ReplicationController</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#由rc创建pod"><span class="toc-number">5.1.</span> <span class="toc-text"># 由 RC 创建 POD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取有关-replicationcontroller-的信息"><span class="toc-number">5.2.</span> <span class="toc-text"># 获取有关 ReplicationController 的信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编辑rc的yaml配置"><span class="toc-number">5.3.</span> <span class="toc-text"># 编辑 RC 的 YAML 配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rc-扩容"><span class="toc-number">5.4.</span> <span class="toc-text"># RC 扩容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除rc"><span class="toc-number">5.5.</span> <span class="toc-text"># 删除 RC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#replicaset"><span class="toc-number">6.</span> <span class="toc-text"># ReplicaSet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#matchexpressions选择器"><span class="toc-number">6.1.</span> <span class="toc-text"># matchExpressions 选择器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看-replicaset-和-deployment-的详细信息"><span class="toc-number">6.2.</span> <span class="toc-text"># 查看 replicaset 和 deployment 的详细信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除replicaset"><span class="toc-number">6.3.</span> <span class="toc-text"># 删除 ReplicaSet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#daemonset"><span class="toc-number">7.</span> <span class="toc-text"># DaemonSet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#查看daemonset"><span class="toc-number">7.1.</span> <span class="toc-text"># 查看 DaemonSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除ds"><span class="toc-number">7.2.</span> <span class="toc-text"># 删除 ds</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#job资源"><span class="toc-number">8.</span> <span class="toc-text"># Job 资源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#删除job"><span class="toc-number">8.1.</span> <span class="toc-text"># 删除 job</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cornjob-资源"><span class="toc-number">9.</span> <span class="toc-text"># CornJob 资源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#查看cronjob"><span class="toc-number">9.1.</span> <span class="toc-text"># 查看 cronjob</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cronjob运行状态"><span class="toc-number">9.2.</span> <span class="toc-text"># cronjob 运行状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除cronjob"><span class="toc-number">9.3.</span> <span class="toc-text"># 删除 cronjob</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#secret"><span class="toc-number">10.</span> <span class="toc-text"># secret</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建自己的secret"><span class="toc-number">10.1.</span> <span class="toc-text"># 创建自己的 Secret</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#configmap"><span class="toc-number">11.</span> <span class="toc-text"># Configmap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#downwardapi"><span class="toc-number">12.</span> <span class="toc-text"># downwardAPI</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2021/03/13/microService/kubernetes/02_kubernetes_roles_introduction/" rel="bookmark" title="02 kubernetes introduction">02 kubernetes introduction</a></li><li><a href="/2021/03/13/microService/kubernetes/01_etcd_high_availablity/" rel="bookmark" title="01 部署external etcd集群">01 部署external etcd集群</a></li><li><a href="/2021/03/13/microService/kubernetes/01_kubernetes%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F%E5%92%8C%E9%85%8D%E7%BD%AE%E6%9D%A1%E4%BB%B6/" rel="bookmark" title="01 Kubernetes安装方式和配置条件">01 Kubernetes安装方式和配置条件</a></li><li><a href="/2021/03/13/microService/kubernetes/05_kubernetes_volume/" rel="bookmark" title="05 Kubernetes volumes">05 Kubernetes volumes</a></li><li><a href="/2021/03/13/microService/kubernetes/07_kubernetes_Etcd/" rel="bookmark" title="07 Kubernetes Etcd">07 Kubernetes Etcd</a></li><li><a href="/2021/03/13/microService/kubernetes/04_kubernetes_service/" rel="bookmark" title="04 Kubernetes service">04 Kubernetes service</a></li><li class="active"><a href="/2021/03/13/microService/kubernetes/03_kubernetes_ns_pod/" rel="bookmark" title="03 Kubernetes nodes, namespace, pod">03 Kubernetes nodes, namespace, pod</a></li><li><a href="/2021/03/13/microService/kubernetes/06_kubernetes_deployment/" rel="bookmark" title="06 Kubernetes deployment">06 Kubernetes deployment</a></li><li><a href="/2021/03/13/microService/kubernetes/08_kubernetes_samples_problems/" rel="bookmark" title="08 Kubernetes samples and problems">08 Kubernetes samples and problems</a></li><li><a href="/2021/03/13/microService/kubernetes/09_kubernetes_certificate/" rel="bookmark" title="09 Kubernetes Certificates">09 Kubernetes Certificates</a></li><li><a href="/2021/03/13/microService/kubernetes/k8s_command_args_entrypoint_cmd%E5%8C%BA%E5%88%AB/" rel="bookmark" title="k8s command, args, entrypoint, cmd 区别">k8s command, args, entrypoint, cmd 区别</a></li><li><a href="/2021/03/13/microService/kubernetes/10_kubernetes_plugin/" rel="bookmark" title="10 Kubernetes plugin">10 Kubernetes plugin</a></li><li><a href="/2021/03/13/microService/kubernetes/k8s_port_forward/" rel="bookmark" title="使用端口转发(Port Forwarding)来访问集群中的应用">使用端口转发(Port Forwarding)来访问集群中的应用</a></li><li><a href="/2021/03/13/microService/kubernetes/k8s_configmap/" rel="bookmark" title="k8s configmap">k8s configmap</a></li><li><a href="/2021/03/13/microService/kubernetes/k8s_%E5%AF%B9%E8%B1%A1%E5%90%8D%E7%A7%B0%E5%92%8CIDs/" rel="bookmark" title="k8s_对象名称和IDs">k8s_对象名称和IDs</a></li><li><a href="/2021/03/13/microService/kubernetes/k8s_resources%E5%92%8C%E9%A9%B1%E9%80%90%E7%AD%96%E7%95%A5/" rel="bookmark" title="k8s resources和驱逐策略">k8s resources和驱逐策略</a></li><li><a href="/2021/03/13/microService/kubernetes/k8s_node%E8%8A%82%E7%82%B9reset%E5%90%8E%E9%87%8D%E6%96%B0%E5%8A%A0%E5%85%A5%E9%9B%86%E7%BE%A4/" rel="bookmark" title="k8s node 节点reset后重新加入集群">k8s node 节点reset后重新加入集群</a></li><li><a href="/2021/03/13/microService/kubernetes/k8s_secret/" rel="bookmark" title="k8s secret">k8s secret</a></li><li><a href="/2021/03/13/microService/kubernetes/kubernetes_%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/" rel="bookmark" title="kubernetes 准入控制">kubernetes 准入控制</a></li><li><a href="/2021/03/13/microService/kubernetes/kubernetes_upgrade/" rel="bookmark" title="kubernetes upgrade">kubernetes upgrade</a></li><li><a href="/2021/03/13/microService/kubernetes/metrics-server,kubernetes-dashboard/" rel="bookmark" title="Metrics-Server, Kubernetes-Dashboard">Metrics-Server, Kubernetes-Dashboard</a></li><li><a href="/2021/03/13/microService/kubernetes/k8s%E9%87%8D%E6%96%B0%E5%90%AF%E5%8A%A8pod%E7%AD%89%E8%B5%84%E6%BA%90/" rel="bookmark" title="k8s重新启动pod等资源">k8s重新启动pod等资源</a></li><li><a href="/2021/03/21/linux/%E5%88%A0%E9%99%A4crd,pod,pv,pvc%E7%AD%89%E8%B5%84%E6%BA%90/" rel="bookmark" title="删除crd,pod,pv,pvc等资源">删除crd,pod,pv,pvc等资源</a></li><li><a href="/2021/05/31/microService/kubernetes/01_kubernetes_build/" rel="bookmark" title="01 Kubernetes build with kubeadm">01 Kubernetes build with kubeadm</a></li><li><a href="/2021/05/31/microService/kubernetes/01_kubernetes_high_availablity_build/" rel="bookmark" title="01 Kubernetes build high availability">01 Kubernetes build high availability</a></li><li><a href="/2021/05/31/microService/kubernetes/k8s_cert_manager/" rel="bookmark" title="k8s cert manager">k8s cert manager</a></li><li><a href="/2021/05/31/microService/kubernetes/affinity/" rel="bookmark" title="affinity">affinity</a></li><li><a href="/2021/05/31/microService/kubernetes/delete_pod_pv_pvc%E7%AD%89%E8%B5%84%E6%BA%90/" rel="bookmark" title="删除crd,pod,pv,pvc等资源">删除crd,pod,pv,pvc等资源</a></li><li><a href="/2021/05/31/microService/kubernetes/k8s_commands/" rel="bookmark" title="k8s操作命令">k8s操作命令</a></li><li><a href="/2021/05/31/microService/kubernetes/k8s_encounter_problem/" rel="bookmark" title="k8s部署遇到的问题">k8s部署遇到的问题</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Kung-Fu-Master" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Kung-Fu-Master</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">314</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">42</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">14</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lvdXJuYW1l" title="https:&#x2F;&#x2F;github.com&#x2F;yourname"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yourname"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPXlvdXJpZA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;yourid"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2021/03/13/microService/kubernetes/06_kubernetes_deployment/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2021/03/13/microService/kubernetes/04_kubernetes_service/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/reference/" title="分类于 reference">reference</a> <i class="ic i-angle-right"></i> <a href="/categories/reference/k8s/" title="分类于 k8s">k8s</a></div><span><a href="/2021/03/13/reference/k8s/44.Kubernetes%20GPU%E7%AE%A1%E7%90%86%E4%B8%8EDevice%20Plugin%E6%9C%BA%E5%88%B6/" title="44 | Kubernetes GPU管理与Device Plugin机制">44 | Kubernetes GPU管理与Device Plugin机制</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/reference/" title="分类于 reference">reference</a> <i class="ic i-angle-right"></i> <a href="/categories/reference/k8s/" title="分类于 k8s">k8s</a></div><span><a href="/2021/03/13/reference/k8s/30.%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%E5%AD%98%E5%82%A8%E6%8F%92%E4%BB%B6%EF%BC%9AFlexVolume%E4%B8%8ECSI/" title="30 | 编写自己的存储插件：FlexVolume与CSI">30 | 编写自己的存储插件：FlexVolume与CSI</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/linux/" title="分类于 linux">linux</a></div><span><a href="/2021/03/13/linux/PTU(Power%20Thermal%20Utility)/" title="PTU(Power Thermal Utility)">PTU(Power Thermal Utility)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/storage/" title="分类于 storage">storage</a> <i class="ic i-angle-right"></i> <a href="/categories/storage/ceph/" title="分类于 ceph">ceph</a></div><span><a href="/2021/03/13/storage/ceph/ceph_01_conception/" title="Ceph 01 Storage Conception">Ceph 01 Storage Conception</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/microService/" title="分类于 microService">microService</a> <i class="ic i-angle-right"></i> <a href="/categories/microService/kubernetes/" title="分类于 kubernetes">kubernetes</a></div><span><a href="/2021/05/31/microService/kubernetes/k8s_encounter_problem/" title="k8s部署遇到的问题">k8s部署遇到的问题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/reference/" title="分类于 reference">reference</a> <i class="ic i-angle-right"></i> <a href="/categories/reference/k8s/" title="分类于 k8s">k8s</a></div><span><a href="/2021/03/13/reference/k8s/13.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81Pod/" title="13 | 为什么我们需要Pod？">13 | 为什么我们需要Pod？</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/linux/" title="分类于 linux">linux</a></div><span><a href="/2021/03/13/linux/expect%E6%89%A7%E8%A1%8C%E4%B8%8E%E7%BB%88%E7%AB%AF%E7%9A%84%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C/" title="expect 执行与终端的交互操作">expect 执行与终端的交互操作</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/reference/" title="分类于 reference">reference</a> <i class="ic i-angle-right"></i> <a href="/categories/reference/k8s/" title="分类于 k8s">k8s</a></div><span><a href="/2021/03/13/reference/k8s/01.%E9%A2%84%E4%B9%A0%E7%AF%87-%E5%B0%8F%E9%B2%B8%E9%B1%BC%E5%A4%A7%E4%BA%8B%E8%AE%B0(%E4%B8%80)%E5%88%9D%E5%87%BA%E8%8C%85%E5%BA%90/" title="01 | 预习篇 · 小鲸鱼大事记（一）：初出茅庐">01 | 预习篇 · 小鲸鱼大事记（一）：初出茅庐</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/reference/" title="分类于 reference">reference</a> <i class="ic i-angle-right"></i> <a href="/categories/reference/k8s/" title="分类于 k8s">k8s</a></div><span><a href="/2021/03/13/reference/k8s/03.%E9%A2%84%E4%B9%A0%E7%AF%87-%E5%B0%8F%E9%B2%B8%E9%B1%BC%E5%A4%A7%E4%BA%8B%E8%AE%B0(%E4%B8%89)%E7%BE%A4%E9%9B%84%E5%B9%B6%E8%B5%B7/" title="03 | 预习篇 · 小鲸鱼大事记（三）：群雄并起">03 | 预习篇 · 小鲸鱼大事记（三）：群雄并起</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/reference/" title="分类于 reference">reference</a> <i class="ic i-angle-right"></i> <a href="/categories/reference/k8s/" title="分类于 k8s">k8s</a></div><span><a href="/2021/03/13/reference/k8s/20.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3StatefulSet(%E4%B8%89)%EF%BC%9A%E6%9C%89%E7%8A%B6%E6%80%81%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/" title="17 | 经典PaaS的记忆：作业副本与水平扩展">17 | 经典PaaS的记忆：作业副本与水平扩展</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Kung-Fu-Master @ Kung Fu Master</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">1.2m 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">18:20</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2021/03/13/microService/kubernetes/03_kubernetes_ns_pod/",favicon:{show:"（●´3｀●）",hide:"（●´3｀●）"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->