---
title: 希尔排序
tags: 
categories:
- language
- 排序算法
---

## 速记方法
插冒选希, 快堆并基

| 排序方法 | 最好时间 | 平均时间 | 最坏时间 | 辅助存储 | 稳定性 | 备注 |
| :-----: | :----- | :------: | :-----:| :-----: | :------: | :------: |
| 插入排序 | O(n) | O(n^2) | O(n^2) | O(1) | 稳定 |
| 冒泡排序 | O(n) | O(n^2) | O(n^2) | O(1) | 稳定 |
| 选择排序 | O(n^2) | O(n^2) | O(n^2) | O(1) | 不稳定 |
| 希尔排序 | O(n^1.3) | O(nlogn) | O(n^2) | O(1) | 不稳定 |
| 快速排序 | O(nlogn) | O(nlogn) | O(n^2) | O(logn) | 不稳定 |
| 堆排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(1) | 不稳定 |
| 归并排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(n) | 稳定 |
| 基数排序 | O(kn) | O(kn) | O(kn) | O(n) | 稳定 |

从平均情况看：堆排序、归并排序、快速排序胜过希尔排序。

从最好情况看：冒泡排序和直接插入排序更胜一筹。

从最差情况看：堆排序和归并排序强过快速排序。

虽然直接插入排序和冒泡排序速度比较慢，但是当初始序列整体或局部有序是，这两种算法的效率比较高。

当初始序列整体或局部有序时，快速排序算法效率会下降。

当排序序列较小且不要求稳定性是，直接排序效率较好；要求稳定性时，冒泡排序法效率较好。

## 希尔排序
希尔排序的算法思想：将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。

同样的：从上面的描述中我们可以发现：希尔排序的总体实现应该由三个循环完成：

1. 第一层循环：将gap依次折半，对序列进行分组，直到gap=1
2. 第二、三层循环：也即直接插入排序所需要的两次循环。具体描述见上。


``` c
	#include <stdio.h>
	
	/**
	 * 宏	功能
	 * ’#‘	字符串化
	 * ‘##’	字符连接的功能
	 * "__VA_ARGS__’	这个可变参数的宏是新的C99规范中新增的, 和变参函数中的...一致
	 * ‘##__VA_ARGS__’	宏前面加上##的作用在于，当可变参数的个数为0时，这里的##起到把前面多余的","去掉的作用,否则会编译出错
	 */
	#define PRINT(fmt, ...) \
	    printf(fmt, ##__VA_ARGS__)
	
	#define PRINT1(...) \
	    printf(__VA_ARGS__)
	
	void shell_sort(int array[], int length)
	{
	    int temp, i, j, h;
	    for (h = length / 2; h > 0; h = h / 2)
	    {
	        for (i = h; i < length; ++i)
	        {
	            temp = array[i];
	            for (j = i - h; j >= 0; j -= h)
	            {
	                if (temp < array[j])
	                {
	                    array[j + h] = array[j];
	                }
	                else
	                {
	                    break;
	                }
	            }
	            array[j + h] = temp;
	        }
	    }
	}
	
	int main()
	{
	    int array[] = {29, 18, 87, 56, 3, 27, 9, 63, 39};
	
	    int length = sizeof(array) / sizeof(array[0]);
	    shell_sort(array, length);
	    int i = 0;
	    for (i = 0; i < length; i++)
	    {
	        PRINT("%d ", array[i]);
	    }
	    PRINT("\n");
	    return 0;
	}
```

Makefile：

```
	insertion_sort: 01.insertion_sort.c
		gcc -g 01.insertion_sort.c -o 01.insertion_sort.o
	
	bubble_sort: 02.bubble_sort.c
		gcc -g 02.bubble_sort.c -o 02.bubble_sort.o
	
	select_sort: 03.select_sort.c
		gcc -g 03.select_sort.c -o 03.select_sort.o
	
	shell_sort: 04.shell_sort.c
		gcc -g 04.shell_sort.c -o 04.shell_sort.o
	
	clean:
		rm -rf *.o
```

编译：

```shell
	// 编译
	make shell_sort
	
	// 执行
	./04.shell_sort.o
	
	// 清理
	make clean
```



