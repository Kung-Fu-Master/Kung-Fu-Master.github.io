---
title: 冒泡排序
tags: 
categories:
- language
- 排序算法
---

## 速记方法
插冒选希, 块堆并基

| 排序方法 | 最好时间 | 平均时间 | 最坏时间 | 辅助存储 | 稳定性 | 备注 |
| :-----: | :----- | :------: | :-----:| :-----: | :------: | :------: |
| 插入排序 | O(n) | O(n^2) | O(n^2) | O(1) | 稳定 |
| 冒泡排序 | O(n) | O(n^2) | O(n^2) | O(1) | 稳定 |
| 选择排序 | O(n^2) | O(n^2) | O(n^2) | O(1) | 不稳定 |
| 希尔排序 | O(n^1.3) | O(nlogn) | O(n^2) | O(1) | 不稳定 |
| 快速排序 | O(nlogn) | O(nlogn) | O(n^2) | O(logn) | 不稳定 |
| 堆排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(1) | 不稳定 |
| 归并排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(n) | 稳定 |
| 基数排序 | O(kn) | O(kn) | O(kn) | O(n) | 稳定 |

从平均情况看：堆排序、归并排序、快速排序胜过希尔排序。

从最好情况看：冒泡排序和直接插入排序更胜一筹。

从最差情况看：堆排序和归并排序强过快速排序。

虽然直接插入排序和冒泡排序速度比较慢，但是当初始序列整体或局部有序是，这两种算法的效率比较高。

当初始序列整体或局部有序时，快速排序算法效率会下降。

当排序序列较小且不要求稳定性是，直接排序效率较好；要求稳定性时，冒泡排序法效率较好。

## 冒泡排序
![](bubble_sort_01.gif)

冒泡排序思路比较简单：

1. 将序列当中的左右元素，依次比较，保证右边的元素始终大于左边的元素；
（ 第一轮结束后，序列最后一个元素一定是当前序列的最大值；）
2. 对序列当中剩下的n-1个元素再次执行步骤1。
3. 对于长度为n的序列，一共需要执行n-1轮比较
（利用while循环可以减少执行次数）


	#include <stdio.h>
	
	/**
	 * 宏	功能
	 * ’#‘	字符串化
	 * ‘##’	字符连接的功能
	 * "__VA_ARGS__’	这个可变参数的宏是新的C99规范中新增的, 和变参函数中的...一致
	 * ‘##__VA_ARGS__’	宏前面加上##的作用在于，当可变参数的个数为0时，这里的##起到把前面多余的","去掉的作用,否则会编译出错
	 */
	#define PRINT(fmt, ...) \
	    printf(fmt, ##__VA_ARGS__)
	
	#define PRINT1(...) \
	    printf(__VA_ARGS__)
	
	// 在C语言中是不存在引用的，也就是说C语言中&表示的不是引用，而是取地址符
	// 用指针来取代引用，在函数中传进来地址, 或者可以将代码扩展名保存成.cpp文件
	void swap_int(int *num1, int *num2)
	{
	    int temp = 0;
	    temp = *num1;
	    *num1 = *num2;
	    *num2 = temp;
	}
	
	void bubble_sort_01(int array[], int length)
	{
	    int i, j, temp;
	    for (i = 0; i < length - 1; ++i)        // 总共比较n - 1 轮.
	    {
	        for (j = 0; j < length - i - 1; ++j)// 每轮从第一个开始, 两两比较到剩余的元素的前一元素位置.
	        {
	            if (array[j] > array[j + 1])    // 如果前者大于后者, 则把大的前者冒泡到后边.
	            {
	                swap_int(&array[j], &array[j + 1]);
	            }
	        }
	    }
	}
	
	int main()
	{
	    int array[] = {29, 18, 87, 56, 3, 27, 9, 63, 39};
	
	    int length = sizeof(array) / sizeof(array[0]);
	    bubble_sort_01(array, length);
	    int i = 0;
	    PRINT("%s-(%d), %s \n",__FILE__, __LINE__, __FUNCTION__);
	    for (i = 0; i < length; i++)
	    {
	        PRINT("%d ", array[i]);
	    }
	    PRINT("\n");
	    return 0;
	}
Makefile：

	insertion_sort: 01.insertion_sort.c
		gcc -g 01.insertion_sort.c -o 01.insertion_sort.o
	
	bubble_sort: 02.bubble_sort.c
		gcc -g 02.bubble_sort.c -o 02.bubble_sort.o
	
	clean:
		rm -rf *.o

编译：

	// 编译
	make bubble_sort
	
	// 执行
	./02.bubble_sort.o
	
	// 清理
	make clean

## 改进冒泡排序算法
传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。

改进后的算法实现为:

	#define PRINT(fmt, ...) \
	    printf(fmt, ##__VA_ARGS__)
	
	void swap_int(int *num1, int *num2)
	{
	    int temp;
	    temp = *num1;
	    *num1 = *num2;
	    *num2 = temp;
	}
	
	void bubble_sort_02(int array[], int length)
	{
	    PRINT("%s-(%d), %s \n",__FILE__, __LINE__, __FUNCTION__);
	    int low = 0, high = length - 1;
	    int i;
	    while (low < high)
	    {
	        for(i = 0; i <= high; ++i)     // 正向冒泡, 找到最大值
	        {
	            if (array[i] > array[i + 1])
	            {
	                swap_int(&array[i], &array[i + 1]);
	            }
	        }
	        --high;    // 将最大值移动到当前要排序的最后位置, high前移一位
	        for (i = high; i > 0; --i)     // 反向冒泡, 找到最小值
	        {
	            if (array[i] < array[i - 1])
	            {
	                swap_int(&array[i], &array[i - 1]);
	            }
	        }
	        ++low;      // 将最小值移动到当前要排序的最前位置, high前移一位
	    }
	}




