---
title: 选择排序
tags: 
categories:
- language
- 排序算法
---

## 速记方法
插冒选希, 快堆并基

| 排序方法 | 最好时间 | 平均时间 | 最坏时间 | 辅助存储 | 稳定性 | 备注 |
| :-----: | :----- | :------: | :-----:| :-----: | :------: | :------: |
| 插入排序 | O(n) | O(n^2) | O(n^2) | O(1) | 稳定 |
| 冒泡排序 | O(n) | O(n^2) | O(n^2) | O(1) | 稳定 |
| 选择排序 | O(n^2) | O(n^2) | O(n^2) | O(1) | 不稳定 |
| 希尔排序 | O(n^1.3) | O(nlogn) | O(n^2) | O(1) | 不稳定 |
| 快速排序 | O(nlogn) | O(nlogn) | O(n^2) | O(logn) | 不稳定 |
| 堆排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(1) | 不稳定 |
| 归并排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(n) | 稳定 |
| 基数排序 | O(kn) | O(kn) | O(kn) | O(n) | 稳定 |

从平均情况看：堆排序、归并排序、快速排序胜过希尔排序。

从最好情况看：冒泡排序和直接插入排序更胜一筹。

从最差情况看：堆排序和归并排序强过快速排序。

虽然直接插入排序和冒泡排序速度比较慢，但是当初始序列整体或局部有序是，这两种算法的效率比较高。

当初始序列整体或局部有序时，快速排序算法效率会下降。

当排序序列较小且不要求稳定性是，直接排序效率较好；要求稳定性时，冒泡排序法效率较好。

## 选择排序
![](select_sort.gif)

简单选择排序的基本思想：比较+交换。

1. 从待排序序列中，找到关键字最小的元素；
2. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；
3. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束。
  因此我们可以发现，简单选择排序也是通过两层循环实现。  
  第一层循环：依次遍历序列当中的每一个元素  
  第二层循环：将遍历得到的当前元素依次与余下的元素进行比较，符合最小元素的条件，则交换。
![](select_sort_02.png)

对于给定的一组记录，经过第一轮比较后得到最小的记录，然后将记录与第一个记录的位置进行交换；接着对不包括第一个记录以外的其他记录进行第二轮排序，得到最小的记录并与第二个记录进行位置交换；重复该过程，直到进行比较的记录只有一个为止。

``` c
	#include <stdio.h>
	
	/**
	 * 宏	功能
	 * ’#‘	字符串化
	 * ‘##’	字符连接的功能
	 * "__VA_ARGS__’	这个可变参数的宏是新的C99规范中新增的, 和变参函数中的...一致
	 * ‘##__VA_ARGS__’	宏前面加上##的作用在于，当可变参数的个数为0时，这里的##起到把前面多余的","去掉的作用,否则会编译出错
	 */
	#define PRINT(fmt, ...) \
	    printf(fmt, ##__VA_ARGS__)
	
	#define PRINT1(...) \
	    printf(__VA_ARGS__)
	
	void swap_int(int *num1, int *num2)
	{
	    int temp;
	    temp = *num1;
	    *num1 = *num2;
	    *num2 = temp;
	}
	
	void select_sort(int array[], int length)
	{
	    int i, j, temp = 0;
	    for (i = 0; i < length; ++i)		// 从第一个开始, 比较然后确定最小的进行交换.
	    {
	        for (j = i + 1; j < length; ++j)
	        {
	            if (array[i] > array[j])
	            {
	                swap_int(&array[i], &array[j]);
	            }
	        }
	    }
	}
	
	int main()
	{
	    int array[] = {29, 18, 87, 56, 3, 27, 9, 63, 39};
	
	    int length = sizeof(array) / sizeof(array[0]);
	    select_sort(array, length);
	    int i = 0;
	    for (i = 0; i < length; i++)
	    {
	        PRINT("%d ", array[i]);
	    }
	    PRINT("\n");
	    return 0;
	}
```
Makefile：

```
	insertion_sort: 01.insertion_sort.c
		gcc -g 01.insertion_sort.c -o 01.insertion_sort.o
	
	bubble_sort: 02.bubble_sort.c
		gcc -g 02.bubble_sort.c -o 02.bubble_sort.o
	
	select_sort: 03.select_sort.c
		gcc -g 03.select_sort.c -o 03.select_sort.o
	
	clean:
		rm -rf *.o
```
编译：

```shell
	// 编译
	make select_sort
	
	// 执行
	./03.select_sort.o
	
	// 清理
	make clean
```




