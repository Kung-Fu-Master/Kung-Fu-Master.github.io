<!-- build time:Tue Jun 15 2021 17:05:23 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Hexo" href="https://kung-fu-master.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Hexo" href="https://kung-fu-master.github.io/atom.xml"><link rel="alternate" type="application/json" title="Hexo" href="https://kung-fu-master.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="istio"><link rel="canonical" href="https://kung-fu-master.github.io/2021/03/13/microService/kubernetes/k8s_secret/"><title>k8s secret - kubernetes - microService | Kung Fu Master = Hexo</title><meta name="generator" content="Hexo 4.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">k8s secret</h1><div class="meta"><span class="item" title="创建时间：2021-03-13 13:00:42"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-03-13T13:00:42+08:00">2021-03-13</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>15k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>14 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Kung Fu Master</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giciuv0socj20zk0m8qes.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicliwyw55j20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipesrnqv3j20zk0m8ava.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipevgoki5j20zk0m84qp.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giciub8ja1j20zk0m81ky.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicitht3xtj20zk0m8k5v.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/microService/" itemprop="item" rel="index" title="分类于 microService"><span itemprop="name">microService</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/microService/kubernetes/" itemprop="item" rel="index" title="分类于 kubernetes"><span itemprop="name">kubernetes</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://kung-fu-master.github.io/2021/03/13/microService/kubernetes/k8s_secret/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Kung-Fu-Master"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hexo"></span><div class="body md" itemprop="articleBody"><h2 id="secret"><a class="anchor" href="#secret">#</a> Secret</h2><p>Secret 对象类型用来保存敏感信息，例如密码、OAuth 令牌和 SSH 密钥。 将这些信息放在 secret 中比放在 Pod 的定义或者 容器镜像 中来说更加安全和灵活。 参阅 <span class="exturl" data-url="aHR0cHM6Ly9naXQuazhzLmlvL2NvbW11bml0eS9jb250cmlidXRvcnMvZGVzaWduLXByb3Bvc2Fscy9hdXRoL3NlY3JldHMubWQ=">Secret 设计文档</span> 获取更多详细信息。</p><p><a id="more"></a></p><p>Secret 是一种包含少量敏感信息例如密码、令牌或密钥的对象。 这样的信息可能会被放在 Pod 规约中或者镜像中。 用户可以创建 Secret，同时系统也创建了一些 Secret.</p><p>Kubernetes 会验证 Secret 作为卷来源时所给的对象引用确实指向一个类型为 Secret 的对象。因此，Secret 需要先于任何依赖于它的 Pod 创建。</p><p>Secret API 对象处于某名字空间 中。它们只能由同一命名空间中的 Pod 引用。</p><p>每个 Secret 的 <code>大小限制为 1MB</code> 。这是为了防止创建非常大的 Secret 导致 API 服务器 和 kubelet 的内存耗尽。然而，创建过多较小的 Secret 也可能耗尽内存。 更全面得限制 Secret 内存用量的功能还在计划中。</p><p>kubelet 仅支持从 API 服务器获得的 Pod 使用 Secret。 这包括使用 kubectl 创建的所有 Pod，以及间接通过副本控制器创建的 Pod。 它不包括通过 kubelet --manifest-url 标志，--config 标志或其 REST API 创建的 Pod（这些不是创建 Pod 的常用方法）。</p><p>以环境变量形式在 Pod 中使用 Secret 之前必须先创建 Secret，除非该环境变量被标记为可选的。 Pod 中引用不存在的 Secret 时将无法启动。</p><p>使用 secretKeyRef 时，如果引用了指定 Secret 不存在的键，对应的 Pod 也无法启动。</p><p>对于通过 <code>envFrom</code> 填充环境变量的 Secret，如果 Secret 中包含的键名无法作为合法的环境变量名称，对应的键会被跳过，该 Pod 将被允许启动。 不过这时会产生一个事件，其原因为 <code>nvalidVariableNames</code> ，其消息中包含被跳过的无效键的列表。 下面的示例显示一个 Pod，它引用了包含 2 个无效键 1badkey 和 2alsobad。</p><pre><code>kubectl get events
输出类似于：
LASTSEEN   FIRSTSEEN   COUNT     NAME            KIND      SUBOBJECT                         TYPE      REASON
0s         0s          1         dapi-test-pod   Pod                                         Warning   InvalidEnvironmentVariableNames   kubelet, 127.0.0.1      Keys [1badkey, 2alsobad] from the EnvFrom secret default/mysecret were skipped since they are considered invalid environment variable names.
</code></pre><h2 id="secret-与-pod-生命周期的关系"><a class="anchor" href="#secret-与-pod-生命周期的关系">#</a> Secret 与 Pod 生命周期的关系</h2><p>通过 API 创建 Pod 时，不会检查引用的 Secret 是否存在。一旦 Pod 被调度，kubelet 就会尝试获取该 Secret 的值。如果获取不到该 Secret，或者暂时无法与 API 服务器建立连接， kubelet 将会定期重试。kubelet 将会报告关于 Pod 的事件，并解释它无法启动的原因。 一旦获取到 Secret，kubelet 将创建并挂载一个包含它的卷。在 Pod 的所有卷被挂载之前， Pod 中的容器不会启动。</p><h2 id="secret-概览"><a class="anchor" href="#secret-概览">#</a> Secret 概览</h2><p>要使用 Secret，Pod 需要引用 Secret。<br>Pod 可以用三种方式之一来使用 Secret：</p><ul><li>作为挂载到一个或多个容器上的 <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poL2RvY3MvY29uY2VwdHMvc3RvcmFnZS92b2x1bWVzLw==">卷</span>中的<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poL2RvY3MvY29uY2VwdHMvY29uZmlndXJhdGlvbi9zZWNyZXQvI3VzaW5nLXNlY3JldHMtYXMtZmlsZXMtZnJvbS1hLXBvZA==">文件</span><br>中的<a href="#%E5%9C%A8Pod%E4%B8%AD%E4%BD%BF%E7%94%A8Secret%E6%96%87%E4%BB%B6">文件</a></li><li>作为<a href="#%E4%BB%A5%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E5%BD%A2%E5%BC%8F%E4%BD%BF%E7%94%A8Secrets">容器的环境变量</a></li><li>由 <a href="#%E4%BD%BF%E7%94%A8imagePullSecret">kubelet 在为 Pod 拉取镜像时使用</a></li></ul><p>Secret 对象的名称必须是合法的 <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poL2RvY3MvY29uY2VwdHMvb3ZlcnZpZXcvd29ya2luZy13aXRoLW9iamVjdHMvbmFtZXMvI2Rucy1zdWJkb21haW4tbmFtZXM=">DNS 子域名</span>。在为创建 Secret 编写配置文件时，你可以设置 <code>data</code> 与 / 或 <code>stringData</code> 字段。 <code>data</code> 和 <code>stringData</code> 字段都是可选的。 <code>data</code> 字段中所有键值都必须是 base64 编码的字符串。如果不希望执行这种 base64 字符串的转换操作，你可以选择设置 stringData 字段，其中可以使用任何字符串作为其取值。</p><h2 id="secret-的类型"><a class="anchor" href="#secret-的类型">#</a> Secret 的类型</h2><p>在创建 Secret 对象时，你可以使用 <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvcmVmZXJlbmNlL2dlbmVyYXRlZC9rdWJlcm5ldGVzLWFwaS92MS4yMC8jc2VjcmV0LXYxLWNvcmU=">Secret</span> 资源的 <code>type</code> 字段，或者与其等价的 <code>kubectl</code> 命令行参数（如果有的话）为其设置类型。 Secret 的类型用来帮助编写程序处理 Secret 数据。</p><p>Kubernetes 提供若干种内置的类型，用于一些常见的使用场景。 针对这些类型，Kubernetes 所执行的合法性检查操作以及对其所实施的限制各不相同。</p><table><thead><tr><th style="text-align:left">内置类型</th><th style="text-align:left">用法</th></tr></thead><tbody><tr><td style="text-align:left">Opaque</td><td style="text-align:left">&lt;div style=&quot;width: 300pt&quot;&gt; 用户定义的任意数据 &lt;/div&gt;</td></tr><tr><td style="text-align:left"><span class="exturl" data-url="aHR0cDovL2t1YmVybmV0ZXMuaW8vc2VydmljZS1hY2NvdW50LXRva2Vu">kubernetes.io/service-account-token</span></td><td style="text-align:left">服务账号令牌</td></tr><tr><td style="text-align:left"><span class="exturl" data-url="aHR0cDovL2t1YmVybmV0ZXMuaW8vZG9ja2VyY2Zn">kubernetes.io/dockercfg</span></td><td style="text-align:left">~/.dockercfg 文件的序列化形式</td></tr><tr><td style="text-align:left"><span class="exturl" data-url="aHR0cDovL2t1YmVybmV0ZXMuaW8vZG9ja2VyY29uZmlnanNvbg==">kubernetes.io/dockerconfigjson</span></td><td style="text-align:left">~/.docker/config.json 文件的序列化形式</td></tr><tr><td style="text-align:left"><span class="exturl" data-url="aHR0cDovL2t1YmVybmV0ZXMuaW8vYmFzaWMtYXV0aA==">kubernetes.io/basic-auth</span></td><td style="text-align:left">用于基本身份认证的凭据</td></tr><tr><td style="text-align:left"><span class="exturl" data-url="aHR0cDovL2t1YmVybmV0ZXMuaW8vc3NoLWF1dGg=">kubernetes.io/ssh-auth</span></td><td style="text-align:left">用于 SSH 身份认证的凭据</td></tr><tr><td style="text-align:left"><span class="exturl" data-url="aHR0cDovL2t1YmVybmV0ZXMuaW8vdGxz">kubernetes.io/tls</span></td><td style="text-align:left">用于 TLS 客户端或者服务器端的数据</td></tr><tr><td style="text-align:left"><span class="exturl" data-url="aHR0cDovL2Jvb3RzdHJhcC5rdWJlcm5ldGVzLmlvL3Rva2Vu">bootstrap.kubernetes.io/token</span></td><td style="text-align:left">启动引导令牌数据</td></tr></tbody></table><p>通过为 Secret 对象的 type 字段设置一个非空的字符串值，你也可以定义并使用自己 Secret 类型。如果 type 值为空字符串，则被视为 Opaque 类型。 Kubernetes 并不对类型的名称作任何限制。不过，如果你要使用内置类型之一， 则你必须满足为该类型所定义的所有要求。</p><h3 id="opaque-secret"><a class="anchor" href="#opaque-secret">#</a> Opaque Secret</h3><p>当 Secret 配置文件中未作显式设定时，默认的 Secret 类型是 Opaque。 当你使用 kubectl 来创建一个 Secret 时，你会使用 generic 子命令来标明 要创建的是一个 Opaque 类型 Secret。 例如，下面的命令会创建一个空的 Opaque 类型 Secret 对象：</p><pre><code>kubectl create secret generic empty-secret
kubectl get secret empty-secret
</code></pre><p>输出类似于</p><pre><code>NAME           TYPE     DATA   AGE
empty-secret   Opaque   0      2m6s
</code></pre><p>DATA 列显示 Secret 中保存的数据条目个数。 在这个例子种，0 意味着我们刚刚创建了一个空的 Secret。</p><h3 id="服务账号令牌-secret"><a class="anchor" href="#服务账号令牌-secret">#</a> 服务账号令牌 Secret</h3><p>Kubernetes 在创建 Pod 时会自动创建一个服务账号 Secret 并自动修改你的 Pod 以使用该 Secret。该服务账号令牌 Secret 中包含了访问 Kubernetes API 所需要的凭据。</p><p>如果需要，可以禁止或者重载这种自动创建并使用 API 凭据的操作。 不过，如果你仅仅是希望能够安全地访问 API 服务器，这是建议的工作方式。</p><p>参考 <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poL2RvY3MvdGFza3MvY29uZmlndXJlLXBvZC1jb250YWluZXIvY29uZmlndXJlLXNlcnZpY2UtYWNjb3VudC8=">ServiceAccount</span> 文档了解服务账号的工作原理。你也可以查看 <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvcmVmZXJlbmNlL2dlbmVyYXRlZC9rdWJlcm5ldGVzLWFwaS92MS4yMC8jcG9kLXYxLWNvcmU=">Pod</span> 资源中的 automountServiceAccountToken 和 serviceAccountName 字段文档，了解 从 Pod 中引用服务账号。</p><h3 id="docker-配置-secret"><a class="anchor" href="#docker-配置-secret">#</a> Docker 配置 Secret</h3><p>你可以使用下面两种 <code>type</code> 值之一来创建 Secret，用以存放访问 Docker 仓库 来下载镜像的凭据。</p><ul><li><code>kubernetes.io/dockercfg</code></li><li><code>kubernetes.io/dockerconfigjson</code></li></ul><p>下面是一个 <span class="exturl" data-url="aHR0cDovL2t1YmVybmV0ZXMuaW8vZG9ja2VyY2Zn">kubernetes.io/dockercfg</span> 类型 Secret 的示例：</p><pre><code>apiVersion: v1
kind: Secret
metadata:
  name: secret-dockercfg
type: kubernetes.io/dockercfg
data:
  .dockercfg: |
        &quot;&lt;base64 encoded ~/.dockercfg file&gt;&quot;
</code></pre><blockquote><p><strong>说明：</strong><br>如果你不希望执行 base64 编码转换，可以使用 stringData 字段代替。</p></blockquote><p>当你使用清单文件来创建这两类 Secret 时，API 服务器会检查 data 字段中是否 存在所期望的主键，并且验证其中所提供的键值是否是合法的 JSON 数据。 不过，API 服务器不会检查 JSON 数据本身是否是一个合法的 Docker 配置文件内容。</p><pre><code>kubectl create secret docker-registry secret-tiger-docker \
  --docker-username=tiger \
  --docker-password=pass113 \
  --docker-email=tiger@acme.com
</code></pre><p>上面的命令创建一个类型为 <span class="exturl" data-url="aHR0cDovL2t1YmVybmV0ZXMuaW8vZG9ja2VyY29uZmlnanNvbg==">kubernetes.io/dockerconfigjson</span> 的 Secret。 如果你对 data 字段中的 .dockerconfigjson 内容进行转储，你会得到下面的 JSON 内容，而这一内容是一个合法的 Docker 配置文件。</p><pre><code>{
  &quot;auths&quot;: {
    &quot;https://index.docker.io/v1/&quot;: {
      &quot;username&quot;: &quot;tiger&quot;,
      &quot;password&quot;: &quot;pass113&quot;,
      &quot;email&quot;: &quot;tiger@acme.com&quot;,
      &quot;auth&quot;: &quot;dGlnZXI6cGFzczExMw==&quot;
    }
  }
}
</code></pre><h3 id="基本身份认证-secret"><a class="anchor" href="#基本身份认证-secret">#</a> 基本身份认证 Secret</h3><p><code>kubernetes.io/basic-auth</code> 类型用来存放用于基本身份认证所需的凭据信息。 使用这种 Secret 类型时，Secret 的 data 字段必须包含以下两个键：</p><ul><li><code>username</code> : 用于身份认证的用户名；</li><li><code>password</code> : 用于身份认证的密码或令牌。<br>以上两个键的键值都是 base64 编码的字符串。 当然你也可以在创建 Secret 时使用 <code>stringData</code> 字段来提供明文形式的内容。 下面的 YAML 是基本身份认证 Secret 的一个示例清单：</li></ul><pre><code>apiVersion: v1
kind: Secret
metadata:
  name: secret-basic-auth
type: kubernetes.io/basic-auth
stringData:
  username: admin
  password: t0p-Secret
</code></pre><p>提供基本身份认证类型的 Secret 仅仅是出于用户方便性考虑。 你也可以使用 Opaque 类型来保存用于基本身份认证的凭据。 不过，使用内置的 Secret 类型的有助于对凭据格式进行归一化处理，并且 API 服务器确实会检查 Secret 配置中是否提供了所需要的主键。</p><h3 id="ssh-身份认证-secret"><a class="anchor" href="#ssh-身份认证-secret">#</a> SSH 身份认证 Secret</h3><p>Kubernetes 所提供的内置类型 <code>kubernetes.io/ssh-auth</code> 用来存放 <code>SSH</code> 身份认证中 所需要的凭据。使用这种 Secret 类型时，你就必须在其 <code>data</code> （或 <code>stringData</code> ） 字段中提供一个 ssh-privatekey 键值对，作为要使用的 SSH 凭据。</p><p>下面的 YAML 是一个 SSH 身份认证 Secret 的配置示例：</p><pre><code>apiVersion: v1
kind: Secret
metadata:
  name: secret-ssh-auth
type: kubernetes.io/ssh-auth
data:
  # 此例中的实际数据被截断
  ssh-privatekey: |
          MIIEpQIBAAKCAQEAulqb/Y ...
</code></pre><p>提供 SSH 身份认证类型的 Secret 仅仅是出于用户方便性考虑。 你也可以使用 Opaque 类型来保存用于 SSH 身份认证的凭据。 不过，使用内置的 Secret 类型的有助于对凭据格式进行归一化处理，并且 API 服务器确实会检查 Secret 配置中是否提供了所需要的主键。</p><blockquote><p><strong>注意</strong>： SSH 私钥自身无法建立 SSH 客户端与服务器端之间的可信连接。 需要其它方式来建立这种信任关系，以缓解 “中间人（Man In The Middle）” 攻击，例如向 ConfigMap 中添加一个 known_hosts 文件。</p></blockquote><h3 id="tls-secret"><a class="anchor" href="#tls-secret">#</a> TLS Secret</h3><p>Kubernetes 提供一种内置的 <code>kubernetes.io/tls</code> Secret 类型，用来存放证书 及其相关密钥（通常用在 TLS 场合）。 此类数据主要提供给 Ingress 资源，用以终结 TLS 链接，不过也可以用于其他 资源或者负载。当使用此类型的 Secret 时，Secret 配置中的 <code>data</code> （或 <code>stringData</code> ）字段必须包含 <code>tls.key</code> 和 <code>tls.crt</code> 主键，尽管 API 服务器 实际上并不会对每个键的取值作进一步的合法性检查。</p><p>下面的 YAML 包含一个 TLS Secret 的配置示例：</p><pre><code>apiVersion: v1
kind: Secret
metadata:
  name: secret-tls
type: kubernetes.io/tls
data:
  # 此例中的数据被截断
  tls.crt: |
        MIIC2DCCAcCgAwIBAgIBATANBgkqh ...
  tls.key: |
        MIIEpgIBAAKCAQEA7yn3bRHQ5FHMQ ...
</code></pre><p>提供 TLS 类型的 Secret 仅仅是出于用户方便性考虑。 你也可以使用 Opaque 类型来保存用于 TLS 服务器与 / 或客户端的凭据。 不过，使用内置的 Secret 类型的有助于对凭据格式进行归一化处理，并且 API 服务器确实会检查 Secret 配置中是否提供了所需要的主键。</p><p>当使用 kubectl 来创建 TLS Secret 时，你可以像下面的例子一样使用 tls 子命令：</p><pre><code>kubectl create secret tls my-tls-secret \
  --cert=path/to/cert/file \
  --key=path/to/key/file
</code></pre><p>这里的公钥 / 私钥对都必须事先已存在。用于 <code>--cert</code> 的公钥证书必须是 <code>.PEM</code> 编码的 （Base64 编码的 DER 格式），且与 <code>--key</code> 所给定的私钥匹配。 私钥必须是通常所说的 PEM 私钥格式，且未加密。对这两个文件而言，PEM 格式数据 的第一行和最后一行（例如，证书所对应的 <code>--------BEGIN CERTIFICATE-----</code> 和 <code>-------END CERTIFICATE----</code> ）都不会包含在其中。</p><h3 id="启动引导令牌-secret"><a class="anchor" href="#启动引导令牌-secret">#</a> 启动引导令牌 Secret</h3><p>通过将 Secret 的 <code>type</code> 设置为 <code>bootstrap.kubernetes.io/token</code> 可以创建 启动引导令牌类型的 Secret。这种类型的 Secret 被设计用来支持节点的启动引导过程。 其中包含用来为周知的 ConfigMap 签名的令牌。</p><p>启动引导令牌 Secret 通常创建于 <code>kube-system</code> 名字空间内，并以 <code>bootstrap-token-&lt;令牌 ID&gt;</code> 的形式命名；其中 <code>&lt;令牌 ID&gt;</code> 是一个由 6 个字符组成 的字符串，用作令牌的标识。</p><h2 id="创建secret"><a class="anchor" href="#创建secret">#</a> 创建 Secret</h2><p>有几种不同的方式来创建 Secret：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poL2RvY3MvdGFza3MvY29uZmlnbWFwLXNlY3JldC9tYW5hZ2luZy1zZWNyZXQtdXNpbmcta3ViZWN0bC8=">使用 kubectl 命令创建 Secret</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poL2RvY3MvdGFza3MvY29uZmlnbWFwLXNlY3JldC9tYW5hZ2luZy1zZWNyZXQtdXNpbmctY29uZmlnLWZpbGUv">使用配置文件来创建 Secret</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poL2RvY3MvdGFza3MvY29uZmlnbWFwLXNlY3JldC9tYW5hZ2luZy1zZWNyZXQtdXNpbmcta3VzdG9taXplLw==">使用 kustomize 来创建 Secret</span></li></ul><h2 id="编辑-secret"><a class="anchor" href="#编辑-secret">#</a> 编辑 Secret</h2><p>你可以通过下面的命令编辑现有的 Secret：</p><pre><code>kubectl edit secrets mysecret
</code></pre><p>这一命令会打开默认的编辑器，允许你更新 data 字段中包含的 base64 编码的 Secret 值</p><h2 id="使用-secret"><a class="anchor" href="#使用-secret">#</a> 使用 Secret</h2><p>Secret 可以作为数据卷被挂载，或作为<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poL2RvY3MvY29uY2VwdHMvY29udGFpbmVycy9jb250YWluZXItZW52aXJvbm1lbnQv">环境变量</span> 暴露出来以供 Pod 中的容器使用。它们也可以被系统的其他部分使用，而不直接暴露在 Pod 内。 例如，它们可以保存凭据，系统的其他部分将用它来代表你与外部系统进行交互。</p><h3 id="在pod中使用secret文件"><a class="anchor" href="#在pod中使用secret文件">#</a> 在 Pod 中使用 Secret 文件</h3><p>在 Pod 中使用存放在卷中的 Secret：</p><ol><li>创建一个 Secret 或者使用已有的 Secret。多个 Pod 可以引用同一个 Secret。</li><li>修改你的 Pod 定义，在 <code>spec.volumes[]</code> 下增加一个卷。可以给这个卷随意命名， 它的 <code>spec.volumes[].secret.secretName</code> 必须是 Secret 对象的名字。</li><li>将 <code>spec.containers[].volumeMounts[]</code> 加到需要用到该 Secret 的容器中。 指定 <code>spec.containers[].volumeMounts[].readOnly = true</code> 和 <code>spec.containers[].volumeMounts[].mountPath</code> 为你想要该 Secret 出现的尚未使用的目录。</li><li>修改你的镜像并且／或者命令行，让程序从该目录下寻找文件。 Secret 的 data 映射中的每一个键都对应 <code>mountPath</code> 下的一个文件名。</li></ol><p>这是一个在 Pod 中使用存放在挂载卷中 Secret 的例子：</p><pre><code>apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
  - name: mypod
    image: redis
    volumeMounts:
    - name: foo
      mountPath: &quot;/etc/foo&quot;
      readOnly: true
  volumes:
  - name: foo
    secret:
      secretName: mysecret
</code></pre><p>您想要用的每个 Secret 都需要在 <code>spec.volumes</code> 中引用。</p><p>如果 Pod 中有多个容器，每个容器都需要自己的 <code>volumeMounts</code> 配置块， 但是每个 Secret 只需要一个 <code>spec.volumes</code> 。</p><p>您可以打包多个文件到一个 Secret 中，或者使用的多个 Secret，怎样方便就怎样来。</p><h3 id="将-secret-键名映射到特定路径"><a class="anchor" href="#将-secret-键名映射到特定路径">#</a> 将 Secret 键名映射到特定路径</h3><p>我们还可以控制 Secret 键名在存储卷中映射的的路径。 你可以使用 spec.volumes [].secret.items 字段修改每个键对应的目标路径：</p><pre><code>apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
  - name: mypod
    image: redis
    volumeMounts:
    - name: foo
      mountPath: &quot;/etc/foo&quot;
      readOnly: true
  volumes:
  - name: foo
    secret:
      secretName: mysecret
      items:
      - key: username
        path: my-group/my-username
</code></pre><p>将会发生什么呢：</p><ul><li><code>username</code> Secret 存储在 <code>/etc/foo/my-group/my-username</code> 文件中而不是 <code>/etc/foo/username</code> 中。</li><li><code>password</code> Secret 没有被映射<br>如果使用了 <code>spec.volumes[].secret.items</code> ，只有在 <code>items</code> 中指定的键会被映射。 要使用 Secret 中所有键，就必须将它们都列在 <code>items</code> 字段中。 所有列出的键名必须存在于相应的 Secret 中。否则，不会创建卷</li></ul><h3 id="secret-文件权限"><a class="anchor" href="#secret-文件权限">#</a> Secret 文件权限</h3><p>你还可以指定 Secret 将拥有的权限模式位。如果不指定，默认使用 0644。 你可以为整个 Secret 卷指定默认模式；如果需要，可以为每个密钥设定重载值。</p><p>例如，您可以指定如下默认模式：</p><pre><code>apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
  - name: mypod
    image: redis
    volumeMounts:
    - name: foo
      mountPath: &quot;/etc/foo&quot;
  volumes:
  - name: foo
    secret:
      secretName: mysecret
      defaultMode: 256
</code></pre><p>之后，Secret 将被挂载到 /etc/foo 目录，而所有通过该 Secret 卷挂载 所创建的文件的权限都是 0400。</p><p>请注意，JSON 规范不支持八进制符号，因此使用 256 值作为 0400 权限。 如果你使用 YAML 而不是 JSON，则可以使用八进制符号以更自然的方式指定权限。</p><p>注意，如果你通过 <code>kubectl exec</code> 进入到 Pod 中，你需要沿着符号链接来找到 所期望的文件模式。例如，下面命令检查 Secret 文件的访问模式：</p><pre><code>kubectl exec mypod -it sh

cd /etc/foo
ls -l
</code></pre><p>输出类似于：</p><pre><code>total 0
lrwxrwxrwx 1 root root 15 May 18 00:18 password -&gt; ..data/password
lrwxrwxrwx 1 root root 15 May 18 00:18 username -&gt; ..data/username
</code></pre><h3 id="挂载的-secret-会被自动更新"><a class="anchor" href="#挂载的-secret-会被自动更新">#</a> 挂载的 Secret 会被自动更新</h3><p>当已经存储于卷中被使用的 Secret 被更新时，被映射的键也将终将被更新。 组件 kubelet 在周期性同步时检查被挂载的 Secret 是不是最新的。 但是，它会使用其本地缓存的数值作为 Secret 的当前值</p><blockquote><p><strong>Note:</strong> 说明： 使用 Secret 作为<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poL2RvY3MvY29uY2VwdHMvc3RvcmFnZS92b2x1bWVzLyN1c2luZy1zdWJwYXRo">子路径卷</span>挂载的容器 不会收到 Secret 更新。</p></blockquote><h3 id="以环境变量的形式使用secrets"><a class="anchor" href="#以环境变量的形式使用secrets">#</a> 以环境变量的形式使用 Secrets</h3><p>将 Secret 作为 Pod 中的<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poL2RvY3MvY29uY2VwdHMvY29udGFpbmVycy9jb250YWluZXItZW52aXJvbm1lbnQv">环境变量</span>使用：</p><ol><li>创建一个 Secret 或者使用一个已存在的 Secret。多个 Pod 可以引用同一个 Secret。</li><li>修改 Pod 定义，为每个要使用 Secret 的容器添加对应 Secret 键的环境变量。 使用 Secret 键的环境变量应在 <code>env[x].valueFrom.secretKeyRef</code> 中指定 要包含的 Secret 名称和键名。</li><li>更改镜像并／或者命令行，以便程序在指定的环境变量中查找值。</li></ol><p>这是一个使用来自环境变量中的 Secret 值的 Pod 示例：</p><pre><code>apiVersion: v1
kind: Pod
metadata:
  name: secret-env-pod
spec:
  containers:
  - name: mycontainer
    image: redis
    env:
      - name: SECRET_USERNAME
        valueFrom:
          secretKeyRef:
            name: mysecret
            key: username
      - name: SECRET_PASSWORD
        valueFrom:
          secretKeyRef:
            name: mysecret
            key: password
  restartPolicy: Never
</code></pre><h4 id="使用来自环境变量的-secret-值"><a class="anchor" href="#使用来自环境变量的-secret-值">#</a> 使用来自环境变量的 Secret 值</h4><p>在一个以环境变量形式使用 Secret 的容器中，Secret 键表现为常规的环境变量，其中 包含 Secret 数据的 base-64 解码值。这是从上面的示例在容器内执行的命令的结果：</p><pre><code>echo $SECRET_USERNAME
</code></pre><p><strong><code>Secret 更新之后对应的环境变量不会被更新</code></strong></p><p>如果某个容器已经在通过环境变量使用某 Secret，对该 Secret 的更新不会被 容器马上看见，除非容器被重启。有一些第三方的解决方案能够在 Secret 发生 变化时触发容器重启。</p><h2 id="不可更改的-secret"><a class="anchor" href="#不可更改的-secret">#</a> 不可更改的 Secret</h2><p>FEATURE STATE: Kubernetes v1.19 [beta]</p><p>Kubernetes 的 alpha 特性 不可变的 Secret 和 ConfigMap 提供了一种可选配置， 可以设置各个 Secret 和 ConfigMap 为不可变的。对于大量使用 Secret 的集群（至少有成千上万各不相同的 Secret 供 Pod 挂载）， 禁止变更它们的数据有下列好处：</p><p>防止意外（或非预期的）更新导致应用程序中断<br>通过将 Secret 标记为不可变来关闭 kube-apiserver 对其的监视，从而显著降低 kube-apiserver 的负载，提升集群性能。</p><p>这个特性通过 ImmutableEmphemeralVolumes 特性门控 来控制，从 v1.19 开始默认启用。 你可以通过将 Secret 的 immutable 字段设置为 true 创建不可更改的 Secret。 例如：</p><pre><code>apiVersion: v1
kind: Secret
metadata:
  ...
data:
  ...
immutable: true
</code></pre><blockquote><p><strong>说明：</strong><br>一旦一个 Secret 或 ConfigMap 被标记为不可更改，撤销此操作或者更改 data 字段的内容都是 不 可能的。 只能删除并重新创建这个 Secret。现有的 Pod 将维持对已删除 Secret 的挂载点 - 建议重新创建这些 Pod。</p></blockquote><h2 id="使用imagepullsecret"><a class="anchor" href="#使用imagepullsecret">#</a> 使用 imagePullSecret</h2><p><code>imagePullSecrets</code> 字段中包含一个列表，列举对同一名字空间中的 Secret 的引用。 你可以使用 <code>imagePullSecrets</code> 将包含 Docker（或其他）镜像仓库密码的 Secret 传递给 kubelet。kubelet 使用此信息来替你的 Pod 拉取私有镜像。 关于 <code>imagePullSecrets</code> 字段的更多信息，请参考 <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvcmVmZXJlbmNlL2dlbmVyYXRlZC9rdWJlcm5ldGVzLWFwaS92MS4yMC8jcG9kc3BlYy12MS1jb3Jl">PodSpec API</span> 文档。</p><h2 id="使用案例"><a class="anchor" href="#使用案例">#</a> 使用案例</h2><h3 id="案例以环境变量的形式使用-secret"><a class="anchor" href="#案例以环境变量的形式使用-secret">#</a> 案例：以环境变量的形式使用 Secret</h3><p>创建一个 Secret 定义：</p><pre><code>apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  USER_NAME: YWRtaW4=
  PASSWORD: MWYyZDFlMmU2N2Rm
</code></pre><p>生成 Secret 对象：</p><pre><code>kubectl apply -f mysecret.yaml
</code></pre><p>使用 <code>envFrom</code> 将 Secret 的所有数据定义为容器的环境变量。 Secret 中的键名称为 Pod 中的环境变量名称：</p><pre><code>apiVersion: v1
kind: Pod
metadata:
  name: secret-test-pod
spec:
  containers:
    - name: test-container
      image: k8s.gcr.io/busybox
      command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;env&quot; ]
      envFrom:
      - secretRef:
          name: mysecret
  restartPolicy: Never
</code></pre><h3 id="案例包含-ssh-密钥的-pod"><a class="anchor" href="#案例包含-ssh-密钥的-pod">#</a> 案例：包含 SSH 密钥的 Pod</h3><p>创建一个包含 SSH 密钥的 Secret：</p><pre><code>kubectl create secret generic ssh-key-secret \
  --from-file=ssh-privatekey=/path/to/.ssh/id_rsa \
  --from-file=ssh-publickey=/path/to/.ssh/id_rsa.pub
</code></pre><p>输出类似于：</p><pre><code>secret &quot;ssh-key-secret&quot; created
</code></pre><p>你也可以创建一个带有包含 SSH 密钥的 secretGenerator 字段的 kustomization.yaml 文件。</p><blockquote><p><strong><code>注意：</code> </strong>发送自己的 SSH 密钥之前要仔细思考：集群的其他用户可能有权访问该密钥。 你可以使用一个服务帐户，分享给 Kubernetes 集群中合适的用户，这些用户是你要分享的。 如果服务账号遭到侵犯，可以将其收回。</p></blockquote><p>现在我们可以创建一个 Pod，令其引用包含 SSH 密钥的 Secret，并通过存储卷来使用它：</p><pre><code>apiVersion: v1
kind: Pod
metadata:
  name: secret-test-pod
  labels:
    name: secret-test
spec:
  volumes:
  - name: secret-volume
    secret:
      secretName: ssh-key-secret
  containers:
  - name: ssh-test-container
    image: mySshImage
    volumeMounts:
    - name: secret-volume
      readOnly: true
      mountPath: &quot;/etc/secret-volume&quot;
</code></pre><p>容器中的命令运行时，密钥的片段可以在以下目录找到：</p><pre><code>/etc/secret-volume/ssh-publickey
/etc/secret-volume/ssh-privatekey
</code></pre><p>然后容器可以自由使用 Secret 数据建立一个 SSH 连接</p><h3 id="案例包含生产测试凭据的-pod"><a class="anchor" href="#案例包含生产测试凭据的-pod">#</a> 案例：包含生产 / 测试凭据的 Pod</h3><p>下面的例子展示的是两个 Pod。 一个 Pod 使用包含生产环境凭据的 Secret，另一个 Pod 使用包含测试环境凭据的 Secret。</p><p>你可以创建一个带有 <code>secretGenerator</code> 字段的 <code>kustomization.yaml</code> 文件，或者执行 <code>kubectl create secret</code> ：</p><pre><code>kubectl create secret generic prod-db-secret \
  --from-literal=username=produser \
  --from-literal=password=Y4nys7f11
</code></pre><pre><code>kubectl create secret generic test-db-secret \
  --from-literal=username=testuser \
  --from-literal=password=iluvtests
</code></pre><blockquote><p><strong>说明：</strong><br>特殊字符（例如 、\、*、= 和 !）会被你的 Shell解释，因此需要转义。 在大多数 Shell 中，对密码进行转义的最简单方式是用单引号（'）将其括起来。 例如，如果您的实际密码是 S!B\*dzDsb，则应通过以下方式执行命令：</p><pre><code>kubectl create secret generic dev-db-secret --from-literal=username=devuser --from-literal=password='S!B\*d$zDsb='
</code></pre><p>您无需对文件中的密码（--from-file）中的特殊字符进行转义。</p></blockquote><p>创建 pod ：</p><figure class="highlight yaml"><figcaption data-lang="YAML"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre>$ cat &lt;&lt;EOF <span class="token punctuation">></span> pod.yaml</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token key atrule">kind</span><span class="token punctuation">:</span> List</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token key atrule">items</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod</pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1</pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token key atrule">metadata</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token key atrule">name</span><span class="token punctuation">:</span> prod<span class="token punctuation">-</span>db<span class="token punctuation">-</span>client<span class="token punctuation">-</span>pod</pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token key atrule">labels</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="10"></td><td><pre>      <span class="token key atrule">name</span><span class="token punctuation">:</span> prod<span class="token punctuation">-</span>db<span class="token punctuation">-</span>client</pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token key atrule">spec</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> secret<span class="token punctuation">-</span>volume</pre></td></tr><tr><td data-num="14"></td><td><pre>      <span class="token key atrule">secret</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token key atrule">secretName</span><span class="token punctuation">:</span> prod<span class="token punctuation">-</span>db<span class="token punctuation">-</span>secret</pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token key atrule">containers</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> db<span class="token punctuation">-</span>client<span class="token punctuation">-</span>container</pre></td></tr><tr><td data-num="18"></td><td><pre>      <span class="token key atrule">image</span><span class="token punctuation">:</span> myClientImage</pre></td></tr><tr><td data-num="19"></td><td><pre>      <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="20"></td><td><pre>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> secret<span class="token punctuation">-</span>volume</pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token key atrule">readOnly</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> <span class="token string">"/etc/secret-volume"</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod</pre></td></tr><tr><td data-num="24"></td><td><pre>  <span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1</pre></td></tr><tr><td data-num="25"></td><td><pre>  <span class="token key atrule">metadata</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>db<span class="token punctuation">-</span>client<span class="token punctuation">-</span>pod</pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token key atrule">labels</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="28"></td><td><pre>      <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>db<span class="token punctuation">-</span>client</pre></td></tr><tr><td data-num="29"></td><td><pre>  <span class="token key atrule">spec</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> secret<span class="token punctuation">-</span>volume</pre></td></tr><tr><td data-num="32"></td><td><pre>      <span class="token key atrule">secret</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token key atrule">secretName</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>db<span class="token punctuation">-</span>secret</pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token key atrule">containers</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> db<span class="token punctuation">-</span>client<span class="token punctuation">-</span>container</pre></td></tr><tr><td data-num="36"></td><td><pre>      <span class="token key atrule">image</span><span class="token punctuation">:</span> myClientImage</pre></td></tr><tr><td data-num="37"></td><td><pre>      <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="38"></td><td><pre>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> secret<span class="token punctuation">-</span>volume</pre></td></tr><tr><td data-num="39"></td><td><pre>        <span class="token key atrule">readOnly</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> <span class="token string">"/etc/secret-volume"</span></pre></td></tr><tr><td data-num="41"></td><td><pre>EOF</pre></td></tr></table></figure><p>将 Pod 添加到同一个 kustomization.yaml 文件</p><pre><code>$ cat &lt;&lt;EOF &gt;&gt; kustomization.yaml
resources:
- pod.yaml
EOF
</code></pre><p>通过下面的命令应用所有对象</p><pre><code>kubectl apply -k .
</code></pre><p>两个容器都会在其文件系统上存在以下文件，其中包含容器对应的环境的值：</p><pre><code>/etc/secret-volume/username
/etc/secret-volume/password
</code></pre><p>请注意，两个 Pod 的规约配置中仅有一个字段不同；这有助于使用共同的 Pod 配置模板创建 具有不同能力的 Pod。</p><p>您可以使用两个服务账号进一步简化基本的 Pod 规约：</p><ol><li>名为 prod-user 的服务账号拥有 prod-db-secret</li><li>名为 test-user 的服务账号拥有 test-db-secret</li></ol><p>然后，Pod 规约可以缩短为：</p><figure class="highlight yaml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token key atrule">metadata</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token key atrule">name</span><span class="token punctuation">:</span> prod<span class="token punctuation">-</span>db<span class="token punctuation">-</span>client<span class="token punctuation">-</span>pod</pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token key atrule">labels</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token key atrule">name</span><span class="token punctuation">:</span> prod<span class="token punctuation">-</span>db<span class="token punctuation">-</span>client</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token key atrule">spec</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token key atrule">serviceAccount</span><span class="token punctuation">:</span> prod<span class="token punctuation">-</span>db<span class="token punctuation">-</span>client</pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token key atrule">containers</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> db<span class="token punctuation">-</span>client<span class="token punctuation">-</span>container</pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token key atrule">image</span><span class="token punctuation">:</span> myClientImage</pre></td></tr></table></figure><h3 id="案例secret-卷中以句点号开头的文件"><a class="anchor" href="#案例secret-卷中以句点号开头的文件">#</a> 案例：Secret 卷中以句点号开头的文件</h3><p>你可以通过定义以句点开头的键名，将数据 “隐藏” 起来。 例如，当如下 Secret 被挂载到 <code>secret-volume</code> 卷中：</p><figure class="highlight yaml"><figcaption data-lang="YAML"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token key atrule">kind</span><span class="token punctuation">:</span> Secret</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token key atrule">metadata</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token key atrule">name</span><span class="token punctuation">:</span> dotfile<span class="token punctuation">-</span>secret</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token key atrule">data</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token key atrule">.secret-file</span><span class="token punctuation">:</span> dmFsdWUtMg0KDQo=</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">---</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token key atrule">metadata</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token key atrule">name</span><span class="token punctuation">:</span> secret<span class="token punctuation">-</span>dotfiles<span class="token punctuation">-</span>pod</pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token key atrule">spec</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token key atrule">volumes</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> secret<span class="token punctuation">-</span>volume</pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token key atrule">secret</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="16"></td><td><pre>      <span class="token key atrule">secretName</span><span class="token punctuation">:</span> dotfile<span class="token punctuation">-</span>secret</pre></td></tr><tr><td data-num="17"></td><td><pre>  <span class="token key atrule">containers</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> dotfile<span class="token punctuation">-</span>test<span class="token punctuation">-</span>container</pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token key atrule">image</span><span class="token punctuation">:</span> k8s.gcr.io/busybox</pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token key atrule">command</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">-</span> ls</pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token punctuation">-</span> <span class="token string">"-l"</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">-</span> <span class="token string">"/etc/secret-volume"</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> secret<span class="token punctuation">-</span>volume</pre></td></tr><tr><td data-num="26"></td><td><pre>      <span class="token key atrule">readOnly</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></pre></td></tr><tr><td data-num="27"></td><td><pre>      <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> <span class="token string">"/etc/secret-volume"</span></pre></td></tr></table></figure><p>卷中将包含唯一的叫做 <code>.secret-file</code> 的文件。 容器 <code>dotfile-test-containe</code> 中，该文件处于 <code>/etc/secret-volume/.secret-file</code> 路径下。</p><blockquote><p><strong>说明：</strong> 以点号开头的文件在 <code>ls -l</code> 的输出中会被隐藏起来； 列出目录内容时，必须使用 <code>ls -la</code> 才能看到它们。</p></blockquote><h3 id="案例secret-仅对-pod-中的一个容器可见"><a class="anchor" href="#案例secret-仅对-pod-中的一个容器可见">#</a> 案例：Secret 仅对 Pod 中的一个容器可见</h3><p>考虑一个需要处理 HTTP 请求、执行一些复杂的业务逻辑，然后使用 HMAC 签署一些消息的应用。 因为应用程序逻辑复杂，服务器中可能会存在一个未被注意的远程文件读取漏洞， 可能会将私钥暴露给攻击者。</p><p>解决的办法可以是将应用分为两个进程，分别运行在两个容器中： 前端容器，用于处理用户交互和业务逻辑，但无法看到私钥； 签名容器，可以看到私钥，响应来自前端（例如通过本地主机网络）的简单签名请求。</p><p>使用这种分割方法，攻击者现在必须欺骗应用程序服务器才能进行任意的操作， 这可能比使其读取文件更难。</p><h2 id="最佳实践"><a class="anchor" href="#最佳实践">#</a> 最佳实践</h2><h3 id="客户端使用-secret-api"><a class="anchor" href="#客户端使用-secret-api">#</a> 客户端使用 Secret API</h3><p>当部署与 Secret API 交互的应用程序时，应使用 <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poL2RvY3MvcmVmZXJlbmNlL2FjY2Vzcy1hdXRobi1hdXRoei9hdXRob3JpemF0aW9uLw==">鉴权策略</span>， 例如 <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poL2RvY3MvcmVmZXJlbmNlL2FjY2Vzcy1hdXRobi1hdXRoei9yYmFjLw==">RBAC</span>，来限制访问。</p><h2 id="安全属性"><a class="anchor" href="#安全属性">#</a> 安全属性</h2><h3 id="保护"><a class="anchor" href="#保护">#</a> 保护</h3><p>因为 Secret 对象可以独立于使用它们的 Pod 而创建，所以在创建、查看和编辑 Pod 的流程中 Secret 被暴露的风险较小。系统还可以对 Secret 对象采取额外的预防性保护措施， 例如，在可能的情况下避免将其写到磁盘。</p><p>只有当某节点上的 Pod 需要用到某 Secret 时，该 Secret 才会被发送到该节点上。 Secret 不会被写入磁盘，而是被 kubelet 存储在 tmpfs 中。 一旦依赖于它的 Pod 被删除，Secret 数据的本地副本就被删除。</p><p>同一节点上的很多个 Pod 可能拥有多个 Secret。 但是，只有 Pod 所请求的 Secret 在其容器中才是可见的。 因此，一个 Pod 不能访问另一个 Pod 的 Secret。</p><p>同一个 Pod 中可能有多个容器。但是，Pod 中的每个容器必须通过 volumeeMounts 请求挂载 Secret 卷才能使卷中的 Secret 对容器可见。 这一实现可以用于在 Pod 级别<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poL2RvY3MvY29uY2VwdHMvY29uZmlndXJhdGlvbi9zZWNyZXQvI3NlY3JldC12aXNpYmxlLXRvLW9ubHktb25lLWNvbnRhaW5lcg==">构建安全分区</span>。</p><p>在大多数 Kubernetes 发行版中，用户与 API 服务器之间的通信以及 从 API 服务器到 kubelet 的通信都受到 SSL/TLS 的保护。 通过这些通道传输时，Secret 受到保护。</p><p>FEATURE STATE: Kubernetes v1.13 [beta]</p><p>你可以为 Secret 数据开启<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poL2RvY3MvdGFza3MvYWRtaW5pc3Rlci1jbHVzdGVyL2VuY3J5cHQtZGF0YS8=">静态加密</span>， 这样 Secret 数据就不会以明文形式存储到 etcd 中。</p><h2 id="风险"><a class="anchor" href="#风险">#</a> 风险</h2><ul><li>API 服务器上的 Secret 数据以纯文本的方式存储在 etcd 中，因此：</li></ul><ul><li>管理员应该为集群数据开启静态加密（要求 v1.13 或者更高版本）。</li><li>管理员应该限制只有 admin 用户能访问 etcd；</li><li>API 服务器中的 Secret 数据位于 etcd 使用的磁盘上；管理员可能希望在不再使用时擦除 / 粉碎 etcd 使用的磁盘</li><li>如果 etcd 运行在集群内，管理员应该确保 etcd 之间的通信使用 SSL/TLS 进行加密。</li></ul><ul><li>如果您将 Secret 数据编码为 base64 的清单（JSON 或 YAML）文件，共享该文件或将其检入代码库，该密码将会被泄露。 Base64 编码不是一种加密方式，应该视同纯文本。</li><li>应用程序在从卷中读取 Secret 后仍然需要保护 Secret 的值，例如不会意外将其写入日志或发送给不信任方。</li><li>可以创建使用 Secret 的 Pod 的用户也可以看到该 Secret 的值。即使 API 服务器策略不允许用户读取 Secret 对象，用户也可以运行 Pod 导致 Secret 暴露。</li><li>目前，任何节点的 root 用户都可以通过模拟 kubelet 来读取 API 服务器中的任何 Secret。 仅向实际需要 Secret 的节点发送 Secret 数据才能限制节点的 root 账号漏洞的影响， 该功能还在计划中</li></ul><div class="tags"><a href="/tags/istio/" rel="tag"><i class="ic i-tag"></i> istio</a></div></div><footer><div class="meta"></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Kung-Fu-Master 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Kung-Fu-Master 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="Kung-Fu-Master 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Kung-Fu-Master <i class="ic i-at"><em>@</em></i>Hexo</li><li class="link"><strong>本文链接：</strong> <a href="https://kung-fu-master.github.io/2021/03/13/microService/kubernetes/k8s_secret/" title="k8s secret">https://kung-fu-master.github.io/2021/03/13/microService/kubernetes/k8s_secret/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2021/03/13/linux/linux%E6%97%A5%E5%BF%97_%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicit31ffoj20zk0m8naf.jpg" title="查看 linux 系统日志 和 服务的日志"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> linux</span><h3>查看 linux 系统日志 和 服务的日志</h3></a></div><div class="item right"><a href="/2021/03/13/microService/kubernetes/k8s_node%E8%8A%82%E7%82%B9reset%E5%90%8E%E9%87%8D%E6%96%B0%E5%8A%A0%E5%85%A5%E9%9B%86%E7%BE%A4/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclga70tsj20zk0m84mr.jpg" title="k8s node 节点reset后重新加入集群"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> kubernetes</span><h3>k8s node 节点reset后重新加入集群</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#secret"><span class="toc-number">1.</span> <span class="toc-text"># Secret</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#secret-与-pod-生命周期的关系"><span class="toc-number">2.</span> <span class="toc-text"># Secret 与 Pod 生命周期的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#secret-概览"><span class="toc-number">3.</span> <span class="toc-text"># Secret 概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#secret-的类型"><span class="toc-number">4.</span> <span class="toc-text"># Secret 的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#opaque-secret"><span class="toc-number">4.1.</span> <span class="toc-text"># Opaque Secret</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务账号令牌-secret"><span class="toc-number">4.2.</span> <span class="toc-text"># 服务账号令牌 Secret</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-配置-secret"><span class="toc-number">4.3.</span> <span class="toc-text"># Docker 配置 Secret</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本身份认证-secret"><span class="toc-number">4.4.</span> <span class="toc-text"># 基本身份认证 Secret</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ssh-身份认证-secret"><span class="toc-number">4.5.</span> <span class="toc-text"># SSH 身份认证 Secret</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tls-secret"><span class="toc-number">4.6.</span> <span class="toc-text"># TLS Secret</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#启动引导令牌-secret"><span class="toc-number">4.7.</span> <span class="toc-text"># 启动引导令牌 Secret</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建secret"><span class="toc-number">5.</span> <span class="toc-text"># 创建 Secret</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编辑-secret"><span class="toc-number">6.</span> <span class="toc-text"># 编辑 Secret</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-secret"><span class="toc-number">7.</span> <span class="toc-text"># 使用 Secret</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#在pod中使用secret文件"><span class="toc-number">7.1.</span> <span class="toc-text"># 在 Pod 中使用 Secret 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将-secret-键名映射到特定路径"><span class="toc-number">7.2.</span> <span class="toc-text"># 将 Secret 键名映射到特定路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#secret-文件权限"><span class="toc-number">7.3.</span> <span class="toc-text"># Secret 文件权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#挂载的-secret-会被自动更新"><span class="toc-number">7.4.</span> <span class="toc-text"># 挂载的 Secret 会被自动更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#以环境变量的形式使用secrets"><span class="toc-number">7.5.</span> <span class="toc-text"># 以环境变量的形式使用 Secrets</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用来自环境变量的-secret-值"><span class="toc-number">7.5.1.</span> <span class="toc-text"># 使用来自环境变量的 Secret 值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不可更改的-secret"><span class="toc-number">8.</span> <span class="toc-text"># 不可更改的 Secret</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用imagepullsecret"><span class="toc-number">9.</span> <span class="toc-text"># 使用 imagePullSecret</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用案例"><span class="toc-number">10.</span> <span class="toc-text"># 使用案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#案例以环境变量的形式使用-secret"><span class="toc-number">10.1.</span> <span class="toc-text"># 案例：以环境变量的形式使用 Secret</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#案例包含-ssh-密钥的-pod"><span class="toc-number">10.2.</span> <span class="toc-text"># 案例：包含 SSH 密钥的 Pod</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#案例包含生产测试凭据的-pod"><span class="toc-number">10.3.</span> <span class="toc-text"># 案例：包含生产 &#x2F; 测试凭据的 Pod</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#案例secret-卷中以句点号开头的文件"><span class="toc-number">10.4.</span> <span class="toc-text"># 案例：Secret 卷中以句点号开头的文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#案例secret-仅对-pod-中的一个容器可见"><span class="toc-number">10.5.</span> <span class="toc-text"># 案例：Secret 仅对 Pod 中的一个容器可见</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最佳实践"><span class="toc-number">11.</span> <span class="toc-text"># 最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#客户端使用-secret-api"><span class="toc-number">11.1.</span> <span class="toc-text"># 客户端使用 Secret API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#安全属性"><span class="toc-number">12.</span> <span class="toc-text"># 安全属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#保护"><span class="toc-number">12.1.</span> <span class="toc-text"># 保护</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#风险"><span class="toc-number">13.</span> <span class="toc-text"># 风险</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2021/03/13/microService/kubernetes/02_kubernetes_roles_introduction/" rel="bookmark" title="02 kubernetes introduction">02 kubernetes introduction</a></li><li><a href="/2021/03/13/microService/kubernetes/01_etcd_high_availablity/" rel="bookmark" title="01 部署external etcd集群">01 部署external etcd集群</a></li><li><a href="/2021/03/13/microService/kubernetes/01_kubernetes%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F%E5%92%8C%E9%85%8D%E7%BD%AE%E6%9D%A1%E4%BB%B6/" rel="bookmark" title="01 Kubernetes安装方式和配置条件">01 Kubernetes安装方式和配置条件</a></li><li><a href="/2021/03/13/microService/kubernetes/05_kubernetes_volume/" rel="bookmark" title="05 Kubernetes volumes">05 Kubernetes volumes</a></li><li><a href="/2021/03/13/microService/kubernetes/07_kubernetes_Etcd/" rel="bookmark" title="07 Kubernetes Etcd">07 Kubernetes Etcd</a></li><li><a href="/2021/03/13/microService/kubernetes/04_kubernetes_service/" rel="bookmark" title="04 Kubernetes service">04 Kubernetes service</a></li><li><a href="/2021/03/13/microService/kubernetes/03_kubernetes_ns_pod/" rel="bookmark" title="03 Kubernetes nodes, namespace, pod">03 Kubernetes nodes, namespace, pod</a></li><li><a href="/2021/03/13/microService/kubernetes/06_kubernetes_deployment/" rel="bookmark" title="06 Kubernetes deployment">06 Kubernetes deployment</a></li><li><a href="/2021/03/13/microService/kubernetes/08_kubernetes_samples_problems/" rel="bookmark" title="08 Kubernetes samples and problems">08 Kubernetes samples and problems</a></li><li><a href="/2021/03/13/microService/kubernetes/09_kubernetes_certificate/" rel="bookmark" title="09 Kubernetes Certificates">09 Kubernetes Certificates</a></li><li><a href="/2021/03/13/microService/kubernetes/k8s_command_args_entrypoint_cmd%E5%8C%BA%E5%88%AB/" rel="bookmark" title="k8s command, args, entrypoint, cmd 区别">k8s command, args, entrypoint, cmd 区别</a></li><li><a href="/2021/03/13/microService/kubernetes/10_kubernetes_plugin/" rel="bookmark" title="10 Kubernetes plugin">10 Kubernetes plugin</a></li><li><a href="/2021/03/13/microService/kubernetes/k8s_port_forward/" rel="bookmark" title="使用端口转发(Port Forwarding)来访问集群中的应用">使用端口转发(Port Forwarding)来访问集群中的应用</a></li><li><a href="/2021/03/13/microService/kubernetes/k8s_configmap/" rel="bookmark" title="k8s configmap">k8s configmap</a></li><li><a href="/2021/03/13/microService/kubernetes/k8s_%E5%AF%B9%E8%B1%A1%E5%90%8D%E7%A7%B0%E5%92%8CIDs/" rel="bookmark" title="k8s_对象名称和IDs">k8s_对象名称和IDs</a></li><li><a href="/2021/03/13/microService/kubernetes/k8s_resources%E5%92%8C%E9%A9%B1%E9%80%90%E7%AD%96%E7%95%A5/" rel="bookmark" title="k8s resources和驱逐策略">k8s resources和驱逐策略</a></li><li><a href="/2021/03/13/microService/kubernetes/k8s_node%E8%8A%82%E7%82%B9reset%E5%90%8E%E9%87%8D%E6%96%B0%E5%8A%A0%E5%85%A5%E9%9B%86%E7%BE%A4/" rel="bookmark" title="k8s node 节点reset后重新加入集群">k8s node 节点reset后重新加入集群</a></li><li class="active"><a href="/2021/03/13/microService/kubernetes/k8s_secret/" rel="bookmark" title="k8s secret">k8s secret</a></li><li><a href="/2021/03/13/microService/kubernetes/kubernetes_%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/" rel="bookmark" title="kubernetes 准入控制">kubernetes 准入控制</a></li><li><a href="/2021/03/13/microService/kubernetes/kubernetes_upgrade/" rel="bookmark" title="kubernetes upgrade">kubernetes upgrade</a></li><li><a href="/2021/03/13/microService/kubernetes/metrics-server,kubernetes-dashboard/" rel="bookmark" title="Metrics-Server, Kubernetes-Dashboard">Metrics-Server, Kubernetes-Dashboard</a></li><li><a href="/2021/03/13/microService/kubernetes/k8s%E9%87%8D%E6%96%B0%E5%90%AF%E5%8A%A8pod%E7%AD%89%E8%B5%84%E6%BA%90/" rel="bookmark" title="k8s重新启动pod等资源">k8s重新启动pod等资源</a></li><li><a href="/2021/03/21/linux/%E5%88%A0%E9%99%A4crd,pod,pv,pvc%E7%AD%89%E8%B5%84%E6%BA%90/" rel="bookmark" title="删除crd,pod,pv,pvc等资源">删除crd,pod,pv,pvc等资源</a></li><li><a href="/2021/05/31/microService/kubernetes/01_kubernetes_build/" rel="bookmark" title="01 Kubernetes build with kubeadm">01 Kubernetes build with kubeadm</a></li><li><a href="/2021/05/31/microService/kubernetes/01_kubernetes_high_availablity_build/" rel="bookmark" title="01 Kubernetes build high availability">01 Kubernetes build high availability</a></li><li><a href="/2021/05/31/microService/kubernetes/k8s_cert_manager/" rel="bookmark" title="k8s cert manager">k8s cert manager</a></li><li><a href="/2021/05/31/microService/kubernetes/affinity/" rel="bookmark" title="affinity">affinity</a></li><li><a href="/2021/05/31/microService/kubernetes/delete_pod_pv_pvc%E7%AD%89%E8%B5%84%E6%BA%90/" rel="bookmark" title="删除crd,pod,pv,pvc等资源">删除crd,pod,pv,pvc等资源</a></li><li><a href="/2021/05/31/microService/kubernetes/k8s_commands/" rel="bookmark" title="k8s操作命令">k8s操作命令</a></li><li><a href="/2021/05/31/microService/kubernetes/k8s_encounter_problem/" rel="bookmark" title="k8s部署遇到的问题">k8s部署遇到的问题</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Kung-Fu-Master" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Kung-Fu-Master</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">321</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">42</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">14</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lvdXJuYW1l" title="https:&#x2F;&#x2F;github.com&#x2F;yourname"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yourname"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPXlvdXJpZA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;yourid"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2021/03/13/linux/linux%E6%97%A5%E5%BF%97_%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2021/03/13/microService/kubernetes/k8s_node%E8%8A%82%E7%82%B9reset%E5%90%8E%E9%87%8D%E6%96%B0%E5%8A%A0%E5%85%A5%E9%9B%86%E7%BE%A4/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/linux/" title="分类于 linux">linux</a></div><span><a href="/2021/03/13/linux/%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E9%94%99%E8%AF%AF_r_command%20not%20found/" title="脚本执行错误 $&#39;\r&#39;:command not found">脚本执行错误 $'\r':command not found</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/microService/" title="分类于 microService">microService</a> <i class="ic i-angle-right"></i> <a href="/categories/microService/istio/" title="分类于 istio">istio</a></div><span><a href="/2021/03/13/microService/istio/istio_authorization/" title="istio authorization">istio authorization</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/reference/" title="分类于 reference">reference</a> <i class="ic i-angle-right"></i> <a href="/categories/reference/k8s/" title="分类于 k8s">k8s</a></div><span><a href="/2021/03/13/reference/k8s/23.%E5%A3%B0%E6%98%8E%E5%BC%8FAPI%E4%B8%8EKubernetes%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/" title="23 | 声明式API与Kubernetes编程范式">23 | 声明式API与Kubernetes编程范式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/linux/" title="分类于 linux">linux</a></div><span><a href="/2021/03/13/linux/ssh-keygen_%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86/" title="ssh-keygen,known_hosts 免密登陆">ssh-keygen,known_hosts 免密登陆</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/reference/" title="分类于 reference">reference</a> <i class="ic i-angle-right"></i> <a href="/categories/reference/k8s/" title="分类于 k8s">k8s</a></div><span><a href="/2021/03/13/reference/k8s/45.%E5%B9%95%E5%90%8E%E8%8B%B1%E9%9B%84%EF%BC%9ASIG-Node%E4%B8%8ECRI/" title="45 | 幕后英雄：SIG-Node与CRI">45 | 幕后英雄：SIG-Node与CRI</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/linux/" title="分类于 linux">linux</a></div><span><a href="/2021/03/13/linux/linux%E7%BB%99grub%E6%B7%BB%E5%8A%A0%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0/" title="linux给grub添加内核启动参数">linux给grub添加内核启动参数</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/reference/" title="分类于 reference">reference</a> <i class="ic i-angle-right"></i> <a href="/categories/reference/k8s/" title="分类于 k8s">k8s</a></div><span><a href="/2021/03/13/reference/k8s/41.%E5%8D%81%E5%AD%97%E8%B7%AF%E5%8F%A3%E4%B8%8A%E7%9A%84Kubernetes%E9%BB%98%E8%AE%A4%E8%B0%83%E5%BA%A6%E5%99%A8/" title="41 | 十字路口上的Kubernetes默认调度器">41 | 十字路口上的Kubernetes默认调度器</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/microService/" title="分类于 microService">microService</a> <i class="ic i-angle-right"></i> <a href="/categories/microService/kubernetes/" title="分类于 kubernetes">kubernetes</a></div><span><a href="/2021/03/13/microService/kubernetes/metrics-server,kubernetes-dashboard/" title="Metrics-Server, Kubernetes-Dashboard">Metrics-Server, Kubernetes-Dashboard</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/blogs/" title="分类于 blogs">blogs</a> <i class="ic i-angle-right"></i> <a href="/categories/blogs/blog%E6%90%AD%E5%BB%BA/" title="分类于 blog搭建">blog搭建</a></div><span><a href="/2021/03/13/blogs/blog%E6%90%AD%E5%BB%BA/hexo%E5%B0%86jupyter_%E5%8A%A0%E5%85%A5%E5%8D%9A%E5%AE%A2%E6%96%B9%E6%B3%95/" title="hexo将jupyter *.ipynb文件加入博客方法">hexo将jupyter *.ipynb文件加入博客方法</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/language/" title="分类于 language">language</a> <i class="ic i-angle-right"></i> <a href="/categories/language/cpp/" title="分类于 cpp">cpp</a></div><span><a href="/2021/03/13/language/cpp/c++_learn_links/" title="c++ learn links">c++ learn links</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Kung-Fu-Master @ Kung Fu Master</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">1.2m 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">18:32</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2021/03/13/microService/kubernetes/k8s_secret/",favicon:{show:"（●´3｀●）",hide:"（●´3｀●）"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->