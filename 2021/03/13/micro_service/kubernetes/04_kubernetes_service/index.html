<!-- build time:Wed Mar 17 2021 03:26:53 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Hexo" href="https://kung-fu-master.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Hexo" href="https://kung-fu-master.github.io/atom.xml"><link rel="alternate" type="application/json" title="Hexo" href="https://kung-fu-master.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="kubernetes"><link rel="canonical" href="https://kung-fu-master.github.io/2021/03/13/micro_service/kubernetes/04_kubernetes_service/"><title>04 Kubernetes service - kubernetes - microService | Kung Fu Master = Hexo</title><meta name="generator" content="Hexo 4.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">04 Kubernetes service</h1><div class="meta"><span class="item" title="创建时间：2021-03-13 13:00:42"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-03-13T13:00:42+08:00">2021-03-13</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>17k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>15 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Kung Fu Master</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipexoj0moj20zk0m8kgu.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giph4baakhj20zk0m8h5q.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclhpw3lwj20zk0m8gvw.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giph4lm9i7j20zk0m84qp.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giciuja1j1j20zk0m8kjl.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipewkhf1zj20zk0m81kx.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/microService/" itemprop="item" rel="index" title="分类于 microService"><span itemprop="name">microService</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/microService/kubernetes/" itemprop="item" rel="index" title="分类于 kubernetes"><span itemprop="name">kubernetes</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://kung-fu-master.github.io/2021/03/13/micro_service/kubernetes/04_kubernetes_service/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Kung-Fu-Master"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hexo"></span><div class="body md" itemprop="articleBody"><h2 id="kubernetes-service"><a class="anchor" href="#kubernetes-service">#</a> Kubernetes Service</h2><blockquote><p>Kubemetes 服务是一种为一组功能相同的 pod 提供单一不变的接入点的资源.<br>当服务存在时，它的 IP 地址和端口不会改变。 客户端通过 IP 地址和端口号建立连接，这些连接会被路由到提供该服务的任意一个 pod 上.<br>通过这种方式， 客户端不需要知道每个单独的提供服务的 pod 的地址， 这样这些 pod 就可以在集群中随时被创建或移除.</p></blockquote><p>通过为前端 pod 创建服务， 并且将其配置成可以在集群外部访问，可以暴露一个单一不变的 IP 地址让外部的客户端连接 pod。<br>同理，可以为后台数据库 pod 创建服务，并为其分配一个固定的 IP 地址。尽管 pod 的 IP 地址会改变，但是服务的 IP 地址固定不变。<br>另外，通过创建服务，能够让前端的 pod 通过环境变量或 DNS 以及服务名来访问后端服务<br>Pod 控制器中使用标签选择器来指定哪些 pod 属于同一 Service。</p><h2 id="service"><a class="anchor" href="#service">#</a> service</h2><blockquote><p>如果 pod 的标签与服务的 pod 选择器相匹配，那么 pod 就将作为服务的后端。只要创建了具有适当标签的新 pod ，它就成为服务的一部分，并且请求开始被重定向到 pod.<br>如下所示 Service 和 POD 都采用命名端口的方式，最大的好处就是即使更换 spec pod 中的端口号也无须更改服务 spec.</p></blockquote><ul><li>第一步，创建 service<br>创建 service yaml 文件 kubia-svc.yaml</li></ul><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apiVersion: v1</pre></td></tr><tr><td data-num="2"></td><td><pre>	kind: Service</pre></td></tr><tr><td data-num="3"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="4"></td><td><pre>	  name: kubia</pre></td></tr><tr><td data-num="5"></td><td><pre>	sepc:</pre></td></tr><tr><td data-num="6"></td><td><pre>	// sessionAffinity: ClientIP	// 默认此值是None, 若改为ClientIP，则SVC接受到的请求连接只会固定转发给同一个pod</pre></td></tr><tr><td data-num="7"></td><td><pre>	  ports:</pre></td></tr><tr><td data-num="8"></td><td><pre>	  - name: http			// 端口别名，可以当作端口号用</pre></td></tr><tr><td data-num="9"></td><td><pre>	    port: 80			// 该服务可用的端口</pre></td></tr><tr><td data-num="10"></td><td><pre>	    targetPort: http	// 服务将连接转发到的POD端口, pod需要将http映射pod本身的8080或其它端口，否则这里只能填写端口号</pre></td></tr><tr><td data-num="11"></td><td><pre>	  - name: https</pre></td></tr><tr><td data-num="12"></td><td><pre>	    port: 443</pre></td></tr><tr><td data-num="13"></td><td><pre>	    targetPort: https	// 含有label:app=kubia的pod需要将https映射pod本身8443或其它端口，否则这里只能填写端口号</pre></td></tr><tr><td data-num="14"></td><td><pre>	  selector:</pre></td></tr><tr><td data-num="15"></td><td><pre>	    app: kubia			// 具有app=kubia标签的pod都属于该服务</pre></td></tr></table></figure><p>创建了 一个名叫 kubia 的服务，它将在端口 80 接收请求并将连接路由到具有标签选择器是 app=kubia 的 pod 的 8080 端口上.<br>在发布完 YAML 文件后， 可以在命名空间下列出来所有的服务资源，新的服务已经被分配了一个内部集群 IP, 只能在集群内部可以被访问.</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get svc</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>   AGE</pre></td></tr><tr><td data-num="3"></td><td><pre>	kubernetes   ClusterIP   <span class="token number">10.96</span>.0.1      <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">443</span>/TCP   23h</pre></td></tr><tr><td data-num="4"></td><td><pre>	kubia        ClusterIP   <span class="token number">10.98</span>.229.76   <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">80</span>/TCP    20s</pre></td></tr></table></figure><ul><li>第二步，创建两个 pod，一个添加标签 app=kubia，另一个用来执行测试通过 kubectl exec 来访问第一个 pod<br>kubia.yaml</li></ul><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apiVersion: v1</pre></td></tr><tr><td data-num="2"></td><td><pre>	kind: Pod</pre></td></tr><tr><td data-num="3"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="4"></td><td><pre>	  name: kubia	// name: kubia1; name: kubia2</pre></td></tr><tr><td data-num="5"></td><td><pre>	spec:</pre></td></tr><tr><td data-num="6"></td><td><pre>	  nodeSelector:		// pod被分配到含有标签gpu=true的node上，当然也可以注释掉这两行</pre></td></tr><tr><td data-num="7"></td><td><pre>	    gpu: "true"</pre></td></tr><tr><td data-num="8"></td><td><pre>	  containers:</pre></td></tr><tr><td data-num="9"></td><td><pre>	  - image: luksa/kubia</pre></td></tr><tr><td data-num="10"></td><td><pre>	    name: kubia</pre></td></tr></table></figure><p>kubia-label.yaml</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apiVersion: v1					// api服务版本</pre></td></tr><tr><td data-num="2"></td><td><pre>	 kind : Pod						// 资源类型</pre></td></tr><tr><td data-num="3"></td><td><pre>	 metadata:</pre></td></tr><tr><td data-num="4"></td><td><pre>	   name: kubia-label			// pod 名字</pre></td></tr><tr><td data-num="5"></td><td><pre>	   labels:</pre></td></tr><tr><td data-num="6"></td><td><pre>	     app: kubia					// pod添加label</pre></td></tr><tr><td data-num="7"></td><td><pre>	 spec :</pre></td></tr><tr><td data-num="8"></td><td><pre>	   nodeSelector:</pre></td></tr><tr><td data-num="9"></td><td><pre>	     gpu: "true"				// node 选择器</pre></td></tr><tr><td data-num="10"></td><td><pre>	   containers:</pre></td></tr><tr><td data-num="11"></td><td><pre>	   - image: luksa/kubia			// image 名字</pre></td></tr><tr><td data-num="12"></td><td><pre>	     name: kubia				// container 名字</pre></td></tr><tr><td data-num="13"></td><td><pre>	     ports:</pre></td></tr><tr><td data-num="14"></td><td><pre>	     - name: http				// pod端口映射，用http名字代替8080，名字随便取, 可以跟上面的service的targetPort对应起来</pre></td></tr><tr><td data-num="15"></td><td><pre>	       containerPort: 8080		// 用上面的名字定义这个端口号的别名</pre></td></tr><tr><td data-num="16"></td><td><pre>	     - name: https</pre></td></tr><tr><td data-num="17"></td><td><pre>	       containerPort: 8443</pre></td></tr></table></figure><p>查看 POD 并执行一个 POD 去通过上面创建的 service (通过 label) 包含的 pod 提供的服务.<br>其中 pod kubia-label 中 container 运行的服务进程监听了 8080 端口，POD 对外也暴露了 8080 端口</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get pod --show-labels</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME           READY   STATUS    RESTARTS   AGE    LABELS</pre></td></tr><tr><td data-num="3"></td><td><pre>	kubia          <span class="token number">1</span>/1     Running   <span class="token number">0</span>          101m   <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr><tr><td data-num="4"></td><td><pre>	kubia-label    <span class="token number">1</span>/1     Running   <span class="token number">0</span>          98m    <span class="token assign-left variable">app</span><span class="token operator">=</span>kubia</pre></td></tr><tr><td data-num="5"></td><td><pre>	kubia-label1   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          99s    <span class="token assign-left variable">app</span><span class="token operator">=</span>kubia</pre></td></tr><tr><td data-num="6"></td><td><pre>	kubia-label2   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          79s    <span class="token assign-left variable">app</span><span class="token operator">=</span>kubia</pre></td></tr></table></figure><ul><li>第三步：执行一个 pod 用 curl 命令访问另一个 pod 提供的服务<br>双横杠 (--) 代表着 kubectl 命令项的结束。在两个横杠之后的内容是指在 pod 内部需要执行的命令.<br>k8s 服务代理接续 curl 请求连接，三个包含 label 为 app=kubia 的 pod 任意选择一个 pod<br>访问服务三种方式，加不加端口都可以</li></ul><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token operator">&lt;</span>p<span class="token operator">></span>$ kubectl <span class="token builtin class-name">exec</span> kubia -- <span class="token function">curl</span> -s http://10.98.229.76:http<span class="token operator">&lt;</span>/p<span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre>	$ kubectl <span class="token builtin class-name">exec</span> kubia -- <span class="token function">curl</span> -s http://10.98.229.76:80</pre></td></tr><tr><td data-num="3"></td><td><pre>	$ kubectl <span class="token builtin class-name">exec</span> kubia -- <span class="token function">curl</span> -s http://10.98.229.76</pre></td></tr><tr><td data-num="4"></td><td><pre>	You<span class="token string">'ve hit kubia-label</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>	$ kubectl exec kubia -- curl -s http://10.98.229.76</pre></td></tr><tr><td data-num="7"></td><td><pre>	You've hit kubia-label2</pre></td></tr><tr><td data-num="8"></td><td><pre>	$ kubectl <span class="token builtin class-name">exec</span> kubia -- <span class="token function">curl</span> -s http://10.98.229.76</pre></td></tr><tr><td data-num="9"></td><td><pre>	You've hit kubia-label1</pre></td></tr></table></figure><h3 id="affinity-亲和性"><a class="anchor" href="#affinity-亲和性">#</a> Affinity 亲和性</h3><p>Kubernetes 仅仅支持两种形式的会话亲和性服务： None 和 ClientIP<br>这种方式将会使服务代理将来自同 一个 client IP 的所有请求转发至同 一个 pod 上.<br>Kubernetes 服务不是在 HTTP 层面上工作。服务处理 TCP 和 UDP 包，并不关心其中的载荷内容。<br>因为 cookie 是 HTTP 协议中的一部分，服务并不知道它们，这就解释了为什么会话亲和性不能基千 cookie。<br>如果希望特定客户端产生的所有请求每次都指向同 一个 pod, 可以设置服务的 sessionAffinity 属性为 ClientIP (而不是 None,None 是默认值）</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apiVersion: vl</pre></td></tr><tr><td data-num="2"></td><td><pre>	kind: Service</pre></td></tr><tr><td data-num="3"></td><td><pre>	spec:</pre></td></tr><tr><td data-num="4"></td><td><pre>	  sessionAffinity: ClientIP</pre></td></tr><tr><td data-num="5"></td><td><pre>	......</pre></td></tr></table></figure><h2 id="环境变量发现service"><a class="anchor" href="#环境变量发现service">#</a> 环境变量发现 service</h2><h3 id="创建replicaset-管理-3-个-pod"><a class="anchor" href="#创建replicaset-管理-3-个-pod">#</a> 创建 replicaSet 管理 3 个 POD</h3><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apiVersion: apps/v1</pre></td></tr><tr><td data-num="2"></td><td><pre>	kind: ReplicaSet</pre></td></tr><tr><td data-num="3"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="4"></td><td><pre>	  name: kubia</pre></td></tr><tr><td data-num="5"></td><td><pre>	spec:</pre></td></tr><tr><td data-num="6"></td><td><pre>	  replicas: 3</pre></td></tr><tr><td data-num="7"></td><td><pre>	  selector:</pre></td></tr><tr><td data-num="8"></td><td><pre>	    matchLabels:</pre></td></tr><tr><td data-num="9"></td><td><pre>	      app: kubia</pre></td></tr><tr><td data-num="10"></td><td><pre>	  template:</pre></td></tr><tr><td data-num="11"></td><td><pre>	    metadata:</pre></td></tr><tr><td data-num="12"></td><td><pre>	      labels:</pre></td></tr><tr><td data-num="13"></td><td><pre>	        app: kubia</pre></td></tr><tr><td data-num="14"></td><td><pre>	    spec:</pre></td></tr><tr><td data-num="15"></td><td><pre>	      nodeSelector:</pre></td></tr><tr><td data-num="16"></td><td><pre>	        gpu: "true"</pre></td></tr><tr><td data-num="17"></td><td><pre>	      containers:</pre></td></tr><tr><td data-num="18"></td><td><pre>	      - name: kubia</pre></td></tr><tr><td data-num="19"></td><td><pre>	        image: luksa/kubia</pre></td></tr><tr><td data-num="20"></td><td><pre>	        ports:</pre></td></tr><tr><td data-num="21"></td><td><pre>	        - name: http</pre></td></tr><tr><td data-num="22"></td><td><pre>	          containerPort: 8080</pre></td></tr><tr><td data-num="23"></td><td><pre>	        - name: https</pre></td></tr><tr><td data-num="24"></td><td><pre>	          containerPort: 8443</pre></td></tr></table></figure><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get svc </pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>          AGE</pre></td></tr><tr><td data-num="3"></td><td><pre>	kubernetes   ClusterIP   <span class="token number">10.96</span>.0.1       <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">443</span>/TCP          29h</pre></td></tr><tr><td data-num="4"></td><td><pre>	kubia        ClusterIP   <span class="token number">10.111</span>.88.195   <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">80</span>/TCP,443/TCP   3h46m</pre></td></tr></table></figure><p>查看 pod 所在的 service 对应的 IP 和端口</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl <span class="token builtin class-name">exec</span> kubia-5rvfq <span class="token function">env</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token assign-left variable">KUBERNETES_SERVICE_PORT</span><span class="token operator">=</span><span class="token number">443</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token assign-left variable">KUBIA_SERVICE_PORT</span><span class="token operator">=</span><span class="token number">80</span>				// 服务的集群IP</pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token assign-left variable">KUBERNETES_SERVICE_HOST</span><span class="token operator">=</span><span class="token number">10.96</span>.0.1</pre></td></tr><tr><td data-num="7"></td><td><pre>	<span class="token assign-left variable">KUBIA_SERVICE_HOST</span><span class="token operator">=</span><span class="token number">10.111</span>.88.195	// 服务所在的端口</pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span></pre></td></tr></table></figure><p>pod 是否使用 内 部的 DNS 服务器是根据 pod 中 spec 的 dnsPolicy 属性来决定的</p><p>进入容器后执行如下命令</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl <span class="token builtin class-name">exec</span> kubia-5rvfq -it -- <span class="token function">bash</span>		// -- 表示kubectl 命令执行完了，开始执行pod容器里要运行的命令</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ <span class="token function">curl</span> http://kubia.default.svc.cluster.local</pre></td></tr><tr><td data-num="3"></td><td><pre>	$ <span class="token function">curl</span> http://kubia.default</pre></td></tr><tr><td data-num="4"></td><td><pre>	$ <span class="token function">curl</span> http://kubia</pre></td></tr><tr><td data-num="5"></td><td><pre>	You've hit kubia-5rvfq</pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>	$ <span class="token function">cat</span> /etc/resolv.conf</pre></td></tr><tr><td data-num="8"></td><td><pre>	nameserver <span class="token number">10.96</span>.0.10		// 对应kube-system 里的服务kube-dns服务IP</pre></td></tr><tr><td data-num="9"></td><td><pre>	search default.svc.cluster.local svc.cluster.local cluster.local sh.intel.com</pre></td></tr><tr><td data-num="10"></td><td><pre>	options ndots:5</pre></td></tr><tr><td data-num="11"></td><td><pre>	root@kubia-5rvfq:/<span class="token comment"># curl http://svc.cluster.local</span></pre></td></tr><tr><td data-num="12"></td><td><pre>	curl: <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> Could not resolve host: svc.cluster.local</pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>	$ <span class="token function">ping</span> kubia</pre></td></tr><tr><td data-num="15"></td><td><pre>	PING kubia.default.svc.cluster.local <span class="token punctuation">(</span><span class="token number">10.111</span>.88.195<span class="token punctuation">)</span>: <span class="token number">56</span> data bytes</pre></td></tr><tr><td data-num="16"></td><td><pre>	^C--- kubia.default.svc.cluster.local <span class="token function">ping</span> statistics ---</pre></td></tr><tr><td data-num="17"></td><td><pre>	<span class="token number">4</span> packets transmitted, <span class="token number">0</span> packets received, <span class="token number">100</span>% packet loss</pre></td></tr></table></figure><p>上面的 curl 这个服务是工作的，但是却 ping 不通。这是 因为服务的集群 IP 是一个虚拟 IP，并且只有在与服务端口结合时才有意义。</p><p>查看 kube-system 下面 kube-dns 信息</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get svc -n kube-system</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>                  AGE</pre></td></tr><tr><td data-num="3"></td><td><pre>	kube-dns   ClusterIP   <span class="token number">10.96</span>.0.10   <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">53</span>/UDP,53/TCP,9153/TCP   2d3h</pre></td></tr></table></figure><h3 id="删除service"><a class="anchor" href="#删除service">#</a> 删除 service</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl delete svc kubia</pre></td></tr></table></figure><h2 id="service-samples"><a class="anchor" href="#service-samples">#</a> Service samples</h2><h3 id="查看service"><a class="anchor" href="#查看service">#</a> 查看 service</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get svc -n kube-system</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ kubectl get svc -n istio-system</pre></td></tr><tr><td data-num="3"></td><td><pre>	NAME                        TYPE           CLUSTER-IP       EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>                                                                                                                                      AGE</pre></td></tr><tr><td data-num="4"></td><td><pre>	grafana                     ClusterIP      <span class="token number">10.104</span>.1.236     <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">3000</span>/TCP                                                                                                                                     3d5h</pre></td></tr><tr><td data-num="5"></td><td><pre>	istio-egressgateway         ClusterIP      <span class="token number">10.107</span>.177.52    <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">80</span>/TCP,443/TCP,15443/TCP                                                                                                                     3d5h</pre></td></tr><tr><td data-num="6"></td><td><pre>	istio-ingressgateway        LoadBalancer   <span class="token number">10.97</span>.82.221     <span class="token operator">&lt;</span>pending<span class="token operator">></span>     <span class="token number">15020</span>:31237/TCP,80:31556/TCP,443:30614/TCP,15029:32511/TCP,15030:32423/TCP,15031:30670/TCP,15032:30961/TCP,31400:30196/TCP,15443:31028/TCP   3d5h</pre></td></tr><tr><td data-num="7"></td><td><pre>	istio-pilot                 ClusterIP      <span class="token number">10.97</span>.192.70     <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">15010</span>/TCP,15011/TCP,15012/TCP,8080/TCP,15014/TCP,443/TCP                                                                                     3d5h</pre></td></tr><tr><td data-num="8"></td><td><pre>	istiod                      ClusterIP      <span class="token number">10.107</span>.202.199   <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">15012</span>/TCP,443/TCP</pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>	$ kubectl get services</pre></td></tr><tr><td data-num="12"></td><td><pre>	NAME                        TYPE           CLUSTER-IP       EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>          AGE</pre></td></tr><tr><td data-num="13"></td><td><pre>	kubernetes                  ClusterIP      <span class="token number">10.3</span>.240.l       <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">443</span>/TCP          34m</pre></td></tr><tr><td data-num="14"></td><td><pre>	kubia-http                  LoadBalancer   <span class="token number">10.3</span>.246.185     <span class="token operator">&lt;</span>pending<span class="token operator">></span>     <span class="token number">8080</span>:31348/TCP   4s</pre></td></tr><tr><td data-num="15"></td><td><pre>	暂时忽略 kubernetes 服务，仔细查看创建的kubian-http 服务 。 它还没有外部 IP 地址 ，因为 Kubernetes 运行的云基础设施创建负载均衡需要一段时间</pre></td></tr><tr><td data-num="16"></td><td><pre>	$ kubectl get services</pre></td></tr><tr><td data-num="17"></td><td><pre>	NAME                        TYPE           CLUSTER-IP       EXTERNAL-IP       PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>          AGE</pre></td></tr><tr><td data-num="18"></td><td><pre>	kubernetes                  ClusterIP      <span class="token number">10.3</span>.240.l       <span class="token operator">&lt;</span>none<span class="token operator">></span>            <span class="token number">443</span>/TCP          34m</pre></td></tr><tr><td data-num="19"></td><td><pre>	kubia-http                  LoadBalancer   <span class="token number">103.246</span>.185      <span class="token number">104</span> <span class="token number">155.74</span>.57     <span class="token number">8080</span>:31348/TCP   4s</pre></td></tr><tr><td data-num="20"></td><td><pre>	现在有外部 IP 了，应用就可以从任何地方通过 http://104.155.74.57:8080 访问</pre></td></tr><tr><td data-num="21"></td><td><pre>	$ <span class="token function">curl</span> <span class="token number">104.155</span>.74.57:8080</pre></td></tr><tr><td data-num="22"></td><td><pre>	You’ve hit kubia-4jfyf</pre></td></tr></table></figure><h3 id="查看service的crd信息"><a class="anchor" href="#查看service的crd信息">#</a> 查看 service 的 CRD 信息</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get svc istio-ingressgateway -n istio-system -oyaml</pre></td></tr></table></figure><h2 id="endpoint-服务"><a class="anchor" href="#endpoint-服务">#</a> endpoint 服务</h2><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl describe svc kubia</pre></td></tr><tr><td data-num="2"></td><td><pre>	Name:              kubia</pre></td></tr><tr><td data-num="3"></td><td><pre>	Namespace:         default</pre></td></tr><tr><td data-num="4"></td><td><pre>	Labels:            <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr><tr><td data-num="5"></td><td><pre>	Annotations:       <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr><tr><td data-num="6"></td><td><pre>	Selector:          <span class="token assign-left variable">app</span><span class="token operator">=</span>kubia		// 用于创建endpoint列表的服务pod选择器</pre></td></tr><tr><td data-num="7"></td><td><pre>	Type:              ClusterIP</pre></td></tr><tr><td data-num="8"></td><td><pre>	IP:                <span class="token number">10.111</span>.88.195</pre></td></tr><tr><td data-num="9"></td><td><pre>	Port:              http  <span class="token number">80</span>/TCP</pre></td></tr><tr><td data-num="10"></td><td><pre>	TargetPort:        <span class="token number">8080</span>/TCP</pre></td></tr><tr><td data-num="11"></td><td><pre>	Endpoints:         <span class="token number">10.44</span>.0.1:8080,10.44.0.2:8080,10.44.0.3:8080		// 服务endpoint的pod的IP和端口列表</pre></td></tr><tr><td data-num="12"></td><td><pre>	Port:              https  <span class="token number">443</span>/TCP</pre></td></tr><tr><td data-num="13"></td><td><pre>	TargetPort:        <span class="token number">8443</span>/TCP</pre></td></tr><tr><td data-num="14"></td><td><pre>	Endpoints:         <span class="token number">10.44</span>.0.1:8443,10.44.0.2:8443,10.44.0.3:8443</pre></td></tr><tr><td data-num="15"></td><td><pre>	Session Affinity:  ClientIP</pre></td></tr><tr><td data-num="16"></td><td><pre>	Events:            <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>	$ kubectl get po -o wide</pre></td></tr><tr><td data-num="19"></td><td><pre>	NAME          READY   STATUS    RESTARTS   AGE   IP          NODE       NOMINATED NODE   READINESS GATES</pre></td></tr><tr><td data-num="20"></td><td><pre>	kubia         <span class="token number">1</span>/1     Running   <span class="token number">0</span>          15h   <span class="token number">10.44</span>.0.4   server02   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr><tr><td data-num="21"></td><td><pre>	kubia-5rvfq   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          15h   <span class="token number">10.44</span>.0.2   server02   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr><tr><td data-num="22"></td><td><pre>	kubia-8cgnm   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          15h   <span class="token number">10.44</span>.0.1   server02   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr><tr><td data-num="23"></td><td><pre>	kubia-8kv8d   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          15h   <span class="token number">10.44</span>.0.3   server02   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr></table></figure><p>Endpoint 资源和其他 Kubernetes 资源一样，所以可以使用 kubectl info 来获取它的基本信息</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get endpoints kubia</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME    ENDPOINTS                                                  AGE</pre></td></tr><tr><td data-num="3"></td><td><pre>	kubia   <span class="token number">10.44</span>.0.1:8443,10.44.0.2:8443,10.44.0.3:8443 + <span class="token number">3</span> more<span class="token punctuation">..</span>.   16h</pre></td></tr></table></figure><p>Endpoint 是一个单独的资源并不 是服务的一个属性，必须手动创建<br>external-service.yaml</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apiVersion: v1</pre></td></tr><tr><td data-num="2"></td><td><pre>	kind: Service</pre></td></tr><tr><td data-num="3"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="4"></td><td><pre>	  name: external-service</pre></td></tr><tr><td data-num="5"></td><td><pre>	spec:</pre></td></tr><tr><td data-num="6"></td><td><pre>	  ports:</pre></td></tr><tr><td data-num="7"></td><td><pre>	  - port: 80</pre></td></tr></table></figure><p>external-service-endpoints.yaml</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apiVersion: v1</pre></td></tr><tr><td data-num="2"></td><td><pre>	kind: Endpoints</pre></td></tr><tr><td data-num="3"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="4"></td><td><pre>	  name: external-service</pre></td></tr><tr><td data-num="5"></td><td><pre>	subsets:</pre></td></tr><tr><td data-num="6"></td><td><pre>	  - addresses:</pre></td></tr><tr><td data-num="7"></td><td><pre>	    - ip: 11.11.11.11</pre></td></tr><tr><td data-num="8"></td><td><pre>	    - ip: 22.22.22.22</pre></td></tr><tr><td data-num="9"></td><td><pre>	    ports:</pre></td></tr><tr><td data-num="10"></td><td><pre>	    - port: 80</pre></td></tr></table></figure><p>部署 service 和 endpoint</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl create -f external-service.yaml</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ kubectl create -f external-service-endpoints.yaml</pre></td></tr><tr><td data-num="3"></td><td><pre>	$ kubectl describe svc/external-service</pre></td></tr><tr><td data-num="4"></td><td><pre>	Name:              external-service</pre></td></tr><tr><td data-num="5"></td><td><pre>	Namespace:         default</pre></td></tr><tr><td data-num="6"></td><td><pre>	Labels:            <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr><tr><td data-num="7"></td><td><pre>	Annotations:       <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr><tr><td data-num="8"></td><td><pre>	Selector:          <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr><tr><td data-num="9"></td><td><pre>	Type:              ClusterIP</pre></td></tr><tr><td data-num="10"></td><td><pre>	IP:                <span class="token number">10.97</span>.153.150</pre></td></tr><tr><td data-num="11"></td><td><pre>	Port:              <span class="token operator">&lt;</span>unset<span class="token operator">></span>  <span class="token number">80</span>/TCP</pre></td></tr><tr><td data-num="12"></td><td><pre>	TargetPort:        <span class="token number">80</span>/TCP</pre></td></tr><tr><td data-num="13"></td><td><pre>	Endpoints:         <span class="token number">11.11</span>.11.11:80,22.22.22.22:80</pre></td></tr><tr><td data-num="14"></td><td><pre>	Session Affinity:  None</pre></td></tr><tr><td data-num="15"></td><td><pre>	Events:            <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr></table></figure><h2 id="暴露service"><a class="anchor" href="#暴露service">#</a> 暴露 service</h2><p>・将服务的类型设置成 NodePort -- 每个集群节点都会在节点上打开一个端口， 对于 NodePort 服务， 每个集群节点在节点本身（因此得名叫 NodePort) 上打开一个端口，并将在该端口上接收到的流量重定向到基础服务。<br>该服务仅在内部集群 IP 和端口上才可访间， 但也可通过所有节点上的专用端口访问.<br>・将服务的类型设置成 LoadBalance, NodePort 类型的一种扩展 -- 这使得服务可以通过一个专用的负载均衡器来访问， 这是由 Kubernetes 中正在运行的云基础设施提供的。 负载均衡器将流量重定向到跨所有节点的节点端口。<br>客户端通过负载均衡器的 IP 连接到服务<br>・创建一 个 Ingress 资源， 这是一 个完全不同的机制， 通过一 个 IP 地址公开多个服务 —— 它运行在 HTTP 层（网络协议第 7 层）上， 因此可以提供比工作在第 4 层的服务更多的功能</p><h3 id="nodeport-类型-service"><a class="anchor" href="#nodeport-类型-service">#</a> NodePort 类型 service</h3><p>指定端口不是强制性的。 如果忽略它，Kubemetes 将选择一个随机端口.<br>客户端发送请求的节点并不重要，整个互联网可以通过任何节点上的 30123 (用户自己定义的) 端口访问到 pod, 如下所示<br>如在个人机器上生成如下 service 和 pod，可以在以前做的项目的任何机器上通过如下访问</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">curl</span> -s http://10.239.140.186:30123 <span class="token punctuation">(</span>master节点的NodeIP:port<span class="token punctuation">)</span>访问服务</pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token function">curl</span> -s http://10.239.140.200:30123 <span class="token punctuation">(</span>worker02节点的NodeIP:port<span class="token punctuation">)</span>访问服务</pre></td></tr></table></figure><p>kubia-svc-nodeport.yaml</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apiVersion: v1</pre></td></tr><tr><td data-num="2"></td><td><pre>	kind: Service</pre></td></tr><tr><td data-num="3"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="4"></td><td><pre>	  name: kubia-nodeport</pre></td></tr><tr><td data-num="5"></td><td><pre>	spec:</pre></td></tr><tr><td data-num="6"></td><td><pre>	  type: NodePort			// 设置服务类型</pre></td></tr><tr><td data-num="7"></td><td><pre>	  ports:</pre></td></tr><tr><td data-num="8"></td><td><pre>	  - port: 80				// 服务集群IP端口号</pre></td></tr><tr><td data-num="9"></td><td><pre>	    targetPort: 8080</pre></td></tr><tr><td data-num="10"></td><td><pre>	    nodePort: 30123			// 通过集群节点(master或worker)的NodeIP，加上30123端口可以访问服务</pre></td></tr><tr><td data-num="11"></td><td><pre>	  selector:</pre></td></tr><tr><td data-num="12"></td><td><pre>	    app: kubia</pre></td></tr></table></figure><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl create -f kubia-svc-nodeport.yaml</pre></td></tr><tr><td data-num="2"></td><td><pre>	</pre></td></tr><tr><td data-num="3"></td><td><pre>	$ kubectl get svc</pre></td></tr><tr><td data-num="4"></td><td><pre>	NAME                 TYPE           CLUSTER-IP      EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>          AGE</pre></td></tr><tr><td data-num="5"></td><td><pre>	kubernetes           ClusterIP      <span class="token number">10.96</span>.0.1       <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">443</span>/TCP          43h</pre></td></tr><tr><td data-num="6"></td><td><pre>	kubia-nodeport       NodePort       <span class="token number">10.103</span>.7.50     <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">80</span>:30123/TCP     99m</pre></td></tr><tr><td data-num="7"></td><td><pre>	</pre></td></tr><tr><td data-num="8"></td><td><pre>	$ kubectl describe svc kubia-nodeport</pre></td></tr><tr><td data-num="9"></td><td><pre>	Name:                     kubia-nodeport</pre></td></tr><tr><td data-num="10"></td><td><pre>	Namespace:                default</pre></td></tr><tr><td data-num="11"></td><td><pre>	Labels:                   <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr><tr><td data-num="12"></td><td><pre>	Annotations:              <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr><tr><td data-num="13"></td><td><pre>	Selector:                 <span class="token assign-left variable">app</span><span class="token operator">=</span>kubia</pre></td></tr><tr><td data-num="14"></td><td><pre>	Type:                     NodePort</pre></td></tr><tr><td data-num="15"></td><td><pre>	IP:                       <span class="token number">10.103</span>.7.50</pre></td></tr><tr><td data-num="16"></td><td><pre>	Port:                     <span class="token operator">&lt;</span>unset<span class="token operator">></span>  <span class="token number">80</span>/TCP</pre></td></tr><tr><td data-num="17"></td><td><pre>	TargetPort:               <span class="token number">8080</span>/TCP</pre></td></tr><tr><td data-num="18"></td><td><pre>	NodePort:                 <span class="token operator">&lt;</span>unset<span class="token operator">></span>  <span class="token number">30123</span>/TCP</pre></td></tr><tr><td data-num="19"></td><td><pre>	Endpoints:                <span class="token number">10.44</span>.0.1:8080,10.44.0.2:8080,10.44.0.3:8080</pre></td></tr><tr><td data-num="20"></td><td><pre>	Session Affinity:         None</pre></td></tr><tr><td data-num="21"></td><td><pre>	External Traffic Policy:  Cluster</pre></td></tr><tr><td data-num="22"></td><td><pre>	Events:                   <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>	$ kubectl get po -o wide</pre></td></tr><tr><td data-num="25"></td><td><pre>	NAME          READY   STATUS    RESTARTS   AGE   IP          NODE       NOMINATED NODE   READINESS GATES</pre></td></tr><tr><td data-num="26"></td><td><pre>	kubia         <span class="token number">1</span>/1     Running   <span class="token number">0</span>          17h   <span class="token number">10.44</span>.0.4   server02   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr><tr><td data-num="27"></td><td><pre>	kubia-5rvfq   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          17h   <span class="token number">10.44</span>.0.2   server02   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr><tr><td data-num="28"></td><td><pre>	kubia-8cgnm   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          17h   <span class="token number">10.44</span>.0.1   server02   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr><tr><td data-num="29"></td><td><pre>	kubia-8kv8d   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          17h   <span class="token number">10.44</span>.0.3   server02   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr></table></figure><p>查看 server02 机器 IP</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token variable">$kubectl</span> get node -o wide</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME       STATUS   ROLES    AGE     VERSION   INTERNAL-IP      EXTERNAL-IP   OS-IMAGE             KERNEL-VERSION      CONTAINER-RUNTIME</pre></td></tr><tr><td data-num="3"></td><td><pre>	alpha      Ready    master   2d18h   v1.18.2   <span class="token number">10.239</span>.140.186   <span class="token operator">&lt;</span>none<span class="token operator">></span>        Ubuntu <span class="token number">18.04</span>.4 LTS   <span class="token number">5.3</span>.0-28-generic    docker://19.3.6</pre></td></tr><tr><td data-num="4"></td><td><pre>	server02   Ready    <span class="token operator">&lt;</span>none<span class="token operator">></span>   2d17h   v1.18.2   <span class="token number">10.239</span>.140.200   <span class="token operator">&lt;</span>none<span class="token operator">></span>        Ubuntu <span class="token number">18.04</span>.4 LTS   <span class="token number">4.15</span>.0-76-generic   docker://19.3.6</pre></td></tr></table></figure><p>两种访问方式</p><ul><li>第一种：通过 NodeIP:Port 访问:</li></ul><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ <span class="token function">curl</span> -s http://10.239.140.200:30123</pre></td></tr><tr><td data-num="2"></td><td><pre>	You<span class="token string">'ve hit kubia-8kv8d</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	$ curl -s http://10.239.140.186:30123</pre></td></tr><tr><td data-num="4"></td><td><pre>	You've hit kubia-5rvfq</pre></td></tr></table></figure><ul><li>第二种：通过 service 的 CLUSTER-IP：port 进入 port 进行访问</li></ul><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl <span class="token builtin class-name">exec</span> kubia -- <span class="token function">curl</span> -s http://10.103.7.50:80</pre></td></tr><tr><td data-num="2"></td><td><pre>	You've hit kubia-8kv8d</pre></td></tr></table></figure><h3 id="loadbalancer-方式访问"><a class="anchor" href="#loadbalancer-方式访问">#</a> LoadBalancer 方式访问</h3><blockquote><p>如果 Kubemetes 在不支持 Load Badancer 服务的环境中运行， 则不会调配负载平衡器， 但该服务仍将表现得像 一 个 NodePort 服 务。 这是因为 LoadBadancer 服务是 NodePo 江服务的扩展<br>如果没有指定特定的节点端口， Kubernetes 将会选择一个端口<br>创建服务后， 云基础架构需要一段时间才能创建负载均衡器并将其 IP 地址写入服务对象。 一旦这样做了， IP 地址将被列为服务的外部 IP 地址</p></blockquote><p>kubia-svc-loadbalancer.yaml</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apiVersion: v1</pre></td></tr><tr><td data-num="2"></td><td><pre>	kind: Service</pre></td></tr><tr><td data-num="3"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="4"></td><td><pre>	  name: kubia-loadbalancer</pre></td></tr><tr><td data-num="5"></td><td><pre>	spec:</pre></td></tr><tr><td data-num="6"></td><td><pre>	  type: LoadBalancer</pre></td></tr><tr><td data-num="7"></td><td><pre>	  ports:</pre></td></tr><tr><td data-num="8"></td><td><pre>	  - port: 80</pre></td></tr><tr><td data-num="9"></td><td><pre>	    targetPort: 8080</pre></td></tr><tr><td data-num="10"></td><td><pre>	  selector:</pre></td></tr><tr><td data-num="11"></td><td><pre>	    app: kubia</pre></td></tr></table></figure><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl create -f kubia-svc-loadbalancer.yaml</pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>	$ kubectl describe svc/kubia-loadbalancer</pre></td></tr><tr><td data-num="4"></td><td><pre>	Name:                     kubia-loadbalancer</pre></td></tr><tr><td data-num="5"></td><td><pre>	Namespace:                default</pre></td></tr><tr><td data-num="6"></td><td><pre>	Labels:                   <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr><tr><td data-num="7"></td><td><pre>	Annotations:              <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr><tr><td data-num="8"></td><td><pre>	Selector:                 <span class="token assign-left variable">app</span><span class="token operator">=</span>kubia</pre></td></tr><tr><td data-num="9"></td><td><pre>	Type:                     LoadBalancer</pre></td></tr><tr><td data-num="10"></td><td><pre>	IP:                       <span class="token number">10.99</span>.184.62</pre></td></tr><tr><td data-num="11"></td><td><pre>	Port:                     <span class="token operator">&lt;</span>unset<span class="token operator">></span>  <span class="token number">80</span>/TCP</pre></td></tr><tr><td data-num="12"></td><td><pre>	TargetPort:               <span class="token number">8080</span>/TCP</pre></td></tr><tr><td data-num="13"></td><td><pre>	NodePort:                 <span class="token operator">&lt;</span>unset<span class="token operator">></span>  <span class="token number">30994</span>/TCP		// yaml资源文件里没有指定, Kubemetes将会选择一个端口</pre></td></tr><tr><td data-num="14"></td><td><pre>	Endpoints:                <span class="token number">10.44</span>.0.1:8080,10.44.0.2:8080,10.44.0.3:8080</pre></td></tr><tr><td data-num="15"></td><td><pre>	Session Affinity:         None</pre></td></tr><tr><td data-num="16"></td><td><pre>	External Traffic Policy:  Cluster</pre></td></tr><tr><td data-num="17"></td><td><pre>	Events:                   <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>	$ kubectl get svc</pre></td></tr><tr><td data-num="20"></td><td><pre>	NAME                 TYPE           CLUSTER-IP      EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>          AGE</pre></td></tr><tr><td data-num="21"></td><td><pre>	kubernetes           ClusterIP      <span class="token number">10.96</span>.0.1       <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">443</span>/TCP          43h</pre></td></tr><tr><td data-num="22"></td><td><pre>	kubia-loadbalancer   LoadBalancer   <span class="token number">10.99</span>.184.62    <span class="token operator">&lt;</span>pending<span class="token operator">></span>     <span class="token number">80</span>:30994/TCP     4m11s</pre></td></tr></table></figure><p>可以看到 Kubemetes 在不支持 Load Badancer 服务的环境中运行 EXTERNAL-IP 显示为 &lt;pending&gt; 状态，但仍然可以像 NodePort 方式一样访问服务</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl <span class="token builtin class-name">exec</span> kubia -- <span class="token function">curl</span> -s http://10.99.184.62:80</pre></td></tr><tr><td data-num="2"></td><td><pre>	You<span class="token string">'ve hit kubia-8cgnm</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	$ curl -s 10.239.140.186:30994		// masterIP：svcPort</pre></td></tr><tr><td data-num="4"></td><td><pre>	You've hit kubia-5rvfq</pre></td></tr><tr><td data-num="5"></td><td><pre>	$ <span class="token function">curl</span> -s <span class="token number">10.239</span>.140.200:30994		// worker01：svcPort</pre></td></tr><tr><td data-num="6"></td><td><pre>	You've hit kubia-8kv8d</pre></td></tr></table></figure><p>如果支持 LoadBalancer 且获得 EXTERNAL-IP 为 130.211.53.173<br>可以通过 $ curl <span class="exturl" data-url="aHR0cDovLzEzMC4yMTEuNTMuMTcz">http://130.211.53.173</span> 进行访问</p><h3 id="ingress-暴露服务"><a class="anchor" href="#ingress-暴露服务">#</a> Ingress 暴露服务</h3><blockquote><p>需要 Ingress 一个重要的原因是每个 LoadBalancer 服务都需要自己的负载均衡器， 以及独有的公有 IP 地址， 而 Ingress 只需要一个公网 IP 就能为许多服务提供访问<br>Ingress 在网络栈 (HTTP) 的应用层操作， 并且可以提供一 些服务不能实现的功能， 诸如基于 cookie 的会话亲和性 (session affinity) 等功能<br>Ingress 对象提供的功能之前，必须强调只有 Ingress 控制器在集群中运行，Ingress 资源才能正常工作。 不同的 Kubernetes 环境使用不同的控制器实现， 但有些并不提供默认控制器<br>Ingress 通常向外暴露 Service.Type=NodePort 或者 Service.Type=LoadBalancer 类型的服务，因此先创建一个 NodePort 类型 svc.</p></blockquote><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get svc</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME                  TYPE           CLUSTER-IP      EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>          AGE</pre></td></tr><tr><td data-num="3"></td><td><pre>	kubia-nodeport        NodePort       <span class="token number">10.103</span>.7.50     <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">80</span>:30123/TCP     144m</pre></td></tr></table></figure><p>创建 kubia-ingress.yaml 资源文件</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apiVersion: networking.k8s.io/v1beta1</pre></td></tr><tr><td data-num="2"></td><td><pre>	kind: Ingress</pre></td></tr><tr><td data-num="3"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="4"></td><td><pre>	  name: kubia</pre></td></tr><tr><td data-num="5"></td><td><pre>	spec:</pre></td></tr><tr><td data-num="6"></td><td><pre>	  rules:</pre></td></tr><tr><td data-num="7"></td><td><pre>	  - host: kubia.example.com				// Ingress 将域名kubia.example.com映射到您的服务</pre></td></tr><tr><td data-num="8"></td><td><pre>	    http:</pre></td></tr><tr><td data-num="9"></td><td><pre>	      paths:</pre></td></tr><tr><td data-num="10"></td><td><pre>	      - path: /</pre></td></tr><tr><td data-num="11"></td><td><pre>	        backend:</pre></td></tr><tr><td data-num="12"></td><td><pre>	          serviceName: kubia-nodeport	// 将所有请求发送到kubia-nodeport服务的80端口</pre></td></tr><tr><td data-num="13"></td><td><pre>	          servicePort: 80</pre></td></tr></table></figure><blockquote><p>kubectl 创建 ingress.yaml 资源文件遇到 webhook ... 错误时修改 master 节点上 /etc/kubernetes/manifests/kube-apiserver.yaml，将 K8s 默认用系统配置的 proxy 注释掉，稍后再运行 kubectl create ... 就可以了</p></blockquote><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl create -f kubia-ingress.yaml</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ kubectl get ingress		// 自己机器上没有获得ADDRESS这列IP</pre></td></tr><tr><td data-num="3"></td><td><pre>	NAME    CLASS    HOSTS               ADDRESS            PORTS   AGE</pre></td></tr><tr><td data-num="4"></td><td><pre>	kubia   <span class="token operator">&lt;</span>none<span class="token operator">></span>   kubia.example.com   <span class="token number">192.168</span>.99.100     <span class="token number">80</span>      92s</pre></td></tr></table></figure><blockquote><p>一旦知道 IP 地址，通过配置 DNS 服务器将 <span class="exturl" data-url="aHR0cDovL2t1YmlhLmV4YW1wbGUuY29t">kubia.example.com</span> 解析为此 IP 地址，或者在 /ect/hosts (Windows 系统为 C:\windows\system32\drivers\etc\hosts ）文件中添加下面一行内容：</p></blockquote><pre><code>	192 168.99.100 kubia.example.com
</code></pre><p>通过 Ingress 访问 pod, 环境都己经建立完毕，可以通过 http ：<span class="exturl" data-url="aHR0cDovL3huLS11YmlhLWZ5NWkuZXhhbXBsZS5jb20=">此 ubia.example.com</span> 地址访 问服务 （使用浏览器或者 curl 命令）</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ <span class="token function">curl</span> http://kubia.example.com</pre></td></tr></table></figure><blockquote><p>客户端如何通过 Ingress 控制器连接到 其 中 一个 pod。客户端首先对 <span class="exturl" data-url="aHR0cDovL2t1YmlhLmV4YW1wbGUuY29t">kubia.example.com</span> 执行 DNS 查 找， DNS 服务器（或本地操作系统）返回了 In gress 控制器的 IP。<br>客户端然后 向 Ingress 控制器发送 HTTP 请求，并在 Host 头中指定 kubia . <span class="exturl" data-url="aHR0cDovL2V4YW1wbGUuY29t">example.com</span>。<br>控制器从该头部确定客户端尝试访 问哪个服务，通过与该服务关联 的 Endpo int 对象查看 pod IP ， 并将客户端的请求转发给其中一个 pod。<br>Ingress 控制器不会将请求转发给该服务，只用它来选择一个 pod。大多数（即使不是全部）控制器都是这样工作的.</p></blockquote><p>Ingress 规范的 rules 和 paths 都是数组，因此它们可以包含多个条目<br>一个 Ingress 可以将 多个主机和路径映射到多个服务</p><ul><li>客户端可以通过一个 IP 地址（ Ingress 控制器的 IP 地址 〉访问两种不同的服务</li><li>同样，可以使用 Ingress 根据 HTTP 请求中的主机而不是（仅）路径映射到不同的服务<br>kubia-ingress.yaml</li></ul><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apiVersion: networking.k8s.io/v1beta1</pre></td></tr><tr><td data-num="2"></td><td><pre>	kind: Ingress</pre></td></tr><tr><td data-num="3"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="4"></td><td><pre>	  name: kubia</pre></td></tr><tr><td data-num="5"></td><td><pre>	spec:</pre></td></tr><tr><td data-num="6"></td><td><pre>	  rules:</pre></td></tr><tr><td data-num="7"></td><td><pre>	  - host: kubia.example.com				// 对 kubia.example.com 的请求将会转发至kubia服务</pre></td></tr><tr><td data-num="8"></td><td><pre>	    http:</pre></td></tr><tr><td data-num="9"></td><td><pre>	      paths:</pre></td></tr><tr><td data-num="10"></td><td><pre>	      - path: /</pre></td></tr><tr><td data-num="11"></td><td><pre>	        backend:</pre></td></tr><tr><td data-num="12"></td><td><pre>	          serviceName: kubia-nodeport</pre></td></tr><tr><td data-num="13"></td><td><pre>	          servicePort: 80</pre></td></tr><tr><td data-num="14"></td><td><pre>	      - path: /kubia					// 对 kubia.example.com/kubia 的请求将会转发至kubia服务</pre></td></tr><tr><td data-num="15"></td><td><pre>	        backend:</pre></td></tr><tr><td data-num="16"></td><td><pre>	          serviceName: kubia</pre></td></tr><tr><td data-num="17"></td><td><pre>	          servicePort: 80</pre></td></tr><tr><td data-num="18"></td><td><pre>	      - path: /foo						// 对 kubia.example.com/foo 的请求将会转发至bar服务</pre></td></tr><tr><td data-num="19"></td><td><pre>	        backend:</pre></td></tr><tr><td data-num="20"></td><td><pre>	          serviceName: bar</pre></td></tr><tr><td data-num="21"></td><td><pre>	          servicePort: 80</pre></td></tr><tr><td data-num="22"></td><td><pre>	  - host: bar.example.com				// 对 bar.example.com 的请求将会转发至bar服务</pre></td></tr><tr><td data-num="23"></td><td><pre>	    http:</pre></td></tr><tr><td data-num="24"></td><td><pre>	      paths:</pre></td></tr><tr><td data-num="25"></td><td><pre>	      - path: /</pre></td></tr><tr><td data-num="26"></td><td><pre>	        backend:</pre></td></tr><tr><td data-num="27"></td><td><pre>	          serviceName: bar</pre></td></tr><tr><td data-num="28"></td><td><pre>	          servicePort: 80</pre></td></tr></table></figure><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get ingress</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME    CLASS    HOSTS                               ADDRESS   PORTS   AGE</pre></td></tr><tr><td data-num="3"></td><td><pre>	kubia   <span class="token operator">&lt;</span>none<span class="token operator">></span>   kubia.example.com,bar.example.com             <span class="token number">80</span>      3s</pre></td></tr></table></figure><p>DNS 需要将 foo .example.com 和 <span class="exturl" data-url="aHR0cDovL2Jhci5leGFtcGxlLmNvbQ==">bar.example.com</span> 域名都指向 Ingress 控制器的 IP 地址.<br>然后像上面一样配置 /ect/hosts 文件内容，就可以通过域名访问了</p><h3 id="ingress处理tls传输"><a class="anchor" href="#ingress处理tls传输">#</a> Ingress 处理 TLS 传输</h3><p>配置 Ingress 以支持 TLS, Ingress 转发 HTTP 流量.</p><h2 id="readiness-probe-就绪探针"><a class="anchor" href="#readiness-probe-就绪探针">#</a> readiness Probe 就绪探针</h2><blockquote><p>了解了存活探针，以及它们如何通过确保异常容器自动重启来保持应用程序的正常运行 。 与存活探针类似， Kubernetes 还允许为容器定义准备就绪探针<br>就绪探测器会定期调用，并确定特定的 pod 是否接收客户端请求 。 当容器的准备就绪探测返回成功时，表示容器己准备好接收请求<br>就绪探针有三种类型:</p></blockquote><ul><li>Exec 探针，执行进程的地方。容器的状态由进程的退出状态代码确定 。</li><li>HTTP GET 探针，向容器发送 HTTP GET 请求，通过响应的 HTTP 状态代码判断容器是否准备好 。</li><li>TCP socket 探针，它打开一个 TCP 连接到容器的指定端口。如果连接己建立，则认为容器己准备就绪</li></ul><p>启动容器时，可以为 Kubernetes 配置一个等待时间，经过等待时间后才可以执行第一次准备就绪检查。<br>之后，它会周期性地调用探针，并根据就绪探针的结果采取行动。<br>如果某个 pod 报告它尚未准备就绪，则会从该服务中删除该 pod。如果 pod 再次准备就绪，则重新添加 pod.<br>存活探针通过杀死异常的容器并用新的正常容器替代它们来保持 pod 正常工作，<br>就绪探针确保只有准备好处理请求的 pod 才可以接收它们（请求）</p><blockquote><p>设想一组 pod (例如， 运行应用程序服务器的 pod) 取决于另 一 个 pod (例如，后端数据库）提供的服务。 如果任何一个前端连接点出现连接间题并且无法再访问数据库， 那么就绪探针可能会告知 Kubemet es 该 pod 没有准备好处理任何请求。 如果其他 pod 实例没有遇到类似的连接问题， 则它们可以正常处理请求。 就绪探针确保客户端只与正常的 pod 交互， 并且永远不会知道系统存在问题.<br>通过 kubectl ed 江命令来向已存在的 ReplicationController 中的 pod 模板添加探针<br>kubia-replicaset-renameport.yaml</p></blockquote><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apiVersion: apps/v1</pre></td></tr><tr><td data-num="2"></td><td><pre>	kind: ReplicaSet</pre></td></tr><tr><td data-num="3"></td><td><pre>	metadata:</pre></td></tr><tr><td data-num="4"></td><td><pre>	  name: kubia</pre></td></tr><tr><td data-num="5"></td><td><pre>	spec:</pre></td></tr><tr><td data-num="6"></td><td><pre>	  replicas: 3</pre></td></tr><tr><td data-num="7"></td><td><pre>	  selector:</pre></td></tr><tr><td data-num="8"></td><td><pre>	    matchLabels:</pre></td></tr><tr><td data-num="9"></td><td><pre>	      app: kubia</pre></td></tr><tr><td data-num="10"></td><td><pre>	  template:</pre></td></tr><tr><td data-num="11"></td><td><pre>	    metadata:</pre></td></tr><tr><td data-num="12"></td><td><pre>	      labels:</pre></td></tr><tr><td data-num="13"></td><td><pre>	        app: kubia</pre></td></tr><tr><td data-num="14"></td><td><pre>	    spec:</pre></td></tr><tr><td data-num="15"></td><td><pre>	      nodeSelector:</pre></td></tr><tr><td data-num="16"></td><td><pre>	        gpu: "true"</pre></td></tr><tr><td data-num="17"></td><td><pre>	      containers:</pre></td></tr><tr><td data-num="18"></td><td><pre>	      - name: kubia</pre></td></tr><tr><td data-num="19"></td><td><pre>	        image: luksa/kubia</pre></td></tr><tr><td data-num="20"></td><td><pre>	        readinessProbe:			// pod中的每个容器都会有一个就绪探针</pre></td></tr><tr><td data-num="21"></td><td><pre>	          exec:</pre></td></tr><tr><td data-num="22"></td><td><pre>	            command:</pre></td></tr><tr><td data-num="23"></td><td><pre>	            - ls</pre></td></tr><tr><td data-num="24"></td><td><pre>	            - /var/ready</pre></td></tr><tr><td data-num="25"></td><td><pre>	        ports:</pre></td></tr><tr><td data-num="26"></td><td><pre>	        - name: http</pre></td></tr><tr><td data-num="27"></td><td><pre>	          containerPort: 8080</pre></td></tr><tr><td data-num="28"></td><td><pre>	        - name: https</pre></td></tr><tr><td data-num="29"></td><td><pre>	          containerPort: 8443</pre></td></tr></table></figure><p>创建 RS 资源并查看 READY 状态</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl create -f kubia-replicaset-renameport.yaml</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ kubectl get po</pre></td></tr><tr><td data-num="3"></td><td><pre>	NAME          READY   STATUS    RESTARTS   AGE</pre></td></tr><tr><td data-num="4"></td><td><pre>	kubia-2xk54   <span class="token number">0</span>/1     Running   <span class="token number">0</span>          6m20s</pre></td></tr><tr><td data-num="5"></td><td><pre>	kubia-bj4tz   <span class="token number">0</span>/1     Running   <span class="token number">0</span>          6m20s</pre></td></tr><tr><td data-num="6"></td><td><pre>	kubia-hr9bx   <span class="token number">0</span>/1     Running   <span class="token number">0</span>          6m21s</pre></td></tr></table></figure><p>通过创建 /var/ready 文件使其中一个文件的就绪探针返回成功，该文件的存在可以模拟就绪探针成功<br>准备就绪探针会定期检查 默认情况下每 10 秒检查一次，最晚 10 秒钟内， 该 pod 应该已经准备就绪.</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl <span class="token builtin class-name">exec</span> po/kubia-2xk54 -- <span class="token function">touch</span> /var/ready</pre></td></tr><tr><td data-num="2"></td><td><pre>	$ kubectl get po</pre></td></tr><tr><td data-num="3"></td><td><pre>	NAME          READY   STATUS    RESTARTS   AGE</pre></td></tr><tr><td data-num="4"></td><td><pre>	kubia-2xk54   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          6m26s</pre></td></tr><tr><td data-num="5"></td><td><pre>	kubia-bj4tz   <span class="token number">0</span>/1     Running   <span class="token number">0</span>          6m26s</pre></td></tr><tr><td data-num="6"></td><td><pre>	kubia-hr9bx   <span class="token number">0</span>/1     Running   <span class="token number">0</span>          6m27s</pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>	$ kubectl describe po/kubia-2xk54</pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	Readiness:      <span class="token builtin class-name">exec</span> <span class="token punctuation">[</span>ls /var/ready<span class="token punctuation">]</span> <span class="token assign-left variable">delay</span><span class="token operator">=</span>0s <span class="token assign-left variable">timeout</span><span class="token operator">=</span>1s <span class="token assign-left variable">period</span><span class="token operator">=</span>10s <span class="token comment">#success=1 #failure=3</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span></pre></td></tr></table></figure><p>修改创建过的 RS 的资源文件里的 readiness 命令是不生效的，除非删了重建，查看 readiness Probe 如下</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl edit rc kubia</pre></td></tr></table></figure><h3 id="再次测试-readiness"><a class="anchor" href="#再次测试-readiness">#</a> 再次测试 readiness</h3><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get po</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME          READY   STATUS    RESTARTS   AGE</pre></td></tr><tr><td data-num="3"></td><td><pre>	kubia-2xk54   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          6m20s</pre></td></tr><tr><td data-num="4"></td><td><pre>	kubia-bj4tz   <span class="token number">0</span>/1     Running   <span class="token number">0</span>          6m20s</pre></td></tr><tr><td data-num="5"></td><td><pre>	kubia-hr9bx   <span class="token number">0</span>/1     Running   <span class="token number">0</span>          6m21s</pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>	$ <span class="token builtin class-name">exec</span> kubia-2xk54 -- <span class="token function">rm</span> -rf /var/ready		// 过大概10s后</pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>	$ kubectl get po</pre></td></tr><tr><td data-num="10"></td><td><pre>	NAME          READY   STATUS    RESTARTS   AGE</pre></td></tr><tr><td data-num="11"></td><td><pre>	kubia-2xk54   <span class="token number">0</span>/1     Running   <span class="token number">0</span>          6m30s</pre></td></tr><tr><td data-num="12"></td><td><pre>	kubia-bj4tz   <span class="token number">0</span>/1     Running   <span class="token number">0</span>          6m30s</pre></td></tr><tr><td data-num="13"></td><td><pre>	kubia-hr9bx   <span class="token number">0</span>/1     Running   <span class="token number">0</span>          6m31s</pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>	$ kubectl <span class="token builtin class-name">exec</span> kubia-bj4tz -- <span class="token function">touch</span> /var/ready	// 过大概10s后</pre></td></tr><tr><td data-num="16"></td><td><pre>	$ kubectl get svc</pre></td></tr><tr><td data-num="17"></td><td><pre>	NAME          READY   STATUS    RESTARTS   AGE   IP          NODE       NOMINATED NODE   READINESS GATES</pre></td></tr><tr><td data-num="18"></td><td><pre>	kubia-2xk54   <span class="token number">0</span>/1     Running   <span class="token number">0</span>          6m40s   <span class="token number">10.44</span>.0.2   server02   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr><tr><td data-num="19"></td><td><pre>	kubia-bj4tz   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          6m40s   <span class="token number">10.44</span>.0.3   server02   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr><tr><td data-num="20"></td><td><pre>	kubia-hr9bx   <span class="token number">0</span>/1     Running   <span class="token number">0</span>          6m40s   <span class="token number">10.44</span>.0.1   server02   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span></pre></td></tr></table></figure><p>查看 SVC</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ kubectl get svc	// 也可以通过kubectl <span class="token builtin class-name">exec</span> kubia-bj4tz <span class="token function">env</span> 来查看POD所支持的所有SVC的IP等信息</pre></td></tr><tr><td data-num="2"></td><td><pre>	NAME                  TYPE           CLUSTER-IP      EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>          AGE</pre></td></tr><tr><td data-num="3"></td><td><pre>	kubia                 ClusterIP      <span class="token number">10.111</span>.88.195   <span class="token operator">&lt;</span>none<span class="token operator">></span>        <span class="token number">80</span>/TCP,443/TCP   22h</pre></td></tr><tr><td data-num="4"></td><td><pre>	kubia-loadbalancer    LoadBalancer   <span class="token number">10.102</span>.224.77   <span class="token operator">&lt;</span>pending<span class="token operator">></span>     <span class="token number">80</span>:32671/TCP     3h8m</pre></td></tr></table></figure><p>两种访问方式，POD 和 Node<br>第一种 POD 访问 SvcIP:SvcPort 方式</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token variable">$kubectl</span> <span class="token builtin class-name">exec</span> kubia -- <span class="token function">curl</span> -s  http://10.111.88.195:80		// SvcIP:SvcPort, SvcPort映射到PodIP, 可以通过describe svc查看</pre></td></tr><tr><td data-num="2"></td><td><pre>	You've hit kubia-bj4tz</pre></td></tr></table></figure><p>第二种 NodeIP:NodePOrt 方式</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ <span class="token function">curl</span> -s <span class="token number">10.239</span>.140.186:32671		// NodeIP:NodePort</pre></td></tr><tr><td data-num="2"></td><td><pre>	You've hit kubia-bj4tz</pre></td></tr></table></figure><p>应该通过删除 pod 或更改 pod 标签而不是手动更改探针来从服务中手动移除 pod.<br>如果想要从某个服务中手动添加或删除 pod, 请将 enabled=true 作为标签添加到 pod, 以及服务的标签选择器中。 当想要从服务中移除 pod 时，删除标签<br>应该始终定义一 个就绪探针， 即使它只是向基准 URL 发送 HTTP 请求一样简单。</p><h2 id="headless-服务"><a class="anchor" href="#headless-服务">#</a> headless 服务</h2><p>让客户端连接到所有 pod, 需要找出每个 pod 的 IP.Kubemetes 允许客户通过 DNS 查找发现 pod IP.<br>但是对千 headless 服务， 由于 DNS 返回了 pod 的 IP, 客户端直接连接到该 pod, 而不是通过服务代理.<br>headless 服务仍然提供跨 pod 的负载平衡， 但是通过 DNS 轮询机制不是通过服务代理.</p><blockquote><p>如果告诉 Kubemetes, 不需要为服务提供集群 IP (通过在服务 spec 中将 clusterIP 字段设置为 None 来完成此操作）， 则 DNS 服务器将返回 pod IP 而不是单个服务 IP<br>将服务 spec 中的 clusterIP 字段设置为 None 会使服务成 为 headless 服务，因为 Kubemetes 不会 为其分配集群 IP, 客户端可通过该 IP 将其连接到支持它的 pod<br>kubia-svc-headless.yaml</p></blockquote><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>apiersion: v1</pre></td></tr><tr><td data-num="2"></td><td><pre>	kin: Service</pre></td></tr><tr><td data-num="3"></td><td><pre>	metdata:</pre></td></tr><tr><td data-num="4"></td><td><pre>	  nme: kubia-headless</pre></td></tr><tr><td data-num="5"></td><td><pre>	spe:</pre></td></tr><tr><td data-num="6"></td><td><pre>	  custerIP: None		// clusterIP字段设置为None 会使服务成 为headless服务</pre></td></tr><tr><td data-num="7"></td><td><pre>	  prts:</pre></td></tr><tr><td data-num="8"></td><td><pre>	  -port: 80</pre></td></tr><tr><td data-num="9"></td><td><pre>	   targetPort: 8080</pre></td></tr><tr><td data-num="10"></td><td><pre>	  slector:</pre></td></tr><tr><td data-num="11"></td><td><pre>	    app: kubia</pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>	$ kubectl create -f kubia-svc-headless.yaml</pre></td></tr><tr><td data-num="14"></td><td><pre>	$ kubectl get svc</pre></td></tr><tr><td data-num="15"></td><td><pre>	NAME                  TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</pre></td></tr><tr><td data-num="16"></td><td><pre>	kubia-headless        ClusterIP      None            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>none</span><span class="token punctuation">></span></span>        80/TCP           103s</pre></td></tr></table></figure><div class="tags"><a href="/tags/kubernetes/" rel="tag"><i class="ic i-tag"></i> kubernetes</a></div></div><footer><div class="meta"></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Kung-Fu-Master 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Kung-Fu-Master 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="Kung-Fu-Master 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Kung-Fu-Master <i class="ic i-at"><em>@</em></i>Hexo</li><li class="link"><strong>本文链接：</strong> <a href="https://kung-fu-master.github.io/2021/03/13/micro_service/kubernetes/04_kubernetes_service/" title="04 Kubernetes service">https://kung-fu-master.github.io/2021/03/13/micro_service/kubernetes/04_kubernetes_service/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2021/03/13/micro_service/kubernetes/03_kubernetes_ns_pod/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclxxcb6rj20zk0m8b29.jpg" title="03 Kubernetes nodes, namespace, pod"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> kubernetes</span><h3>03 Kubernetes nodes, namespace, pod</h3></a></div><div class="item right"><a href="/2021/03/13/micro_service/kubernetes/01_kubernetes_build/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclxfdlttj20zk0m8npd.jpg" title="01 Kubernetes build with kubeadm"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> kubernetes</span><h3>01 Kubernetes build with kubeadm</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#kubernetes-service"><span class="toc-number">1.</span> <span class="toc-text"># Kubernetes Service</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#service"><span class="toc-number">2.</span> <span class="toc-text"># service</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#affinity-亲和性"><span class="toc-number">2.1.</span> <span class="toc-text"># Affinity 亲和性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#环境变量发现service"><span class="toc-number">3.</span> <span class="toc-text"># 环境变量发现 service</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建replicaset-管理-3-个-pod"><span class="toc-number">3.1.</span> <span class="toc-text"># 创建 replicaSet 管理 3 个 POD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除service"><span class="toc-number">3.2.</span> <span class="toc-text"># 删除 service</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#service-samples"><span class="toc-number">4.</span> <span class="toc-text"># Service samples</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#查看service"><span class="toc-number">4.1.</span> <span class="toc-text"># 查看 service</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看service的crd信息"><span class="toc-number">4.2.</span> <span class="toc-text"># 查看 service 的 CRD 信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#endpoint-服务"><span class="toc-number">5.</span> <span class="toc-text"># endpoint 服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#暴露service"><span class="toc-number">6.</span> <span class="toc-text"># 暴露 service</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nodeport-类型-service"><span class="toc-number">6.1.</span> <span class="toc-text"># NodePort 类型 service</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loadbalancer-方式访问"><span class="toc-number">6.2.</span> <span class="toc-text"># LoadBalancer 方式访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ingress-暴露服务"><span class="toc-number">6.3.</span> <span class="toc-text"># Ingress 暴露服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ingress处理tls传输"><span class="toc-number">6.4.</span> <span class="toc-text"># Ingress 处理 TLS 传输</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#readiness-probe-就绪探针"><span class="toc-number">7.</span> <span class="toc-text"># readiness Probe 就绪探针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#再次测试-readiness"><span class="toc-number">7.1.</span> <span class="toc-text"># 再次测试 readiness</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#headless-服务"><span class="toc-number">8.</span> <span class="toc-text"># headless 服务</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2021/03/13/micro_service/kubernetes/02_kubernetes_roles_introduction/" rel="bookmark" title="02 kubernetes introduction">02 kubernetes introduction</a></li><li><a href="/2021/03/13/micro_service/kubernetes/01_etcd_high_availablity/" rel="bookmark" title="01 部署external etcd集群">01 部署external etcd集群</a></li><li><a href="/2021/03/13/micro_service/kubernetes/01_kubernetes%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F%E5%92%8C%E9%85%8D%E7%BD%AE%E6%9D%A1%E4%BB%B6/" rel="bookmark" title="01 Kubernetes安装方式和配置条件">01 Kubernetes安装方式和配置条件</a></li><li><a href="/2021/03/13/micro_service/kubernetes/01_kubernetes_high_availablity_build/" rel="bookmark" title="01 Kubernetes build high availability">01 Kubernetes build high availability</a></li><li><a href="/2021/03/13/micro_service/kubernetes/01_kubernetes_build/" rel="bookmark" title="01 Kubernetes build with kubeadm">01 Kubernetes build with kubeadm</a></li><li class="active"><a href="/2021/03/13/micro_service/kubernetes/04_kubernetes_service/" rel="bookmark" title="04 Kubernetes service">04 Kubernetes service</a></li><li><a href="/2021/03/13/micro_service/kubernetes/03_kubernetes_ns_pod/" rel="bookmark" title="03 Kubernetes nodes, namespace, pod">03 Kubernetes nodes, namespace, pod</a></li><li><a href="/2021/03/13/micro_service/kubernetes/05_kubernetes_volume/" rel="bookmark" title="05 Kubernetes volumes">05 Kubernetes volumes</a></li><li><a href="/2021/03/13/micro_service/kubernetes/06_kubernetes_deployment/" rel="bookmark" title="06 Kubernetes deployment">06 Kubernetes deployment</a></li><li><a href="/2021/03/13/micro_service/kubernetes/07_kubernetes_Etcd/" rel="bookmark" title="07 Kubernetes Etcd">07 Kubernetes Etcd</a></li><li><a href="/2021/03/13/micro_service/kubernetes/10_kubernetes_plugin/" rel="bookmark" title="10 Kubernetes plugin">10 Kubernetes plugin</a></li><li><a href="/2021/03/13/micro_service/kubernetes/09_kubernetes_certificate/" rel="bookmark" title="09 Kubernetes Certificates">09 Kubernetes Certificates</a></li><li><a href="/2021/03/13/micro_service/kubernetes/k8s_port_forward/" rel="bookmark" title="使用端口转发(Port Forwarding)来访问集群中的应用">使用端口转发(Port Forwarding)来访问集群中的应用</a></li><li><a href="/2021/03/13/micro_service/kubernetes/08_kubernetes_samples_problems/" rel="bookmark" title="08 Kubernetes samples and problems">08 Kubernetes samples and problems</a></li><li><a href="/2021/03/13/micro_service/kubernetes/k8s%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/" rel="bookmark" title="k8s操作命令">k8s操作命令</a></li><li><a href="/2021/03/13/micro_service/kubernetes/k8s_command_args_entrypoint_cmd%E5%8C%BA%E5%88%AB/" rel="bookmark" title="k8s command, args, entrypoint, cmd 区别">k8s command, args, entrypoint, cmd 区别</a></li><li><a href="/2021/03/13/micro_service/kubernetes/k8s_configmap/" rel="bookmark" title="k8s configmap">k8s configmap</a></li><li><a href="/2021/03/13/micro_service/kubernetes/k8s_node%E8%8A%82%E7%82%B9reset%E5%90%8E%E9%87%8D%E6%96%B0%E5%8A%A0%E5%85%A5%E9%9B%86%E7%BE%A4/" rel="bookmark" title="k8s node 节点reset后重新加入集群">k8s node 节点reset后重新加入集群</a></li><li><a href="/2021/03/13/micro_service/kubernetes/k8s_resources%E5%92%8C%E9%A9%B1%E9%80%90%E7%AD%96%E7%95%A5/" rel="bookmark" title="k8s resources和驱逐策略">k8s resources和驱逐策略</a></li><li><a href="/2021/03/13/micro_service/kubernetes/k8s_%E5%AF%B9%E8%B1%A1%E5%90%8D%E7%A7%B0%E5%92%8CIDs/" rel="bookmark" title="k8s_对象名称和IDs">k8s_对象名称和IDs</a></li><li><a href="/2021/03/13/micro_service/kubernetes/k8s%20encounter%20problem/" rel="bookmark" title="k8s部署遇到的问题">k8s部署遇到的问题</a></li><li><a href="/2021/03/13/micro_service/kubernetes/k8s_secret/" rel="bookmark" title="k8s secret">k8s secret</a></li><li><a href="/2021/03/13/micro_service/kubernetes/metrics-server,kubernetes-dashboard/" rel="bookmark" title="Metrics-Server, Kubernetes-Dashboard">Metrics-Server, Kubernetes-Dashboard</a></li><li><a href="/2021/03/13/micro_service/kubernetes/kubernetes_upgrade/" rel="bookmark" title="kubernetes upgrade">kubernetes upgrade</a></li><li><a href="/2021/03/13/micro_service/kubernetes/kubernetes_%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/" rel="bookmark" title="kubernetes 准入控制">kubernetes 准入控制</a></li><li><a href="/2021/03/13/micro_service/kubernetes/k8s%E9%87%8D%E6%96%B0%E5%90%AF%E5%8A%A8pod%E7%AD%89%E8%B5%84%E6%BA%90/" rel="bookmark" title="k8s重新启动pod等资源">k8s重新启动pod等资源</a></li><li><a href="/2021/03/13/micro_service/kubernetes/%E5%88%A0%E9%99%A4crd,pod,pv,pvc%E7%AD%89%E8%B5%84%E6%BA%90/" rel="bookmark" title="删除crd,pod,pv,pvc等资源">删除crd,pod,pv,pvc等资源</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Kung-Fu-Master" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Kung-Fu-Master</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">292</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">40</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">12</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lvdXJuYW1l" title="https:&#x2F;&#x2F;github.com&#x2F;yourname"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yourname"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPXlvdXJpZA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;yourid"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2021/03/13/micro_service/kubernetes/03_kubernetes_ns_pod/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2021/03/13/micro_service/kubernetes/01_kubernetes_build/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/microService/" title="分类于 microService">microService</a> <i class="ic i-angle-right"></i> <a href="/categories/microService/istio/" title="分类于 istio">istio</a></div><span><a href="/2021/03/13/micro_service/istio/istio_01_conception/" title="Istio 01 conception">Istio 01 conception</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/reference/" title="分类于 reference">reference</a> <i class="ic i-angle-right"></i> <a href="/categories/reference/k8s/" title="分类于 k8s">k8s</a></div><span><a href="/2021/03/13/reference/k8s/21.%E5%AE%B9%E5%99%A8%E5%8C%96%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%84%8F%E4%B9%89%EF%BC%9ADaemonSet/" title="21 | 容器化守护进程的意义：DaemonSet">21 | 容器化守护进程的意义：DaemonSet</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/microService/" title="分类于 microService">microService</a> <i class="ic i-angle-right"></i> <a href="/categories/microService/istio/" title="分类于 istio">istio</a></div><span><a href="/2021/03/13/micro_service/istio/istio_04_inject/" title="istio 04 sidecar inject">istio 04 sidecar inject</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/linux/" title="分类于 linux">linux</a></div><span><a href="/2021/03/13/linux/yum%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%89%E8%A3%85cmake-3%E7%89%88%E6%9C%AC%E4%B8%8A/" title="yum使用和安装cmake 3 版本上">yum使用和安装cmake 3 版本上</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/linux/" title="分类于 linux">linux</a></div><span><a href="/2021/03/13/linux/cut/" title="cut">cut</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/linux/" title="分类于 linux">linux</a></div><span><a href="/2021/03/13/linux/EOF/" title="EOF">EOF</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/language/" title="分类于 language">language</a> <i class="ic i-angle-right"></i> <a href="/categories/language/cpp/" title="分类于 cpp">cpp</a></div><span><a href="/2021/03/13/language/cpp/09_%E5%BC%82%E5%B8%B8/" title="09 异常">09 异常</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/technologies/" title="分类于 technologies">technologies</a> <i class="ic i-angle-right"></i> <a href="/categories/technologies/security/" title="分类于 security">security</a></div><span><a href="/2021/03/13/technologies/security/ECDHE-RSA-AES256-GCM-SHA384%E8%A7%A3%E9%87%8A/" title="ECDHE-RSA-AES256-GCM-SHA384 解释">ECDHE-RSA-AES256-GCM-SHA384 解释</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/DLearning/" title="分类于 DLearning">DLearning</a></div><span><a href="/2021/03/13/DLearning/deeplearning_01_get_started/" title="deeplearning 01 getting started">deeplearning 01 getting started</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/linux/" title="分类于 linux">linux</a></div><span><a href="/2021/03/13/linux/BIOS/" title="BIOS">BIOS</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Kung-Fu-Master @ Kung Fu Master</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">1.1m 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">16:30</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2021/03/13/micro_service/kubernetes/04_kubernetes_service/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->